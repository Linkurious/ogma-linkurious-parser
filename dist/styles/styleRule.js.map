{"version":3,"file":"styleRule.js","sourceRoot":"","sources":["../../src/styles/styleRule.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2018\n *\n * Created by maximeallex on 2018-04-19.\n */\n\n'use strict';\n\nimport {\n  EdgeStyle,\n  IStyleRule,\n  LkEdgeData,\n  LkNodeData,\n  NodeStyle,\n  SelectorType\n} from '@linkurious/rest-client';\n\nimport {ItemAttributes, Tools} from '..';\n\nexport class StyleRule implements IStyleRule<NodeStyle | EdgeStyle> {\n  public type: SelectorType;\n  public input: string[] | undefined;\n  public index: number;\n  public itemType?: string;\n  public value: any;\n  public style: any;\n\n  constructor(model: IStyleRule<NodeStyle | EdgeStyle>) {\n    this.type = model.type;\n    this.input = model.input;\n    this.index = model.index;\n    this.itemType = model.itemType;\n    this.style = model.style;\n    this.value = model.value;\n  }\n\n  /**\n   * Return an int describing specificity of the style. 4 = very specific / 1 = not specific\n   *\n   * @return {number}\n   */\n  get specificity(): number {\n    if (this.itemType !== undefined && this.input !== undefined) {\n      return 4;\n    }\n    if (this.itemType === undefined && this.input !== undefined) {\n      return 3;\n    }\n    if (this.itemType !== undefined && this.input === undefined) {\n      return 2;\n    }\n    return 1;\n  }\n\n  /**\n   * Return true if this style match values\n   */\n  public matchValues(itemType: string | null, input: Array<string>, value: any): boolean {\n    if (Tools.isDefined(input)) {\n      return (\n        ((itemType === this.itemType || !Tools.isDefined(this.itemType)) &&\n          Tools.isEqual(['properties', ...input], this.input) &&\n          Tools.isEqual(value, this.value)) ||\n        (this.type === 'any' &&\n          !Tools.isDefined(this.input) &&\n          typeof this.style.color === 'object' &&\n          this.style.color.input[1] === input[0])\n      );\n    }\n\n    if (Tools.isDefined(this.itemType)) {\n      return itemType === this.itemType && !Tools.isDefined(this.input);\n    }\n\n    return !Tools.isDefined(this.input);\n  }\n\n  public static inputExists(\n    type: SelectorType,\n    input: Array<string> | undefined\n  ): input is Array<string> {\n    return type !== SelectorType.ANY;\n  }\n\n  /**\n   * Return true if a style can apply to a node\n   */\n  public canApplyTo(data: LkNodeData | LkEdgeData): boolean {\n    const types = 'categories' in data ? data.categories : [data.type];\n    let typePredicate = false;\n    switch (this.type) {\n      case SelectorType.ANY:\n        typePredicate = StyleRule.checkAny(data, this.style);\n        break;\n\n      case SelectorType.NO_VALUE:\n        if (StyleRule.inputExists(this.type, this.input)) {\n          typePredicate = StyleRule.checkNoValue(data, this.input);\n        }\n        break;\n\n      case SelectorType.NAN:\n        if (StyleRule.inputExists(this.type, this.input)) {\n          typePredicate = StyleRule.checkNan(data, this.input);\n        }\n        break;\n\n      case SelectorType.RANGE:\n        if (StyleRule.inputExists(this.type, this.input)) {\n          typePredicate = StyleRule.checkRange(Tools.getIn(data, this.input), this.value);\n        }\n        break;\n\n      case SelectorType.IS:\n        if (StyleRule.inputExists(this.type, this.input)) {\n          typePredicate = StyleRule.checkIs(data, this.input, this.value);\n        }\n        break;\n    }\n    return typePredicate && StyleRule.checkItemType(types, this.itemType);\n  }\n\n  /**\n   * Return true or false on rule type 'any' if the current node match the rule\n   */\n  public static checkAny(data: LkNodeData | LkEdgeData, style: NodeStyle | EdgeStyle): boolean {\n    // return true if autoColor by a property and this property exists in node\n    if (typeof style.color === 'object') {\n      return Tools.isDefined(Tools.getIn(data, style.color.input));\n    }\n    return true;\n  }\n\n  /**\n   * Return true or false on rule type 'noValue' if the current node match the rule\n   */\n  public static checkNoValue(data: LkNodeData | LkEdgeData, input: Array<string>): boolean {\n    return !Tools.valueExists(Tools.getIn(data, input));\n  }\n\n  /**\n   * Return true or false on rule type 'NaN' if the current node match the rule\n   */\n  public static checkNan(data: LkNodeData | LkEdgeData, input: Array<string>): boolean {\n    return !Tools.isNumber(Tools.getIn(data, input));\n  }\n\n  /**\n   * Return true if predicate is true for the node value\n   *\n   * @param value\n   * @param comparator\n   * @return {boolean}\n   */\n  public static checkRange(value: number, comparator: {[key: string]: number}): boolean {\n    const operators = Object.keys(comparator);\n    return operators.every((op) => {\n      switch (op) {\n        case '<=':\n          return value <= comparator[op];\n\n        case '<':\n          return value < comparator[op];\n\n        case '>':\n          return value > comparator[op];\n\n        case '>=':\n          return value >= comparator[op];\n      }\n    });\n  }\n\n  /**\n   * Return true or false on rule type 'is' if the current node match the rule\n   */\n  public static checkIs(data: LkNodeData | LkEdgeData, input: Array<string>, value: any): boolean {\n    if (!Tools.isDefined(input)) {\n      return false;\n    }\n    const itemValue = Tools.getIn(data, input);\n    let formattedValue = itemValue;\n    if (\n      Tools.isDefined(itemValue) &&\n      typeof itemValue === 'object' &&\n      (itemValue.type === 'date' || itemValue.type === 'datetime')\n    ) {\n      let timezone = itemValue.timezone;\n      if (itemValue.timezone === 'Z') {\n        timezone = '+00:00';\n      }\n      formattedValue = Tools.formatDate(\n        itemValue.value,\n        itemValue.type === 'datetime',\n        Tools.timezoneToMilliseconds(timezone) / 1000\n      );\n    }\n    return Tools.isEqual(formattedValue, value);\n  }\n\n  /**\n   * Check that value of itemType match for the node\n   */\n  public static checkItemType(types: Array<string>, itemType: string | undefined): boolean {\n    return (\n      (itemType !== undefined && StyleRule.matchCategory(types, itemType)) ||\n      StyleRule.matchAny(itemType)\n    );\n  }\n\n  /**\n   * Return true if itemType is defined and category exists in an array of categories\n   *\n   * @param {Array<string> | string} types\n   * @param {string} itemType\n   * @return {boolean}\n   */\n  public static matchCategory(types: Array<string> | string, itemType: string): boolean {\n    return (\n      Tools.isDefined(itemType) &&\n      (Array.isArray(types) ? types.includes(itemType) : Tools.isEqual(types, itemType))\n    );\n  }\n\n  /**\n   * Return true if itemType is undefined\n   *\n   * @param {string} itemType\n   * @return {boolean}\n   */\n  public static matchAny(itemType: any | null): boolean {\n    return itemType === undefined;\n  }\n\n  /**\n   * Return the color for a type\n   */\n  public getTypeColor(type: string): string | undefined | null {\n    let color;\n    if (\n      StyleRule.checkItemType([type], this.itemType) &&\n      this.type === SelectorType.ANY &&\n      !Tools.isDefined(this.input)\n    ) {\n      color = ItemAttributes.getTypeColor(this, type);\n    }\n    return color;\n  }\n}\n"]}
{"version":3,"file":"nodeAttributes.js","sourceRoot":"","sources":["../../src/styles/nodeAttributes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2018\n *\n * Created by maximeallex on 2018-05-21.\n */\n\n'use strict';\nimport {Color} from 'ogma';\nimport {LkNodeData, OgmaNodeShape, StyleIcon, StyleImage} from '@linkurious/rest-client';\nimport sha1 from 'sha1';\n\nimport {Tools} from '..';\n\nimport {StyleRule} from './styleRule';\nimport {BASE_GREY, ItemAttributes} from './itemAttributes';\n\nexport interface OgmaImage extends StyleImage {\n  url?: string;\n}\n\nexport class NodeAttributes extends ItemAttributes {\n  constructor(rulesMap: {\n    color?: Array<StyleRule>;\n    icon?: Array<StyleRule>;\n    image?: Array<StyleRule>;\n    shape?: Array<StyleRule>;\n    size?: Array<StyleRule>;\n  }) {\n    super(rulesMap);\n  }\n\n  /**\n   * Run the callback if an item match with a style in the array of rules\n   */\n  private matchStyle(\n    styleRules: Array<StyleRule>,\n    itemData: LkNodeData,\n    callback: (style: StyleRule) => unknown\n  ): void {\n    if (!Tools.isDefined(itemData)) {\n      return;\n    }\n    if (!Tools.isDefined(styleRules)) {\n      return;\n    }\n    for (let i = 0; i < styleRules.length; ++i) {\n      if (styleRules[i].canApplyTo(itemData)) {\n        callback(styleRules[i]);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Generate color for a given node (call only if _rulesMap.color is defined\n   */\n  public color(itemData: LkNodeData): Color | Array<Color> {\n    if (!Tools.isDefined(itemData)) {\n      return [BASE_GREY];\n    }\n    const hash = sha1(JSON.stringify(itemData));\n    const cachedColor = this.colorsCache.get(hash);\n    if (cachedColor !== undefined) {\n      return cachedColor;\n    }\n    let colors = [];\n    for (let i = 0; i < itemData.categories.length; ++i) {\n      let c = null;\n      for (let j = 0; j < this._rulesMap.color!.length; ++j) {\n        const rule = this._rulesMap.color![j];\n        if (\n          rule.itemType !== undefined &&\n          rule.itemType !== null &&\n          rule.itemType !== itemData.categories[i]\n        ) {\n          continue;\n        }\n        if (rule.canApplyTo(itemData)) {\n          if (typeof rule.style.color === 'object') {\n            const propValue = Tools.getInUnsafe(itemData, rule.style.color.input);\n            if (Array.isArray(propValue)) {\n              c = ItemAttributes.autoColor(itemData.categories[i], rule.style.ignoreCase);\n            } else {\n              c = ItemAttributes.autoColor(`${propValue}`, rule.style.ignoreCase);\n            }\n          } else {\n            c = rule.style.color;\n          }\n          break;\n        }\n      }\n      colors.push(c);\n    }\n    colors = colors.filter((c) => Tools.isDefined(c));\n    if (colors.length === 0) {\n      colors = [BASE_GREY];\n    }\n    const finalColor = colors.length === 1 ? colors[0] : colors;\n    this.colorsCache.set(hash, finalColor);\n    return finalColor;\n  }\n\n  /**\n   * Generate icon for a given node\n   */\n  public icon(\n    itemData: LkNodeData\n  ): {\n    icon?: StyleIcon;\n    image?: OgmaImage | null;\n  } {\n    const rawColors = this.color(itemData);\n    const color = Array.isArray(rawColors) ? rawColors[0] : rawColors;\n    let result = {};\n    const rules = [...(this._rulesMap.image || []), ...(this._rulesMap.icon || [])];\n    if (!Tools.isDefined(itemData)) {\n      return {\n        icon: {},\n        image: {}\n      };\n    }\n    for (let i = 0; i < rules.length; ++i) {\n      if (rules[i].canApplyTo(itemData)) {\n        if ('icon' in rules[i].style) {\n          result = {\n            icon: {\n              content: rules[i].style.icon.content,\n              font: rules[i].style.icon.font,\n              scale: 0.5,\n              color: Tools.isBright(color) ? '#000000' : '#FFFFFF'\n            }\n          };\n        } else if ('image' in rules[i].style) {\n          result = {\n            image: {\n              url:\n                Tools.getType(rules[i].style.image.url) === 'imageUrl' ||\n                Tools.getType(rules[i].style.image.url) === 'image'\n                  ? rules[i].style.image.url\n                  : Tools.getIn(itemData, rules[i].style.image.url.path),\n              scale: rules[i].style.image.scale,\n              fit: rules[i].style.image.fit,\n              tile: rules[i].style.image.tile,\n              minVisibleSize: 0\n            }\n          };\n        }\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate shape for a given node\n   */\n  public shape(itemData: LkNodeData): OgmaNodeShape | undefined {\n    let result = undefined;\n    if (this._rulesMap.shape !== undefined) {\n      this.matchStyle(this._rulesMap.shape, itemData, (styleRule) => {\n        result = styleRule.style.shape;\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Generate size for a given node\n   */\n  public size(itemData: LkNodeData): number | undefined {\n    let result = undefined;\n    if (this._rulesMap.size !== undefined) {\n      this.matchStyle(this._rulesMap.size, itemData, (styleRule) => {\n        result = styleRule.style.size;\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Return an object containing all node attributes needed by Ogma to style a node\n   */\n  public all(\n    itemData: LkNodeData\n  ): {\n    radius?: number | undefined;\n    color: Color | Array<Color>;\n    shape?: OgmaNodeShape | undefined;\n    icon?: StyleIcon;\n    image?: StyleImage | null;\n  } {\n    if (!Tools.isDefined(itemData)) {\n      return {\n        color: BASE_GREY\n      };\n    }\n    const generatedIcon = this.icon(itemData);\n    return {\n      radius: this.size(itemData),\n      color: this.color(itemData),\n      shape: this.shape(itemData),\n      icon: generatedIcon.icon,\n      image: generatedIcon.image\n    };\n  }\n}\n"]}
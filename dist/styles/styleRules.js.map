{"version":3,"file":"styleRules.js","sourceRoot":"","sources":["../../src/styles/styleRules.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2018\n *\n * Created by maximeallex on 2018-05-21.\n */\n\n'use strict';\n\nimport {\n  EdgeStyle,\n  IStyleRule,\n  LkEdgeData,\n  LkNodeData,\n  NodeStyle,\n  SelectorType,\n  StyleIcon,\n  StyleImage\n} from '@linkurious/rest-client';\n\nimport {sortBy} from '../tools/tools';\nimport {Tools} from '..';\n\nimport {StyleRule} from './styleRule';\nimport {ItemAttributes} from './itemAttributes';\n\nexport enum StyleType {\n  COLOR = 'color',\n  ICON = 'icon',\n  SIZE = 'size',\n  IMAGE = 'image',\n  SHAPE = 'shape',\n  WIDTH = 'width'\n}\n\nexport interface Legend {\n  [key: string]: Array<{label: string; value: string | StyleIcon | StyleImage | number}>;\n}\n\nexport const SORTING_RULE = ['specificity', 'itemType', 'index'];\n\nexport class StyleRules {\n  private _rules: Array<IStyleRule<NodeStyle | EdgeStyle>>;\n\n  constructor(rules: Array<IStyleRule<NodeStyle | EdgeStyle>>) {\n    this._rules = rules;\n  }\n\n  /**\n   * Return an array of StyleRule with only 'color' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get color(): Array<StyleRule> {\n    return sortBy(StyleRules.getBy(StyleType.COLOR, this._rules), SORTING_RULE);\n  }\n\n  /**\n   * Return an array of StyleRule with only 'icon' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get icon(): Array<StyleRule> {\n    return sortBy(\n      [\n        ...(StyleRules.getBy(StyleType.ICON, this._rules) || []),\n        ...(StyleRules.getBy(StyleType.IMAGE, this._rules) || [])\n      ],\n      SORTING_RULE\n    );\n  }\n\n  /**\n   * Return an array of StyleRule with only 'image' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get image(): Array<StyleRule> {\n    return sortBy(StyleRules.getBy(StyleType.IMAGE, this._rules), SORTING_RULE);\n  }\n\n  /**\n   * Return an array of StyleRule with only 'shape' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get shape(): Array<StyleRule> {\n    return sortBy(StyleRules.getBy(StyleType.SHAPE, this._rules), SORTING_RULE);\n  }\n\n  /**\n   * Return an array of StyleRule with only 'size' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get size(): Array<StyleRule> {\n    return sortBy(StyleRules.getBy(StyleType.SIZE, this._rules), SORTING_RULE);\n  }\n\n  /**\n   * Return an array of StyleRule with only 'width' rules and sorted by specificity, itemType and index\n   *\n   * @return {Array<StyleRule>}\n   */\n  public get width(): Array<StyleRule> {\n    return sortBy(StyleRules.getBy(StyleType.WIDTH, this._rules), SORTING_RULE);\n  }\n\n  /**\n   * Return an object containing for each node style a sorted array of StyleRule\n   *\n   * @return {any}\n   */\n  public get nodeRules(): {[key: string]: Array<StyleRule>} {\n    return {\n      color: this.color,\n      icon: this.icon,\n      image: this.image,\n      shape: this.shape,\n      size: this.size\n    };\n  }\n\n  /**\n   * Return an object containing for each edge style a sorted array of StyleRule\n   *\n   * @return {any}\n   */\n  public get edgeRules(): {[key: string]: Array<StyleRule>} {\n    return {\n      color: this.color,\n      shape: this.shape,\n      width: this.width\n    };\n  }\n\n  /**\n   * Generate a legend with an array of style rules and existing items in visualization\n   */\n  public generateLegend(itemsData: Array<LkNodeData | LkEdgeData>): Legend {\n    const result: Legend = {};\n    if (itemsData.length === 0) {\n      return result;\n    }\n\n    if ('categories' in itemsData[0]) {\n      Object.keys(this.nodeRules).forEach((style: string) => {\n        result[style] = StyleRules.getLegendForStyle(style, this.nodeRules[style], itemsData);\n      });\n    } else {\n      Object.keys(this.edgeRules).forEach((style: string) => {\n        result[style] = StyleRules.getLegendForStyle(style, this.edgeRules[style], itemsData);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Return the legend for a specific style type (color, icon, image...)\n   */\n  public static getLegendForStyle(\n    styleType: string,\n    styles: Array<StyleRule>,\n    itemsData: Array<LkNodeData | LkEdgeData>\n  ): Array<{label: string; value: string | number | StyleIcon | StyleImage}> {\n    const result: Array<{label: string; value: string | number | StyleIcon | StyleImage}> = [];\n    const data = itemsData.filter((i) => i);\n    for (let i = 0; i < styles.length; i++) {\n      const styleRule = new StyleRule(styles[i]);\n      const ruleExistsInViz = data.some((d) => {\n        return styleRule.canApplyTo(d);\n      });\n      if (ruleExistsInViz) {\n        if (styleType === StyleType.COLOR && typeof styleRule.style.color === 'object') {\n          StyleRules.addLegendAutoColors(data, styleRule, result);\n        } else if (styleType === StyleType.ICON && 'image' in styleRule.style) {\n          // style is a custom icon\n          const label = Tools.isDefined(styleRule.input)\n            ? `${StyleRules.getTypeLabel(styleRule.itemType)}.${\n                styleRule.input![1]\n              } ${StyleRules.sanitizeValue(styleRule.type, styleRule.value)}`\n            : `${StyleRules.getTypeLabel(styleRule.itemType)}`;\n          const value = styleRule.style.image;\n          StyleRules.updateLegend(result, {label: label, value: value});\n        } else {\n          const label = Tools.isDefined(styleRule.input)\n            ? `${StyleRules.getTypeLabel(styleRule.itemType)}.${\n                styleRule.input![1]\n              } ${StyleRules.sanitizeValue(styleRule.type, styleRule.value)}`\n            : `${StyleRules.getTypeLabel(styleRule.itemType)}`;\n          const value = styleRule.style[styleType];\n          StyleRules.updateLegend(result, {label: label, value: value});\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Sanitize value for legend\n   */\n  public static sanitizeValue(styleType: SelectorType, value: any): string {\n    switch (styleType) {\n      case SelectorType.NO_VALUE:\n        return 'is undefined';\n\n      case SelectorType.NAN:\n        return 'is not an number';\n\n      case SelectorType.RANGE:\n        let template = '';\n        Object.keys(value).forEach((k, i) => {\n          if (i > 0) {\n            template += ' and ';\n          }\n          template += `${k} ${value[k]}`;\n        });\n        return template;\n    }\n\n    return typeof value === 'object' ? `= ${JSON.stringify(value)}` : `= ${value}`;\n  }\n\n  /**\n   * Add items in legend for automatic coloring\n   */\n  public static addLegendAutoColors(\n    itemsData: Array<LkNodeData | LkEdgeData>,\n    styleRule: StyleRule,\n    currentLegend: Array<{label: string; value: string | number | StyleIcon | StyleImage}>\n  ): void {\n    const propertyKey: string = styleRule.style.color.input[1];\n    itemsData.forEach((data) => {\n      const propValue = Tools.getIn(data, styleRule.style.color.input);\n      if (Array.isArray(propValue)) {\n        propValue.forEach((value) => {\n          const label = styleRule.style.color.input.includes('properties')\n            ? `${StyleRules.getTypeLabel(styleRule.itemType)}.${propertyKey} = ${value}`\n            : `${StyleRules.getTypeLabel(value)}`;\n          const color = ItemAttributes.autoColor(value, styleRule.style.color.ignoreCase);\n          StyleRules.updateLegend(currentLegend, {label: label, value: color});\n        });\n      } else {\n        const label = styleRule.style.color.input.includes('properties')\n          ? `${StyleRules.getTypeLabel(styleRule.itemType)}.${propertyKey} = ${propValue}`\n          : `${StyleRules.getTypeLabel(propValue)}`;\n        const value = ItemAttributes.autoColor(propValue, styleRule.style.color.ignoreCase);\n        StyleRules.updateLegend(currentLegend, {label: label, value: value});\n      }\n    });\n  }\n\n  /**\n   * Return the label of item type for a legend item\n   */\n  public static getTypeLabel(type: string | undefined): string {\n    return type === undefined ? 'All' : type === null ? 'Others' : type;\n  }\n\n  /**\n   * Check if a legend item already exists and overwrite it / push it\n   */\n  public static updateLegend(\n    legend: Array<{label: string; value: string | number | StyleIcon | StyleImage}>,\n    {label, value}: {[key: string]: string}\n  ): void {\n    const indexOfLegendItem = legend.map((r) => r.label).indexOf(label);\n    if (indexOfLegendItem < 0) {\n      legend.push({label: label, value: value});\n    } else {\n      legend[indexOfLegendItem] = {label: label, value: value};\n    }\n  }\n\n  /**\n   * return an array of StyleRule, containing only the desired style\n   */\n  public static getBy(\n    styleType: StyleType,\n    rules: Array<IStyleRule<NodeStyle | EdgeStyle>>\n  ): Array<StyleRule> {\n    return rules\n      .filter((style: IStyleRule<NodeStyle | EdgeStyle>) => {\n        switch (styleType) {\n          case StyleType.COLOR:\n            return style.style.color !== undefined;\n\n          case StyleType.ICON:\n            return 'icon' in style.style && style.style.icon !== undefined;\n\n          case StyleType.IMAGE:\n            return 'image' in style.style && style.style.image !== undefined;\n\n          case StyleType.SHAPE:\n            return style.style.shape !== undefined;\n\n          case StyleType.SIZE:\n            return 'size' in style.style && style.style.size !== undefined;\n\n          case StyleType.WIDTH:\n            return 'width' in style.style && style.style.width !== undefined;\n        }\n      })\n      .map((style: IStyleRule<NodeStyle | EdgeStyle>) => StyleRules.getRule(style, styleType));\n  }\n\n  /**\n   * From a RawStyle, generate a StyleRule of a specific style\n   */\n  public static getRule(\n    rawRule: IStyleRule<NodeStyle | EdgeStyle>,\n    styleType: StyleType\n  ): StyleRule {\n    const rule = Tools.clone(rawRule);\n    rule.style = {[styleType]: rule.style[styleType]};\n    return new StyleRule(rule);\n  }\n}\n"]}
{"version":3,"file":"models.js","sourceRoot":"","sources":["../../src/ogma/models.ts"],"names":[],"mappings":"","sourcesContent":["import * as o from 'ogma';\n\nexport type RawItem<ND, ED> = RawNode<ND> | RawEdge<ED>;\n\nexport interface RawNode<ND> extends o.RawNode {\n  data: ND;\n}\n\nexport interface RawEdge<ED> extends o.RawEdge {\n  data: ED;\n}\n\nexport interface RawGraph<ND, ED> extends o.RawGraph {\n  nodes: RawNode<ND>[];\n  edges: RawEdge<ED>[];\n}\n\nexport interface Item<ND, ED> extends o.Item {\n  setData(value: ND | ((item: Item<ND, ED>) => ND)): Item<ND, ED>;\n  setData<K1 extends keyof ND>(\n    property: K1,\n    value: ND[K1] | ((item: Item<ND, ED>) => ND[K1])\n  ): Item<ND, ED>;\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    value: ND[K1][K2] | ((item: Item<ND, ED>) => ND[K1][K2])\n  ): Item<ND, ED>;\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ND[K1][K2][K3] | ((item: Item<ND, ED>) => ND[K1][K2][K3])\n  ): Item<ND, ED>;\n  getData<K1 extends keyof ND>(property: K1 | [K1]): ND[K1];\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1]>(property: [K1, K2]): ND[K1][K2];\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ND[K1][K2][K3];\n  getData(): ND;\n  toJSON(options?: {\n    attributes?: o.PropertyPath[] | 'all';\n    data?: (data: any) => any;\n  }): RawItem<ND, ED>;\n  toList(): ItemList<ND, ED>;\n}\n\nexport interface ItemList<ND, ED> extends o.ItemList {\n  concat(items: ItemList<ND, ED>): ItemList<ND, ED>;\n  dedupe(): ItemList<ND, ED>;\n  fillData(value: any): ItemList<ND, ED>;\n  filter(callback: (item: Item<ND, ED>, index: number) => boolean): ItemList<ND, ED>;\n  forEach(callback: (item: Item<ND, ED>, index: number) => void): void;\n  get(index: number): Item<ND, ED>;\n  getData(): ND[];\n  getData<K1 extends keyof ND>(property: K1 | [K1]): ND[K1][];\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1]>(property: [K1, K2]): ND[K1][K2][];\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ND[K1][K2][K3][];\n  includes(item: Item<ND, ED>): boolean;\n  inverse(): ItemList<ND, ED>;\n  map(callback: (item: Item<ND, ED>, index: number) => any): any[];\n  setData(values: ND[] | ((item: Node<ND, ED>) => ND)): ItemList<ND, ED>;\n  setData<K1 extends keyof ND>(\n    property: K1 | [K1],\n    values: ND[K1][] | ((item: Node<ND, ED>) => ND[K1])\n  ): ItemList<ND, ED>;\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    values: ND[K1][K2][] | ((item: Node<ND, ED>) => ND[K1][K2])\n  ): ItemList<ND, ED>;\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    values: ND[K1][K2][K3][] | ((item: Node<ND, ED>) => ND[K1][K2][K3])\n  ): ItemList<ND, ED>;\n  fillData(values: ND[] | ((item: Node<ND, ED>) => ND)): ItemList<ND, ED>;\n  fillData<K1 extends keyof ND>(\n    property: K1 | [K1],\n    value: ND[K1] | ((item: Node<ND, ED>) => ND[K1])\n  ): ItemList<ND, ED>;\n  fillData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    value: ND[K1][K2] | ((item: Node<ND, ED>) => ND[K1][K2][])\n  ): ItemList<ND, ED>;\n  fillData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ND[K1][K2][K3] | ((item: Node<ND, ED>) => ND[K1][K2][K3])\n  ): ItemList<ND, ED>;\n  slice(start?: number, end?: number): ItemList<ND, ED>;\n  toArray(): Item<ND, ED>[];\n  toJSON(options?: {\n    attributes?: o.PropertyPath[] | 'all';\n    data?: (data: any) => any;\n  }): RawItem<ND, ED>[];\n  toList(): ItemList<ND, ED>;\n}\n\nexport interface Node<ND, ED> extends o.Node {\n  getAdjacentNodes(options: o.AdjacencyOptions): NodeList<ND, ED>;\n\n  getAdjacentEdges(options?: o.AdjacencyOptions): EdgeList<ED, ND>;\n\n  toList(): NodeList<ND, ED>;\n\n  slice(): NodeList<ND, ED>;\n\n  toJSON(options?: {\n    attributes?: Array<o.PropertyPath> | 'all';\n    data?: (data: any) => any;\n  }): RawNode<ND>;\n\n  get(index: number): this;\n\n  getId(): string;\n\n  setData(value: ND | ((node: Node<ND, ED>) => ND)): Node<ND, ED>;\n\n  setData<K1 extends keyof ND>(\n    property: K1,\n    value: ND[K1] | ((node: Node<ND, ED>) => ND[K1])\n  ): Node<ND, ED>;\n\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    value: ND[K1][K2] | ((node: Node<ND, ED>) => ND[K1][K2])\n  ): Node<ND, ED>;\n\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ND[K1][K2][K3] | ((node: Node<ND, ED>) => ND[K1][K2][K3])\n  ): Node<ND, ED>;\n\n  getData<K1 extends keyof ND>(property: K1 | [K1]): ND[K1];\n\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1]>(property: [K1, K2]): ND[K1][K2];\n\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ND[K1][K2][K3];\n\n  getData(): ND;\n\n  addClass(className: string, options?: o.AttributeAnimationOptions): Promise<Node<ND, ED>>;\n\n  addClasses(\n    classNames: Array<string>,\n    options?: o.AttributeAnimationOptions\n  ): Promise<Node<ND, ED>>;\n\n  removeClass(className: string, options?: o.AttributeAnimationOptions): Promise<Node<ND, ED>>;\n\n  removeClasses(classNames: string[], options?: o.AttributeAnimationOptions): Promise<Node<ND, ED>>;\n\n  setGeoCoordinates(coords: o.GeoCoordinate | null, duration?: number): Promise<Node<ND, ED>>;\n\n  getMetaNode(): Node<ND, ED> | null;\n\n  getSubNodes(): NodeList<ND, ED> | null;\n}\n\nexport interface NodeList<ND, ED> extends o.NodeList {\n  getAdjacentNodes(options?: o.AdjacencyOptions): NodeList<ND, ED>;\n\n  getAdjacentEdges(options?: o.AdjacencyOptions): EdgeList<ED, ND>;\n\n  getConnectedComponents(options: {\n    filter?: 'visible';\n    returnIds?: boolean;\n  }): Array<NodeList<ND, ED>>;\n\n  toList(): NodeList<ND, ED>;\n\n  toArray(): Array<Node<ND, ED>>;\n\n  get(index: number): Node<ND, ED>;\n\n  getId(): Array<string>;\n\n  forEach(callback: (node: Node<ND, ED>, index: number) => void): void;\n\n  map<T>(callback: (node: Node<ND, ED>, index: number) => T): Array<T>;\n\n  filter(callback: (node: Node<ND, ED>, index: number) => boolean): NodeList<ND, ED>;\n\n  dedupe(): NodeList<ND, ED>;\n\n  slice(start: number, end: number): NodeList<ND, ED>;\n\n  includes(node: Node<ND, ED>): boolean;\n\n  inverse(): NodeList<ND, ED>;\n\n  toJSON(options?: {\n    attributes?: Array<o.PropertyPath> | 'all';\n    data?: (data: unknown) => unknown;\n  }): Array<RawNode<ND>>;\n\n  setData(values: ND[] | ((node: Node<ND, ED>) => ND)): NodeList<ND, ED>;\n\n  setData<K1 extends keyof ND>(\n    property: K1 | [K1],\n    values: ND[K1][] | ((node: Node<ND, ED>) => ND[K1])\n  ): NodeList<ND, ED>;\n\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    values: ND[K1][K2][] | ((node: Node<ND, ED>) => ND[K1][K2])\n  ): NodeList<ND, ED>;\n\n  setData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    values: ND[K1][K2][K3][] | ((node: Node<ND, ED>) => ND[K1][K2][K3])\n  ): NodeList<ND, ED>;\n\n  fillData(values: ND[] | ((node: Node<ND, ED>) => ND)): NodeList<ND, ED>;\n\n  fillData<K1 extends keyof ND>(\n    property: K1 | [K1],\n    value: ND[K1] | ((node: Node<ND, ED>) => ND[K1])\n  ): NodeList<ND, ED>;\n\n  fillData<K1 extends keyof ND, K2 extends keyof ND[K1]>(\n    property: [K1, K2],\n    value: ND[K1][K2] | ((node: Node<ND, ED>) => ND[K1][K2][])\n  ): NodeList<ND, ED>;\n\n  fillData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ND[K1][K2][K3] | ((node: Node<ND, ED>) => ND[K1][K2][K3])\n  ): NodeList<ND, ED>;\n\n  getData(): ND[];\n\n  getData<K1 extends keyof ND>(property: K1 | [K1]): ND[K1][];\n\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1]>(property: [K1, K2]): ND[K1][K2][];\n\n  getData<K1 extends keyof ND, K2 extends keyof ND[K1], K3 extends keyof ND[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ND[K1][K2][K3][];\n\n  getMetaNode(): Array<Node<ND, ED> | null>;\n\n  getSubNodes(): Array<NodeList<ND, ED> | null>;\n}\n\nexport interface Edge<ED, ND> extends o.Edge {\n  getParallelEdges(options: any): EdgeList<ED, ND>;\n\n  fastGetAdjacentElements(): {nodes: NodeList<ND, ED>; edges: EdgeList<ED, ND>};\n\n  toList(): EdgeList<ED, ND>;\n\n  getSource(): Node<ND, ED>;\n\n  getTarget(): Node<ND, ED>;\n\n  getExtremities(): NodeList<ND, ED>;\n\n  setSource(source: Node<ND, ED>): void;\n\n  setTarget(target: Node<ND, ED>): void;\n\n  toJSON(options?: {}): RawEdge<ED>;\n\n  get(index: number): this;\n\n  getId(): string;\n\n  setData(value: ED | ((edge: Edge<ED, ND>) => ED)): Edge<ED, ND>;\n\n  setData<K1 extends keyof ED>(\n    property: K1 | [K1],\n    value: ED[K1] | ((edge: Edge<ED, ND>) => ED[K1])\n  ): Edge<ED, ND>;\n\n  setData<K1 extends keyof ED, K2 extends keyof ED[K1]>(\n    property: [K1, K2],\n    value: ED[K1][K2] | ((edge: Edge<ED, ND>) => ED[K1][K2])\n  ): Edge<ED, ND>;\n\n  setData<K1 extends keyof ED, K2 extends keyof ED[K1], K3 extends keyof ED[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ED[K1][K2][K3] | ((edge: Edge<ED, ND>) => ED[K1][K2][K3])\n  ): Edge<ED, ND>;\n\n  getData<K1 extends keyof ED>(property: K1 | [K1]): ED[K1];\n\n  getData<K1 extends keyof ED, K2 extends keyof ED[K1]>(property: [K1, K2]): ED[K1][K2];\n\n  getData<K1 extends keyof ED, K2 extends keyof ED[K1], K3 extends keyof ED[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ED[K1][K2][K3];\n\n  getData(): ED;\n\n  addClass(className: string, options?: o.AttributeAnimationOptions): Promise<Edge<ED, ND>>;\n\n  addClasses(\n    classNames: Array<string>,\n    options: o.AttributeAnimationOptions\n  ): Promise<Edge<ED, ND>>;\n\n  removeClass(className: string, options?: o.AttributeAnimationOptions): Promise<Edge<ED, ND>>;\n\n  removeClasses(classNames: string[], options: o.AttributeAnimationOptions): Promise<Edge<ED, ND>>;\n\n  getMetaEdge(): Edge<ED, ND> | null;\n\n  getSubEdges(): EdgeList<ED, ND> | null;\n}\n\nexport interface EdgeList<ED, ND> extends o.EdgeList {\n  getParallelEdges(options?: {filter?: 'visible' | 'raw' | 'all'}): EdgeList<ED, ND>;\n\n  fastGetAdjacentElements(): EdgeList<ED, ND>;\n\n  toList(): EdgeList<ED, ND>;\n\n  toArray(): Array<Edge<ED, ND>>;\n\n  getId(): Array<string>;\n\n  getSource(): NodeList<ND, ED>;\n\n  getTarget(): NodeList<ND, ED>;\n\n  getExtremities(): NodeList<ND, ED>;\n\n  get(index: number): Edge<ED, ND>;\n\n  getId(): Array<string>;\n\n  forEach(callback: (edge: Edge<ED, ND>, index: number) => void): void;\n\n  map(callback: (edge: Edge<ED, ND>, index: number) => any): Array<any>;\n\n  filter(callback: (edge: Edge<ED, ND>, index: number) => boolean): EdgeList<ED, ND>;\n\n  reduce(\n    callback: (accumulator: any, currentValue: Edge<ED, ND>, index: number) => any,\n    initialValue: any\n  ): any;\n\n  concat(edges: EdgeList<ED, ND>): EdgeList<ED, ND>;\n\n  dedupe(): EdgeList<ED, ND>;\n\n  slice(start: number, end: number): EdgeList<ED, ND>;\n\n  includes(edge: Edge<ED, ND>): boolean;\n\n  inverse(): EdgeList<ED, ND>;\n\n  toJSON(options?: {}): RawEdge<ED>[];\n\n  setData(values: ED[] | ((edge: Edge<ND, ED>) => ED)): EdgeList<ED, ND>;\n\n  setData<K1 extends keyof ED>(\n    property: K1 | [K1],\n    values: ED[K1][] | ((edge: Edge<ED, ND>) => ED[K1])\n  ): EdgeList<ED, ND>;\n\n  setData<K1 extends keyof ED, K2 extends keyof ED[K1]>(\n    property: [K1, K2],\n    values: ED[K1][K2][] | ((edge: Edge<ED, ND>) => ED[K1][K2][])\n  ): EdgeList<ED, ND>;\n\n  setData<K1 extends keyof ED, K2 extends keyof ED[K1], K3 extends keyof ED[K1][K2]>(\n    property: [K1, K2, K3],\n    values: ED[K1][K2][K3][] | ((edge: Edge<ED, ND>) => ED[K1][K2][K3])\n  ): EdgeList<ED, ND>;\n\n  fillData(values: ED[] | ((edge: Edge<ED, ND>) => ED)): EdgeList<ED, ND>;\n\n  fillData<K1 extends keyof ED>(\n    property: K1 | [K1],\n    value: ED[K1] | ((edge: Edge<ED, ND>) => ED[K1])\n  ): EdgeList<ED, ND>;\n\n  fillData<K1 extends keyof ED, K2 extends keyof ED[K1]>(\n    property: [K1, K2],\n    value: ED[K1][K2] | ((edge: Edge<ED, ND>) => ED[K1][K2][])\n  ): EdgeList<ED, ND>;\n\n  fillData<K1 extends keyof ED, K2 extends keyof ED[K1], K3 extends keyof ED[K1][K2]>(\n    property: [K1, K2, K3],\n    value: ED[K1][K2][K3] | ((edge: Edge<ED, ND>) => ED[K1][K2][K3])\n  ): EdgeList<ED, ND>;\n\n  getData(): ND[];\n\n  getData<K1 extends keyof ED>(property: K1 | [K1]): ED[K1][];\n\n  getData<K1 extends keyof ED, K2 extends keyof ED[K1]>(property: [K1, K2]): ED[K1][K2][];\n\n  getData<K1 extends keyof ED, K2 extends keyof ED[K1], K3 extends keyof ED[K1][K2]>(\n    property: [K1, K2, K3]\n  ): ED[K1][K2][K3][];\n\n  addClass(className: string, options?: o.AttributeAnimationOptions): Promise<EdgeList<ED, ND>>;\n\n  addClasses(\n    classNames: Array<string>,\n    options: o.AttributeAnimationOptions\n  ): Promise<EdgeList<ED, ND>>;\n\n  removeClass(className: string, options?: o.AttributeAnimationOptions): Promise<EdgeList<ED, ND>>;\n\n  removeClasses(\n    classNames: string[],\n    options: o.AttributeAnimationOptions\n  ): Promise<EdgeList<ED, ND>>;\n\n  getMetaEdge(): Array<Edge<ED, ND> | null>;\n\n  getSubEdges(): Array<EdgeList<ED, ND> | null>;\n}\n"]}
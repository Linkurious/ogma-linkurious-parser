{"version":3,"file":"filters.js","sourceRoot":"","sources":["../../src/filters/filters.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2018\n *\n * Created by andrebarata on 2018-05-22.\n */\n\nimport {\n  ItemSelector,\n  LkEdgeData,\n  LkNodeData,\n  RangeValues,\n  SelectorType,\n  SelectorAny,\n  SelectorIs,\n  SelectorNoValue,\n  SelectorNaN,\n  SelectorRange,\n  LkItemData\n} from '@linkurious/rest-client';\n\nimport {Tools} from '..';\n\ntype FilterFunction<T extends LkItemData> = (itemData: T) => boolean;\n\nexport class Filters {\n  private static nodeCache: Map<string, FilterFunction<LkNodeData>> = new Map();\n  private static edgeCache: Map<string, FilterFunction<LkEdgeData>> = new Map();\n  private static FILTER_CACHE_SIZE = 5;\n\n  /**\n   * Returns whether the node/edge should be *filtered* (a.k.a. *hidden*).\n   *\n   * Notes:\n   * 1. `filterRules` are rules that match what should be filtered/hidden.\n   * 2. `filterRules` are combined inclusively: as soon as one rule returns `true` for\n   *    an item, the item can be hidden/filtered.\n   *\n   * @param filterRules\n   * @param itemData\n   */\n  public static isFiltered(\n    filterRules: Array<ItemSelector>,\n    itemData: LkNodeData | LkEdgeData\n  ): boolean {\n    if (!Tools.isDefined(itemData)) {\n      return false;\n    }\n\n    if ('categories' in itemData) {\n      return this.getFilterFunction(filterRules, true)(itemData);\n    } else {\n      return this.getFilterFunction(filterRules, false)(itemData);\n    }\n  }\n\n  private static getFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filterRules: Array<ItemSelector>,\n    isNode: boolean\n  ): FilterFunction<T> {\n    const filterKey = JSON.stringify(filterRules, null, '');\n\n    // This cast is needed to tell the TypeScript compiler to trust us that \"isNode\" and \"T\" are dependent.\n    const filterCache = (isNode ? this.nodeCache : this.edgeCache) as Map<\n      string,\n      FilterFunction<T>\n    >;\n\n    let filterFunc = filterCache.get(filterKey);\n    if (!filterFunc) {\n      filterFunc = this.createFilterFunction(filterRules, isNode);\n      if (filterCache.size > this.FILTER_CACHE_SIZE) {\n        filterCache.clear();\n      }\n      filterCache.set(filterKey, filterFunc);\n    }\n    return filterFunc;\n  }\n\n  private static createFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filterRules: Array<ItemSelector>,\n    isNode: boolean\n  ): FilterFunction<T> {\n    const filterFunctions = filterRules.map((filter: ItemSelector) =>\n      this.filterToFilterFunction(filter, isNode)\n    );\n\n    /**\n     * For each filterFunction, as soon as we find a filterFunction that says that a given\n     * node/edge should be filtered/hidden, we return `true` for the node/edge.\n     */\n    return (itemData: T): boolean => {\n      for (const filterFunction of filterFunctions) {\n        if (filterFunction(itemData)) {\n          return true;\n        }\n      }\n      return false;\n    };\n  }\n\n  private static filterToFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: ItemSelector,\n    isNode: boolean\n  ): FilterFunction<T> {\n    switch (filter.type) {\n      case SelectorType.ANY:\n        return this.createAnyFilterFunction(filter, isNode);\n      case SelectorType.IS:\n        return this.createIsFilterFunction(filter, isNode);\n      case SelectorType.NO_VALUE:\n        return this.createNoValueFilterFunction(filter, isNode);\n      case SelectorType.RANGE:\n        return this.createRangeFilterFunction(filter, isNode);\n      case SelectorType.NAN:\n        return this.createNaNFilterFunction(filter, isNode);\n    }\n  }\n\n  private static createAnyFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: SelectorAny,\n    isNode: boolean\n  ): FilterFunction<T> {\n    if (isNode) {\n      return (itemData: T) => {\n        if (filter.itemType === undefined) {\n          return true;\n        }\n        return (itemData as LkNodeData).categories.includes(filter.itemType);\n      };\n    } else {\n      // isEdge\n      return (itemData: T) => (itemData as LkEdgeData).type === filter.itemType;\n    }\n  }\n\n  private static createIsFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: SelectorIs,\n    isNode: boolean\n  ): FilterFunction<T> {\n    if (isNode) {\n      return (itemData: T) =>\n        (itemData as LkNodeData).categories.includes(filter.itemType) &&\n        Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true) === filter.value;\n    } else {\n      // isEdge\n      return (itemData: T) =>\n        (itemData as LkEdgeData).type === filter.itemType &&\n        Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true) === filter.value;\n    }\n  }\n\n  private static createNoValueFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: SelectorNoValue,\n    isNode: boolean\n  ): FilterFunction<T> {\n    if (isNode) {\n      return (itemData: T) =>\n        (itemData as LkNodeData).categories.includes(filter.itemType) &&\n        !Tools.isDefined(Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true));\n    } else {\n      // isEdge\n      return (itemData: T) =>\n        (itemData as LkEdgeData).type === filter.itemType &&\n        !Tools.isDefined(Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true));\n    }\n  }\n\n  private static createNaNFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: SelectorNaN,\n    isNode: boolean\n  ): FilterFunction<T> {\n    if (isNode) {\n      return (itemData: T) =>\n        (itemData as LkNodeData).categories.includes(filter.itemType) &&\n        this.isNotANumber(Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true));\n    } else {\n      // isEdge\n      return (itemData: T) =>\n        (itemData as LkEdgeData).type === filter.itemType &&\n        this.isNotANumber(Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true));\n    }\n  }\n\n  private static isNotANumber(value: any) {\n    return Tools.isDefined(value) && !Tools.isNumber(value);\n  }\n\n  public static createRangeFilterFunction<T extends LkNodeData | LkEdgeData>(\n    filter: SelectorRange,\n    isNode: boolean\n  ): FilterFunction<T> {\n    if (isNode) {\n      return (itemData: T) =>\n        (itemData as LkNodeData).categories.includes(filter.itemType) &&\n        this.valueShouldBeHidden(\n          Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true),\n          filter.value\n        );\n    } else {\n      // isEdge\n      return (itemData: T) =>\n        (itemData as LkEdgeData).type === filter.itemType &&\n        this.valueShouldBeHidden(\n          Tools.getPropertyValue(Tools.getIn(itemData, filter.input), true),\n          filter.value\n        );\n    }\n  }\n\n  /**\n   * Returns true if `value` should be filtered/hidden.\n   *\n   * `range` describes what should be filtered/hidden:\n   * - e.g. {\"<\":10, \">=\":20} => hide any value in ]-inf, 10[ *OR* in [20, +inf[\n   * - e.g. {\"<=\":10}         => hide any value in ]-inf, 10]\n   * - e.g. {\">=\":20}         => hide any value in [20, +inf[\n   *\n   * Returns false (i.e. will not filter/hide) if `value` is not a number.\n   */\n  public static valueShouldBeHidden(value: unknown, range: RangeValues): boolean {\n    const n = Tools.parseFloat(value);\n    if (Number.isNaN(n)) {\n      return false;\n    }\n\n    /**\n     * As soon as we find a condition that says that `value` should be filtered/hidden,\n     * we return `true`.\n     *\n     * If `range` contains multiple conditions, all are checked and if any condition causes\n     * `value` to be in the filtered/hidden range, we return `true`.\n     *\n     * If no condition causes `value` to be filtered/hidden, we return `false`.\n     */\n    return (\n      (range['<'] !== undefined && n < range['<']) ||\n      (range['<='] !== undefined && n <= range['<=']) ||\n      (range['>'] !== undefined && n > range['>']) ||\n      (range['>='] !== undefined && n >= range['>='])\n    );\n  }\n}\n"]}
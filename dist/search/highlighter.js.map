{"version":3,"file":"highlighter.js","sourceRoot":"","sources":["../../src/search/highlighter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS\n *\n * - Created on 25/07/18.\n */\n\nimport {\n  EntityType,\n  GenericObject,\n  LkDate,\n  LkDateTime,\n  LkProperties,\n  SearchQuery,\n  TermStatement\n} from '@linkurious/rest-client';\nimport {hasValue} from '@linkurious/rest-client/dist/src/utils';\n\nconst MAX_VALUE_LENGTH_BYTE = 10000; // 10 kB\nconst DIACRITIC_CHARACTERS = /[\\u0300-\\u036f]/g;\nconst NOT_A_LETTER = /[\\s.:,;?!\"'`~@#$€£%^&*(){}[\\]_\\-+=|\\\\<>/]/;\n\nconst OPENING_TAG = '[match]';\nconst CLOSING_TAG = '[/match]';\n\nexport interface HighlighterOptions {\n  maxValueLength?: number;\n  minTokenLength?: number;\n  maxTokenLength?: number;\n  maxMatchResults?: number;\n  localFuzziness?: number;\n}\n\nconst ISO_DATE_RE = /^\\d+-\\d\\d-\\d\\d((T\\d\\d(:\\d\\d(:\\d\\d(\\.\\d{1,3})?)?)?)(Z|[+-]\\d\\d(:\\d\\d)?)?)?$/;\n\nexport class Highlighter {\n  /**\n   * Extract the best quotation of size `maxLength` of `text`, a text already highlighted\n   * with `openingTag` and `closingTag`.\n   *\n   * @param {string}              text\n   * @param {Map<string, number>} tokenScores\n   * @param {string}              openingTag\n   * @param {string}              closingTag\n   * @param {number}              [maxLength]\n   * @returns {string}\n   */\n  private static extractQuotation(\n    text: string,\n    tokenScores: Map<string, number>,\n    openingTag: string,\n    closingTag: string,\n    maxLength?: number\n  ): string {\n    if (maxLength === null || maxLength === undefined || text.length <= maxLength) {\n      return text;\n    }\n\n    // 1) split the text in words; a matching word (enclosed by tags) is going to be its own word.\n\n    let wordsStr = text.split(openingTag).join(' ' + openingTag);\n    wordsStr = wordsStr.split(closingTag).join(closingTag + ' ');\n    const words = wordsStr.replace(/\\s+/g, ' ').trim().split(' ');\n\n    // 2) count `charsUpToIndex`: number of characters contained in `word` up to the i-th word included\n    // and discover which ones are the indices of the highlighted words (`interestingIndexes`)\n    const interestingIndexes = [];\n    const charsUpToIndex: number[] = [];\n\n    for (let i = 0; i < words.length; ++i) {\n      charsUpToIndex[i] = i === 0 ? words[0].length : charsUpToIndex[i - 1] + words[i].length + 1; // +1 for the space char\n\n      const word = words[i];\n\n      // if i'm enclosed by tag\n      if (\n        word.startsWith(openingTag) &&\n        word.indexOf(closingTag) === word.length - closingTag.length\n      ) {\n        interestingIndexes.push(i);\n\n        // fix `charsUpToIndex` s.t. the tag lengths don't influence the number of characters\n        charsUpToIndex[i] -= openingTag.length + closingTag.length;\n      }\n    }\n\n    // 3) find end given any fixed start\n    const end: number[] = [];\n    for (let i = 0; i < words.length; ++i) {\n      const firstIndex = end[i - 1] || i;\n      end[i] = end[i - 1] || i;\n      for (let y = firstIndex; y < words.length; ++y) {\n        if (charsUpToIndex[y] - (i === 0 ? 0 : charsUpToIndex[i - 1] + 1) <= maxLength) {\n          end[i] = y + 1; // +1 because we have [start, end)\n        } else {\n          break; // length can only go increasing\n        }\n      }\n    }\n\n    // 4) find best start\n    let bestStart = 0;\n    let bestScore = 0; // how many highlighted words (weighted by their matching score) appear in the quotation\n    let contextBestScore = 0; // sum of the min distances among the highlighted words and the borders of the window\n\n    // 4.1) compute score of all the cases\n    for (let i = 0; i < words.length; ++i) {\n      let score = 0;\n      let contextScore = 0;\n\n      for (let y = 0; y < interestingIndexes.length; ++y) {\n        const index = interestingIndexes[y];\n        if (index < i) {\n          continue;\n        }\n\n        if (index < end[i]) {\n          score += tokenScores.get(words[index]) as number;\n          contextScore += Math.min(index - i, end[i] - 1 - index);\n        } else {\n          break; // index can only go increasing\n        }\n      }\n\n      if (score > bestScore || (score === bestScore && contextScore > contextBestScore)) {\n        bestStart = i;\n        bestScore = score;\n        contextBestScore = contextScore;\n      }\n    }\n\n    let resultString = words.slice(bestStart, end[bestStart]).join(' ');\n\n    if (bestStart !== 0) {\n      resultString = '... ' + resultString;\n    }\n    if (end[bestStart] !== words.length) {\n      resultString = resultString + ' ...';\n    }\n\n    return resultString;\n  }\n\n  /**\n   * NOTE: if a literal is longer than `maxLength` it gets truncated\n   * but the indices are of the original token.\n   *\n   * @example\n   * tokenize('hello! WoRlD&(/\"£miao5world5f', 2, 4);\n   * // -> {hell: [[0, 5]], worl: [[7, 5], [22, 5]], miao: [[17, 4]]}\n   *\n   * @param {string} text\n   * @param {number} minLength\n   * @param {number} maxLength\n   * @returns {Map<string, number[][]>}\n   */\n  public static tokenize(\n    text: string,\n    minLength: number,\n    maxLength: number\n  ): Map<string, number[][]> {\n    text = text.normalize('NFD').replace(DIACRITIC_CHARACTERS, '');\n    const result = new Map();\n    const addResult = (literal: string, firstIndex: number, length: number): void => {\n      literal = literal.slice(0, maxLength);\n      if (literal.length < minLength) {\n        return;\n      }\n\n      if (!result.has(literal)) {\n        result.set(literal, []);\n      }\n      result.get(literal).push([firstIndex, length]);\n    };\n\n    let curLiteral = null;\n    let curFirstIndex = null;\n    let curLen = null;\n\n    for (let i = 0; i < text.length && i < MAX_VALUE_LENGTH_BYTE; ++i) {\n      const c = text[i].toLowerCase();\n\n      if (!c.match(NOT_A_LETTER)) {\n        // is a letter\n        if (curLiteral) {\n          curLiteral += c;\n          (curLen as number)++;\n        } else {\n          curLiteral = c;\n          curFirstIndex = i;\n          curLen = 1;\n        }\n      } else {\n        if (curLiteral) {\n          addResult(curLiteral, curFirstIndex as number, curLen as number);\n          curLiteral = null;\n          curFirstIndex = null;\n          curLen = null;\n        }\n      }\n    }\n\n    if (curLiteral) {\n      // if curLiteral is defined, curFirstIndex and curLen are numbers\n      addResult(curLiteral, curFirstIndex as number, curLen as number);\n    }\n\n    return result;\n  }\n\n  /**\n   * Return a number from 0 to 1 to indicate how similar are `a` and `b`.\n   * If `a` and `b` differ more characters than `maxEditDistance`, it returns 0.\n   * If `allowPrefix` is true and `b` starts with `a`, it returns 1.\n   * If `a` and `b` are equal, it also returns 1.\n   *\n   * @returns {number} a number from 0 to 1. 1 indicates a non-match, and 0 an exact match\n   */\n  public static fuzzyMatch(\n    a: string,\n    b: string,\n    maxEditDistance: number,\n    allowPrefix = false\n  ): number {\n    // if (a.length === 0) {return b.length;} // `a` and `b` are never empty\n    // if (b.length === 0) {return a.length;}\n\n    if (allowPrefix && b.startsWith(a)) {\n      return 1; // if `a` is a prefix of `b`, it's a match\n    }\n\n    if (Math.abs(a.length - b.length) > maxEditDistance) {\n      return 0; // if the difference in length is too high is not a match\n    }\n\n    const editDistance = Highlighter.editDistance(a, b);\n\n    if (editDistance > maxEditDistance) {\n      return 0;\n    } else {\n      return 1 - editDistance / a.length;\n    }\n  }\n\n  /**\n   * Return the edit distance among a and b.\n   *\n   * Source: https://gist.github.com/andrei-m/982927\n   *\n   * @param {string} a\n   * @param {string} b\n   * @returns {number}\n   */\n  private static editDistance(a: string, b: string): number {\n    let tmp, i, j, prev, val;\n\n    // swap to save some memory O(min(a,b)) instead of O(a)\n    if (a.length > b.length) {\n      tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    const row = new Array(a.length + 1);\n    // init the row\n    for (i = 0; i <= a.length; i++) {\n      row[i] = i;\n    }\n\n    // fill in the rest\n    for (i = 1; i <= b.length; i++) {\n      prev = i;\n      for (j = 1; j <= a.length; j++) {\n        if (b[i - 1] === a[j - 1]) {\n          val = row[j - 1]; // match\n        } else {\n          val = Math.min(\n            row[j - 1] + 1, // substitution\n            Math.min(\n              prev + 1, // insertion\n              row[j] + 1\n            )\n          ); // deletion\n        }\n        row[j - 1] = prev;\n        prev = val;\n      }\n      row[a.length] = prev;\n    }\n    return row[a.length];\n  }\n\n  public static editDistanceFromFuzziness(tokenLength: number, fuzziness: number): number {\n    return Math.min(Math.round(tokenLength * fuzziness), 2);\n  }\n\n  private static isLkDate(o: unknown): o is LkDate | LkDateTime {\n    return typeof o === 'object' && o !== null && 'value' in o;\n  }\n\n  private static isISODate(input: string): boolean {\n    // check valid grammar\n    if (!ISO_DATE_RE.test(input)) {\n      return false;\n    }\n\n    // check valid values\n    const candidateValue = new Date(input);\n    return isFinite(candidateValue.getTime());\n  }\n\n  /**\n   * In local search we don't have a searchQuery, but we have query string and fuzziness\n   */\n  public static buildSearchQueryFromString(\n    q: string,\n    params: Required<HighlighterOptions>\n  ): SearchQuery {\n    const tokens = Array.from(\n      Highlighter.tokenize(q, params.minTokenLength, params.maxTokenLength).keys()\n    );\n    return {\n      fuzziness: params.localFuzziness,\n      entityType: EntityType.NODE, // this is not used, but required for TS not to complain\n      filters: [],\n      phrases: [],\n      terms: tokens.map(\n        (token, index) =>\n          ({\n            // We decided to prefix the last term if it's not followed by whitespaces\n            prefix: index === tokens.length - 1 && !/\\s/.test(q[q.length - 1]),\n            term: token\n          } as TermStatement)\n      ),\n      propertiesPerTypes: {}\n    };\n  }\n\n  /**\n   *\n   * Example 1: tokenizeForPhraseSearch(\"hello! WoRlD&(/\"£miao5world5f\", 2, 4);\n   * Output 1: [\n   *    {tokenStart: 0, tokenEnd: 5, token: \"hello\"},\n   *    {tokenStart: 7, tokenEnd: 12, token: \"world\"},\n   *    ...\n   * ]\n   */\n  private static tokenizeForPhraseSearch(\n    text: string\n  ): {\n    tokenStart: number;\n    tokenEnd: number;\n    token: string;\n  }[] {\n    text = text.normalize('NFD').replace(DIACRITIC_CHARACTERS, '');\n    const tokens = [];\n    let token: string | undefined = undefined;\n    for (let index = 0; index < text.length; index++) {\n      const char = text[index].toLowerCase();\n      if (/[a-zA-Z0-9]/.test(char)) {\n        token = hasValue(token) ? token + char : char;\n      } else if (hasValue(token)) {\n        tokens.push({\n          tokenStart: index - token.length,\n          tokenEnd: index,\n          token: token\n        });\n        token = undefined;\n      }\n    }\n    if (hasValue(token)) {\n      tokens.push({\n        tokenStart: text.length - token.length,\n        tokenEnd: text.length,\n        token: token\n      });\n    }\n    return tokens;\n  }\n\n  /**\n   * This function looks for tokens of `searchQuery` inside `document`.\n   *\n   * For every property key that match, this function will return the property key in `field` and\n   * the property value in `value` properly truncated and highlighted:\n   * - Wrap every token of `searchQuery` that is contained in `value` like: [match]word[/match].\n   * - If `value` is longer than MAX_LENGTH_SEARCH_RESULT, it will be shortened by extracting\n   * a fragment where the highest number of matched words appear.\n   *\n   * @example\n   * document: {name: 'Linkurious', description: 'The Linkurious company makes Software', ...}\n   * searchQuery.terms[0].terms: ['Linkurios']\n   * options.fuzziness: 0.4\n   * options.maxValueLength: 20\n   *\n   * returns:\n   * [{\n   *   field: 'name',\n   *   value: '[match]Linkurious[/match]'\n   * }, {\n   *   field: 'description',\n   *   value: 'The [match]Linkurious[/match] company ...'\n   * }]\n   *\n   * @param {SearchQuery | string} searchQueryOrString\n   * @param {GenericObject<unknown>} document\n   * @param {string} openingTag\n   * @param {string} closingTag\n   * @param {object} [options]\n   * @param {number} [options.maxValueLength=80]\n   * @param {number} [options.minTokenLength=2]\n   * @param {number} [options.maxTokenLength=7]\n   * @param {number} [options.maxMatchResults=5]\n   * @returns {Array<{field: string, value: string}>}\n   */\n  public static highlight(\n    searchQueryOrString: SearchQuery | string,\n    document: LkProperties,\n    openingTag: string,\n    closingTag: string,\n    options?: HighlighterOptions\n  ): Array<{field: string; value: string}> {\n    let searchQuery = {} as SearchQuery;\n\n    const params: Required<HighlighterOptions> = {\n      maxValueLength: 80,\n      minTokenLength: 2,\n      maxTokenLength: 7,\n      maxMatchResults: 5,\n      localFuzziness: 0.3,\n      ...(options || {})\n    };\n\n    if (typeof searchQueryOrString === 'string') {\n      searchQuery = Highlighter.buildSearchQueryFromString(searchQueryOrString, params);\n    } else {\n      searchQuery = searchQueryOrString;\n    }\n\n    const docTokens: GenericObject<Map<string, number[][]> | undefined> = {};\n    Object.keys(document).forEach((key) => {\n      const propertyValue = document[key];\n      let value;\n      if (\n        typeof propertyValue === 'string' ||\n        typeof propertyValue === 'number' ||\n        typeof propertyValue === 'boolean'\n      ) {\n        value = '' + propertyValue;\n      } else if ('value' in propertyValue) {\n        // LkDate or LkDateTime\n        value = propertyValue.value;\n      } else if ('original' in propertyValue) {\n        // InvalidValue or ConflictValue\n        value = propertyValue.original;\n      }\n\n      docTokens[key] = hasValue(value)\n        ? Highlighter.tokenize(value, params.minTokenLength, params.maxTokenLength)\n        : undefined;\n    });\n\n    const allMatches = new Map();\n    for (const field in document) {\n      allMatches.set(field, []);\n    }\n\n    // 1) for each term statement\n    for (let i = 0; i < searchQuery.terms.length; ++i) {\n      const searchTerm = searchQuery.terms[i].term.toLowerCase();\n\n      // 1.1) for each field in the document\n      for (const field in docTokens) {\n        const fieldTokensMap = docTokens[field];\n\n        // 1.2) if searchTerm parses as a date (Server issue #2072)\n        if (Highlighter.isISODate(searchTerm)) {\n          const docField = document[field];\n\n          if (Highlighter.isLkDate(docField) && docField.value.startsWith(searchTerm)) {\n            // null indicates to highlight the whole string\n            // also we set a low score to prevent a filter match to hide other highlights\n            allMatches.get(field).push([0, null, 0.01]);\n            continue;\n          }\n        }\n\n        // only string fields are tokenized\n        if (fieldTokensMap === undefined) {\n          continue;\n        }\n\n        const fieldTokensArray: string[] = Array.from(fieldTokensMap.keys());\n\n        // check if the term statement is only relevant to a specific field\n        if (searchQuery.terms[i].key !== undefined && field !== searchQuery.terms[i].key) {\n          continue;\n        }\n\n        // 1.3) for each token in the field\n        for (let y = 0; y < fieldTokensArray.length; ++y) {\n          const fieldToken = fieldTokensArray[y];\n\n          // 1.4) check if a match\n          const maxEditDistance = Highlighter.editDistanceFromFuzziness(\n            searchTerm.length,\n            searchQuery.fuzziness\n          );\n\n          const score = Highlighter.fuzzyMatch(\n            searchTerm,\n            fieldToken,\n            maxEditDistance,\n            searchQuery.terms[i].prefix\n          );\n\n          if (score > 0) {\n            // for every match we have one field containing the position, the length and the score\n            // the tokenization provides the first two, we manually add the score\n            const fieldMatches = fieldTokensMap.get(fieldToken)!.map((o) => o.concat(score));\n            // @ts-ignore\n            [].push.apply(allMatches.get(field), fieldMatches);\n          }\n        }\n      }\n    }\n\n    // 2) for each phrase statement\n    for (let i = 0; i < searchQuery.phrases.length; ++i) {\n      const searchPhrase = searchQuery.phrases[i].phrase;\n\n      // 2.1) for each field in the document\n      for (const field in document) {\n        // check if the phrase statement is only relevant to a specific field\n        if (searchQuery.phrases[i].key !== undefined && field !== searchQuery.phrases[i].key) {\n          continue;\n        }\n\n        const fieldText = document[field];\n\n        if (typeof fieldText !== 'string') {\n          continue;\n        }\n\n        // 2.2) tokenize the search text and the target text\n        const phraseTokens = Highlighter.tokenizeForPhraseSearch(searchPhrase);\n        const fieldTokens = Highlighter.tokenizeForPhraseSearch(fieldText);\n\n        // 2.3) check if all phraseTokens match consecutively a subarray of fieldTokens\n        fieldToken: for (let j = 0; j < fieldTokens.length; j++) {\n          for (let k = 0; k < phraseTokens.length; k++) {\n            const isMatch =\n              hasValue(fieldTokens[j + k]) &&\n              (fieldTokens[j + k].token === phraseTokens[k].token ||\n                (searchQuery.phrases[i].prefix &&\n                  k === phraseTokens.length - 1 &&\n                  fieldTokens[j + k].token.startsWith(phraseTokens[k].token)));\n            if (!isMatch) {\n              continue fieldToken;\n            }\n          }\n\n          // 2.4) push the match, the indices of the phrase that contains the tokens that found a match\n          const phraseStart = fieldTokens[j].tokenStart;\n          const phraseLength =\n            fieldTokens[j + phraseTokens.length - 1].tokenEnd - fieldTokens[j].tokenStart;\n          allMatches.get(field).push([phraseStart, phraseLength, 1]);\n        }\n      }\n    }\n\n    // 3) for each filter\n    for (let i = 0; i < searchQuery.filters.length; ++i) {\n      const field = searchQuery.filters[i].key;\n\n      if (field in document) {\n        // null indicates to highlight the whole string\n        // also we set a low score to prevent a filter match to hide other highlights\n        allMatches.get(field).push([0, null, 0.01]);\n      }\n    }\n\n    // 4) pick the best field\n    // in `allMatches` we have all the pairs of start/end indices to highlight for each field\n    // we choose the field with the highest number of highlights\n    let matchingFields = [];\n\n    for (const field in document) {\n      let valueLength;\n      const docField = document[field];\n      let value: string;\n      if (typeof docField === 'string') {\n        valueLength = docField.length;\n        value = docField;\n      } else if (typeof docField === 'number') {\n        // numerical filter statements\n        value = '' + docField;\n        valueLength = 1;\n      } else if (Highlighter.isLkDate(docField)) {\n        // date/datetime filter statements\n        value = docField.value;\n        valueLength = 1;\n      } else {\n        // neither string, number or date\n        continue;\n      }\n\n      // The order of matching fields is defined by the following formula\n      // We sum all the scores of a given field and divide the result by the length of the value\n      const sum = allMatches.get(field).reduce((acc: number, next: number[]) => acc + next[2], 0);\n      const fieldScore = sum / valueLength;\n      if (fieldScore > 0) {\n        matchingFields.push({score: fieldScore, field: field, value: value});\n      }\n    }\n\n    // sort in descending order by score\n    matchingFields.sort((f1, f2) => f2.score - f1.score);\n    matchingFields = matchingFields.slice(0, params.maxMatchResults);\n\n    return matchingFields.map((matchingField) => {\n      const field = matchingField.field;\n      let value = matchingField.value;\n      let fieldMatches: [number, number, number][] = allMatches.get(matchingField.field);\n\n      // we sort fieldMatches by token index in increasing order and by score in decreasing order\n      // This way, when we deduplicate in the next step, we avoid multiple matches\n      // in the same position and we keep only the one with the highest score\n      fieldMatches.sort((u1, u2) => u1[0] - u2[0] || u2[2] - u1[2]);\n\n      // we remove duplicate highlighted token (we keep the highest score)\n      const sortedUniq: [number, number, number][] = [];\n      let lastTokenIndex: number | undefined = undefined;\n      for (const fieldMatch of fieldMatches) {\n        if (lastTokenIndex !== fieldMatch[0]) {\n          lastTokenIndex = fieldMatch[0];\n          sortedUniq.push(fieldMatch);\n        }\n      }\n      fieldMatches = sortedUniq;\n      let offset = 0;\n\n      const tokenScores = new Map();\n\n      for (let i = 0; i < fieldMatches.length; ++i) {\n        const openingTagPos = offset + fieldMatches[i][0];\n        let closingTagPos;\n        if (fieldMatches[i][1] === null) {\n          // null indicates to highlight the whole string\n          closingTagPos = value.length;\n        } else {\n          closingTagPos = openingTagPos + fieldMatches[i][1];\n        }\n        const score = fieldMatches[i][2];\n\n        // We set the score in tokenScores, in case we need to make a quotation\n        tokenScores.set(\n          OPENING_TAG + value.slice(openingTagPos, closingTagPos) + CLOSING_TAG,\n          score\n        );\n\n        value =\n          value.slice(0, openingTagPos) +\n          OPENING_TAG +\n          value.slice(openingTagPos, closingTagPos) +\n          CLOSING_TAG +\n          value.slice(closingTagPos);\n\n        // every time we add openingTag and closingTag we introduce an offset for all the indices\n        offset += OPENING_TAG.length + CLOSING_TAG.length;\n      }\n\n      value = Highlighter.extractQuotation(\n        value,\n        tokenScores,\n        OPENING_TAG,\n        CLOSING_TAG,\n        params.maxValueLength\n      )\n        .replace(/\\[match\\]/g, openingTag)\n        .replace(/\\[\\/match\\]/g, closingTag);\n\n      return {\n        field: field,\n        value: value\n      };\n    });\n  }\n}\n"]}
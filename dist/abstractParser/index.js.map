{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/abstractParser/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2019\n *\n * - Created on 2019-08-13.\n */\n\nexport enum AbstractTokenType {\n  LITERAL = 'literal',\n  EXPRESSION = 'expression'\n}\n\nexport interface AbstractToken {\n  type: AbstractTokenType;\n  value: string;\n  start: number;\n  end: number;\n}\n\nexport interface AbstractTokenDelimiters {\n  opening: string;\n  closing: string;\n  openingRE: RegExp;\n  closingRE: RegExp;\n}\n\n// Returns an array with the indexes of the match of regexp on str\nfunction getMatchIndexes(str: string, regexp: RegExp): number[] {\n  // In ES2020 return [...str.matchAll(regexp)].map(el => el.index) would do the trick\n  const res: number[] = [];\n  while (true) {\n    const match = regexp.exec(str);\n    if (match === null) {\n      break;\n    }\n    res.push(match.index);\n  }\n  return res;\n}\n\nexport default class AbstractTemplate {\n  public static tokenize(\n    rawTemplate: string,\n    config: AbstractTokenDelimiters = {\n      opening: '{{',\n      closing: '}}',\n      openingRE: /{{(?!{)/g,\n      closingRE: /}}(?!})/g\n    }\n  ): AbstractToken[] {\n    const openingLength = config.opening.length;\n    const closingLength = config.closing.length;\n\n    const tokens: AbstractToken[] = [];\n\n    // Indexes of double opening/closing braces in the `rawTemplate`\n    const openings = getMatchIndexes(rawTemplate, config.openingRE);\n    const closings = getMatchIndexes(rawTemplate, config.closingRE);\n\n    let i = 0; // Pointer for opening indexes list.\n    let j = 0; // Pointer for closing indexes list.\n    let l = 0; // `urlTemplate` index for last literal beginning.\n\n    while (true) {\n      // Loop ends because we run out of openings.\n      // We push the remaining literal if any.\n      if (i >= openings.length) {\n        const literalToken = rawTemplate.substring(l, rawTemplate.length);\n        if (literalToken.length > 0) {\n          tokens.push({\n            type: AbstractTokenType.LITERAL,\n            value: literalToken,\n            start: l,\n            end: rawTemplate.length\n          });\n        }\n        break;\n      }\n\n      // Loops ends because we were looking for closings but run out of them.\n      // We push the last literal if any which is previous to the unclosed expression.\n      // We push the last expression whose closing double brace was not found.\n      if (j >= closings.length) {\n        const literalToken = rawTemplate.substring(l, openings[i]);\n        if (literalToken.length > 0) {\n          tokens.push({\n            type: AbstractTokenType.LITERAL,\n            value: literalToken,\n            start: l,\n            end: openings[i]\n          });\n        }\n        tokens.push({\n          type: AbstractTokenType.EXPRESSION,\n          value: rawTemplate.substring(openings[i] + openingLength, rawTemplate.length),\n          start: openings[i] + openingLength,\n          end: rawTemplate.length\n        });\n        break;\n      }\n\n      // We look for the next closing for each opening outside an expression,\n      // if a closing is found we have an expression, and the string, if any, before\n      // this expression is a literal.\n      if (openings[i] > closings[j]) {\n        j++;\n      } else {\n        const literalToken = rawTemplate.substring(l, openings[i]);\n        const expressionToken = rawTemplate.substring(openings[i] + openingLength, closings[j]);\n\n        if (literalToken.length > 0) {\n          tokens.push({\n            type: AbstractTokenType.LITERAL,\n            value: literalToken,\n            start: l,\n            end: openings[i]\n          });\n        }\n        tokens.push({\n          type: AbstractTokenType.EXPRESSION,\n          value: expressionToken,\n          start: openings[i] + openingLength,\n          end: closings[i]\n        });\n\n        l = closings[j] + closingLength;\n\n        // We move to the next opening outside the expression.\n        while (i < openings.length) {\n          if (openings[i] > closings[j]) {\n            break;\n          } else {\n            i++;\n          }\n        }\n      }\n    }\n    return tokens;\n  }\n}\n"]}
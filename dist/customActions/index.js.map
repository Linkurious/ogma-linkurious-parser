{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/customActions/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2019\n *\n * - Created on 2019-08-13.\n */\n\nimport {\n  CustomActionElement,\n  CustomActionParsingError,\n  CustomActionParsingErrorKey,\n  CustomActionType,\n  CustomActionVariable,\n  GenericObject,\n  GraphSchema,\n  LkDate,\n  LkDateTime,\n  LkEdge,\n  LkNode,\n  LkProperty,\n  ParsedCustomAction\n} from '@linkurious/rest-client';\nimport difference from 'lodash/difference';\nimport * as nearley from 'nearley';\nimport {hasValue} from '@linkurious/rest-client/dist/src/utils';\n\nimport AbstractTemplate, {AbstractTokenType} from '../abstractParser';\n\nimport grammar from './expressionGrammar';\n\nexport interface ContextData {\n  baseURL: string;\n  sourceKey: string;\n  vizId: number;\n  nodes: LkNode[];\n  edges: LkEdge[];\n}\n\ninterface CustomActionParsedExpression {\n  variable: {\n    value: CustomActionVariable;\n    offset: number;\n  };\n  itemType?: {\n    value: string;\n    offset: number;\n  };\n  property?: {\n    value: string;\n    offset: number;\n  };\n}\n\nconst {BASE_URL, SOURCE_KEY, VISUALIZATION, NODE_SET, EDGE_SET, NODE, EDGE} = CustomActionVariable;\n\nexport default class CustomActionTemplate {\n  /**\n   * Encode a node or edge property value to a URL safe value.\n   */\n  private static encodeLkValue(item: string | number | boolean | LkDate | LkDateTime): string {\n    if (typeof item === 'object' && 'type' in item && item.type === 'date') {\n      // `value` is a date with an ISO value property, we return only yyyy-mm-dd\n      return encodeURIComponent(item.value.slice(0, 10));\n    }\n    if (typeof item === 'object' && 'type' in item && item.type === 'datetime') {\n      // `value` is a date with an ISO value property, we return only yyyy-mm-ddThh:mm:ss\n      return encodeURIComponent(item.value.slice(0, 19));\n    }\n\n    return encodeURIComponent(item);\n  }\n\n  private static isGraphItemExpression(\n    element: CustomActionElement\n  ): element is\n    | {\n        value: string;\n        type: 'ca-expression';\n        variable: CustomActionVariable.NODE_SET | CustomActionVariable.EDGE_SET;\n        itemType?: string;\n      }\n    | {\n        value: string;\n        type: 'ca-expression';\n        variable: CustomActionVariable.NODE | CustomActionVariable.EDGE;\n        itemType?: string;\n        property?: string;\n      } {\n    return element.type === 'ca-expression' && 'itemType' in element;\n  }\n\n  private static isGraphPropertyExpression(\n    element: CustomActionElement\n  ): element is {\n    value: string;\n    type: 'ca-expression';\n    variable: CustomActionVariable.NODE | CustomActionVariable.EDGE;\n    itemType?: string;\n    property?: string;\n  } {\n    return element.type === 'ca-expression' && 'property' in element;\n  }\n\n  /**\n   * We filter out missing, invalid, conflict and undefined from LkProperties\n   */\n  private static getValidLkPropertyKeys(lkProperties: GenericObject<LkProperty>): string[] {\n    const selectedNodeProperties: string[] = [];\n    for (const propertyKey of Object.keys(lkProperties)) {\n      const lkProperty = lkProperties[propertyKey];\n      if (hasValue(lkProperty) && !(typeof lkProperty === 'object' && 'status' in lkProperty)) {\n        selectedNodeProperties.push(propertyKey);\n      }\n    }\n    return selectedNodeProperties;\n  }\n\n  /**\n   * Returns whether a visible custom action should be shown (enabled) or grayed out (disabled).\n   */\n  private static isEnabled(customAction: ParsedCustomAction, contextData: ContextData): boolean {\n    const commonItemType = (\n      customAction.elements.filter(CustomActionTemplate.isGraphItemExpression)[0] || {}\n    ).itemType;\n\n    const allProperties = customAction.elements\n      .filter(CustomActionTemplate.isGraphPropertyExpression)\n      .map((e) => e.property)\n      .filter(hasValue);\n\n    switch (customAction.type) {\n      case CustomActionType.NON_GRAPH: {\n        return true;\n      }\n      case CustomActionType.NODE: {\n        if (commonItemType && !contextData.nodes[0].data.categories.includes(commonItemType)) {\n          return false;\n        }\n        const selectedNodeProperties = CustomActionTemplate.getValidLkPropertyKeys(\n          contextData.nodes[0].data.properties\n        );\n        return !(\n          allProperties.length !== 0 &&\n          difference(allProperties, selectedNodeProperties).length !== 0\n        );\n      }\n      case CustomActionType.EDGE: {\n        if (commonItemType && contextData.edges[0].data.type !== commonItemType) {\n          return false;\n        }\n        const selectedNodeProperties = CustomActionTemplate.getValidLkPropertyKeys(\n          contextData.edges[0].data.properties\n        );\n        return !(\n          allProperties.length !== 0 &&\n          difference(allProperties, selectedNodeProperties).length !== 0\n        );\n      }\n      case CustomActionType.NODESET: {\n        return (\n          !commonItemType ||\n          contextData.nodes.filter((node) => node.data.categories.includes(commonItemType))\n            .length !== 0\n        );\n      }\n      case CustomActionType.EDGESET: {\n        return (\n          !commonItemType ||\n          contextData.edges.filter((edge) => edge.data.type === commonItemType).length !== 0\n        );\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Return a rendered custom action template.\n   */\n  public static render(\n    customAction: ParsedCustomAction,\n    contextData: ContextData\n  ): string | undefined {\n    if (!CustomActionTemplate.isEnabled(customAction, contextData)) {\n      return undefined;\n    }\n\n    let renderedString = '';\n    for (const element of customAction.elements) {\n      if (element.type === 'ca-literal') {\n        renderedString += element.value;\n      } else {\n        const variable = element.variable;\n        const itemType = CustomActionTemplate.isGraphItemExpression(element)\n          ? element.itemType\n          : undefined;\n        const property = CustomActionTemplate.isGraphPropertyExpression(element)\n          ? element.property\n          : undefined;\n        let value: string;\n        switch (variable) {\n          case NODE: {\n            const [node] = contextData.nodes;\n            if (property === undefined) {\n              value = encodeURIComponent(node.id);\n            } else {\n              // In isEnabled(), we ensured that all the lkProperties we're gonna encode\n              // are not invalid, missing, conflict or undefined\n              value = CustomActionTemplate.encodeLkValue(\n                node.data.properties[property] as string | number | boolean | LkDate | LkDateTime\n              );\n            }\n            break;\n          }\n          case EDGE: {\n            const [edge] = contextData.edges;\n            if (property === undefined) {\n              value = encodeURIComponent(edge.id);\n            } else {\n              // In isEnabled(), we ensured that all the lkProperties we're gonna encode\n              // are not invalid, missing, conflict or undefined\n              value = CustomActionTemplate.encodeLkValue(\n                edge.data.properties[property] as string | number | boolean | LkDate | LkDateTime\n              );\n            }\n            break;\n          }\n          case NODE_SET: {\n            value = contextData.nodes\n              .filter((node) =>\n                itemType === undefined ? true : node.data.categories.includes(itemType)\n              )\n              .map((node) => encodeURIComponent(node.id))\n              .join(',');\n            break;\n          }\n          case EDGE_SET: {\n            value = contextData.edges\n              .filter((edge) => (itemType === undefined ? true : edge.data.type === itemType))\n              .map((edge) => encodeURIComponent(edge.id))\n              .join(',');\n            break;\n          }\n          case VISUALIZATION: {\n            value = encodeURIComponent(contextData.vizId + '');\n            break;\n          }\n          case SOURCE_KEY: {\n            value = encodeURIComponent(contextData.sourceKey);\n            break;\n          }\n          case BASE_URL: {\n            value = contextData.baseURL;\n            break;\n          }\n          default: {\n            value = '';\n            break;\n          }\n        }\n        renderedString += value;\n      }\n    }\n    return renderedString;\n  }\n\n  /**\n   * Return the parsed items from a valid custom action, or the errors from an invalid custom action.\n   */\n  public static parse(\n    template: string,\n    nodeSchema: GraphSchema = {results: []},\n    edgeSchema: GraphSchema = {results: []}\n  ): ParsedCustomAction | {errors: CustomActionParsingError[]} {\n    const elements: CustomActionElement[] = [];\n    let errors: CustomActionParsingError[] = [];\n    const variables: {value: CustomActionVariable; offset: number}[] = [];\n    const validVariablesAndItemTypes: {\n      parsedExpression: CustomActionParsedExpression;\n      tokenOffset: number;\n    }[] = [];\n\n    const abstractTokens = AbstractTemplate.tokenize(template);\n    if (abstractTokens.length === 1 && abstractTokens[0].value.length === template.length) {\n      return {\n        errors: [\n          {\n            key: CustomActionParsingErrorKey.NO_EXPRESSIONS,\n            start: 0,\n            end: template.length\n          }\n        ]\n      };\n    }\n\n    for (const token of abstractTokens) {\n      const {type, value, start, end} = token;\n      if (type === AbstractTokenType.LITERAL) {\n        elements.push({\n          type: 'ca-literal',\n          value: value\n        });\n        continue;\n      }\n\n      const expressionErrors: CustomActionParsingError[] = [];\n      let invalidItemType = false;\n      const parsingResult = CustomActionTemplate.parseExpression(value, start, end);\n\n      // non-parsable expressions\n      if ('key' in parsingResult) {\n        expressionErrors.push(parsingResult);\n      }\n\n      // parsable expressions\n      else {\n        const {variable, itemType, property} = parsingResult;\n        // we store all the variables to determine the type of template\n        variables.push(variable);\n\n        if (property !== undefined && property.value === '') {\n          expressionErrors.push({\n            key: CustomActionParsingErrorKey.INVALID_EXPRESSION_SYNTAX,\n            start: start + property.offset,\n            end: end\n          });\n        }\n\n        // Variables that need to check its itemType against Schema\n        if ([NODE_SET, EDGE_SET, NODE, EDGE].includes(variable.value)) {\n          if (itemType !== undefined) {\n            let nodeEdgeSchema = nodeSchema;\n            let unknownItemType = CustomActionParsingErrorKey.UNKNOWN_NODE_CATEGORY;\n            if ([EDGE_SET, EDGE].includes(variable.value)) {\n              nodeEdgeSchema = edgeSchema;\n              unknownItemType = CustomActionParsingErrorKey.UNKNOWN_EDGE_TYPE;\n            }\n            const types = nodeEdgeSchema.results.filter((type) => type.itemType === itemType.value);\n            if (types.length === 0) {\n              invalidItemType = true;\n              expressionErrors.push({\n                key: unknownItemType,\n                start: start + itemType.offset,\n                end: start + itemType.offset + itemType.value.length\n              });\n            }\n          }\n        }\n\n        // Variables that are not allowed to have itemType\n        if (\n          itemType !== undefined &&\n          [VISUALIZATION, SOURCE_KEY, BASE_URL].includes(variable.value)\n        ) {\n          expressionErrors.push({\n            key: CustomActionParsingErrorKey.INVALID_SEMANTIC,\n            start: start + itemType.offset - 1,\n            end: start + itemType.offset + itemType.value.length,\n            variable: variable.value,\n            unsupportedRestriction: 'type'\n          });\n        }\n\n        // Variables that are not allowed to have property\n        if (\n          property !== undefined &&\n          [NODE_SET, EDGE_SET, VISUALIZATION, SOURCE_KEY, BASE_URL].includes(variable.value)\n        ) {\n          expressionErrors.push({\n            key: CustomActionParsingErrorKey.INVALID_SEMANTIC,\n            start: start + property.offset - 1,\n            end: start + property.offset + property.value.length,\n            variable: variable.value,\n            unsupportedRestriction: 'property'\n          });\n        }\n      }\n\n      if (end === template.length) {\n        expressionErrors.push({\n          key: CustomActionParsingErrorKey.UNCLOSED_EXPRESSION,\n          start: start,\n          end: end\n        });\n      }\n\n      // if parsing and itemType didn't raise an error\n      if (!('key' in parsingResult) && !invalidItemType) {\n        validVariablesAndItemTypes.push({parsedExpression: parsingResult, tokenOffset: start});\n        const element: GenericObject = {\n          type: 'ca-expression',\n          value: value,\n          variable: parsingResult.variable.value\n        };\n\n        const {itemType, property} = parsingResult;\n        if (itemType) {\n          element.itemType = itemType.value;\n        }\n        if (property) {\n          element.property = property.value;\n        }\n        elements.push(element as CustomActionElement);\n      }\n\n      errors = errors.concat(expressionErrors);\n    }\n\n    const candidateType = CustomActionTemplate.resolveCustomActionType(variables);\n\n    if (typeof candidateType === 'object' && 'errors' in candidateType) {\n      errors = errors.concat(candidateType.errors);\n      return {\n        errors: errors\n      };\n    }\n\n    errors = CustomActionTemplate.checkIncompatibleRestrictions(errors, validVariablesAndItemTypes);\n\n    if (errors.length > 0) {\n      return {\n        errors: errors\n      };\n    }\n\n    return {\n      type: candidateType,\n      elements: elements\n    };\n  }\n\n  /**\n   * For edge and node templates, if there is one element with a type restriction:\n   *  - Adds an error for all the elements that don't have restriction\n   *  - Adds an error for all the elements with a restriction different than the first restriction found\n   */\n  private static checkIncompatibleRestrictions(\n    errors: CustomActionParsingError[],\n    expressions: {parsedExpression: CustomActionParsedExpression; tokenOffset: number}[]\n  ): CustomActionParsingError[] {\n    const allErrors: CustomActionParsingError[] = errors.slice();\n    const variablesWithoutItemType: {\n      value: CustomActionVariable.NODE | CustomActionVariable.EDGE;\n      offset: number;\n      tokenOffset: number;\n    }[] = [];\n    let firstItemType: string | undefined = undefined;\n    for (const {parsedExpression, tokenOffset} of expressions) {\n      const {variable, itemType} = parsedExpression;\n      if (\n        variable.value === CustomActionVariable.NODE ||\n        variable.value === CustomActionVariable.EDGE\n      ) {\n        if (hasValue(itemType)) {\n          if (!hasValue(firstItemType)) {\n            firstItemType = itemType.value;\n          } else if (firstItemType !== itemType.value) {\n            // parsedExpression has an error, its restriction should be the same as firstItemType\n            allErrors.push({\n              key: CustomActionParsingErrorKey.INCOMPATIBLE_RESTRICTIONS,\n              variable: variable.value,\n              restrictionType: variable.value === CustomActionVariable.NODE ? 'category' : 'type',\n              start: tokenOffset + itemType.offset,\n              end: tokenOffset + itemType.offset + itemType.value.length\n            });\n          }\n        } else {\n          variablesWithoutItemType.push({\n            value: variable.value,\n            offset: variable.offset,\n            tokenOffset: tokenOffset\n          });\n        }\n      }\n    }\n\n    if (hasValue(firstItemType) && variablesWithoutItemType.length !== 0) {\n      // there are some that have restriction\n      // the ones without itemType (elementsWithoutItemType) have error\n      for (const {value, offset, tokenOffset} of variablesWithoutItemType) {\n        allErrors.push({\n          key: CustomActionParsingErrorKey.INCOMPATIBLE_RESTRICTIONS,\n          variable: value,\n          restrictionType: value === CustomActionVariable.NODE ? 'category' : 'type',\n          start: tokenOffset + offset,\n          end: tokenOffset + offset + value.length\n        });\n      }\n    }\n\n    return allErrors;\n  }\n\n  /**\n   * Return a parse expression or a parsing error.\n   * Input: (node:PERSON).name\n   * Output: {variable: {value: 'node', offset: 1}, itemType: {value: 'PERSON', offset: 6}, property: {value: 'name', offset: 14}}\n   */\n  public static parseExpression(\n    tokenValue: string,\n    tokenStart: number,\n    tokenEnd: number\n  ): CustomActionParsedExpression | CustomActionParsingError {\n    if (tokenValue === '') {\n      return {\n        key: CustomActionParsingErrorKey.EMPTY_EXPRESSION,\n        start: tokenStart,\n        end: tokenEnd\n      };\n    }\n\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n\n    try {\n      parser.feed(tokenValue);\n    } catch (ex) {\n      // This happens when an expected character (char not defined in grammar.ne) is found\n      return {\n        key: CustomActionParsingErrorKey.INVALID_EXPRESSION_SYNTAX,\n        start: tokenStart + ex.offset,\n        end: tokenStart + ex.offset + 1\n      };\n    }\n\n    // When parser.feed succeed but does not have any parser.results\n    if (parser.results.length === 0) {\n      return {\n        key: CustomActionParsingErrorKey.INVALID_EXPRESSION_SYNTAX,\n        start: tokenStart + tokenValue.length,\n        end: tokenStart + tokenValue.length\n      };\n    }\n\n    if (!Object.values(CustomActionVariable).includes(parser.results[0].variable.value)) {\n      return {\n        key: CustomActionParsingErrorKey.INVALID_VARIABLE,\n        start: tokenStart + parser.results[0].variable.offset,\n        end:\n          tokenStart + parser.results[0].variable.offset + parser.results[0].variable.value.length\n      };\n    }\n\n    return parser.results[0] as CustomActionParsedExpression;\n  }\n\n  /**\n   * Return the type of a custom action or an incompatible-type-combination\n   */\n  private static resolveCustomActionType(\n    variables: {value: CustomActionVariable; offset: number}[]\n  ): CustomActionType | {errors: CustomActionParsingError[]} {\n    const errors: CustomActionParsingError[] = [];\n    let referenceVariable: CustomActionVariable | undefined = undefined;\n    for (const {value, offset} of variables) {\n      // Graph variables are ignored as they are compatible with all variables\n      if (value === SOURCE_KEY || value === VISUALIZATION || value === BASE_URL) {\n        continue;\n      }\n\n      // The first variable's value determines our template type\n      if (!hasValue(referenceVariable)) {\n        referenceVariable = value;\n        continue;\n      }\n\n      // If the first variable is nodeset or edgeset, we don't allow more variables\n      // If the first variable is node or edge, all variables have to be the same variable\n      if (\n        referenceVariable === NODE_SET ||\n        referenceVariable === EDGE_SET ||\n        referenceVariable !== value\n      ) {\n        errors.push({\n          key: CustomActionParsingErrorKey.INVALID_TEMPLATE_COMBINATION,\n          start: offset,\n          end: offset + value.length,\n          variables: [referenceVariable, value]\n        });\n      }\n    }\n\n    if (errors.length > 0) {\n      return {errors: errors};\n    }\n\n    return ((referenceVariable as string) as CustomActionType) || CustomActionType.NON_GRAPH;\n  }\n}\n"]}
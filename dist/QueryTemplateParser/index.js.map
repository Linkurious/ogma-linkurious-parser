{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/QueryTemplateParser/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * LINKURIOUS CONFIDENTIAL\n * Copyright Linkurious SAS 2012 - 2019\n *\n * - Created on 2018-01-22.\n */\n// external libs\n\nimport {Valcheck} from 'valcheck/lib/valcheck/Valcheck';\n// local libs\nimport {\n  ErrorHighlight,\n  GenericObject,\n  GraphQueryInputType,\n  Template,\n  TemplateFieldType\n} from '@linkurious/rest-client';\n\nimport * as tools from '../tools/tools';\n\nimport {RawFieldChecker} from './RawFieldChecker';\nimport {NodeChecker} from './NodeChecker';\nimport {NodeSetChecker} from './NodeSetChecker';\nimport {StringChecker} from './StringChecker';\nimport {NumberChecker} from './NumberChecker';\nimport {BooleanChecker} from './BooleanChecker';\nimport {EnumChecker} from './EnumChecker';\nimport {DateChecker} from './DateChecker';\nimport {DateTimeChecker} from './DateTimeChecker';\nimport {EnvChecker} from './EnvChecker';\nimport {Level, Message, ParserError} from './ParserError';\n\nexport interface ModifiedQuery {\n  query: string;\n  correctionTable: OffsetCorrection[];\n}\n\nexport interface OffsetCorrection {\n  offset: number;\n  displacement: number;\n}\n\nexport interface TemplateCheckerAttributes {\n  type: TemplateFieldType;\n  shorthand: string;\n  defaultSerializer: InputSerialization;\n}\n\nexport enum InputSerialization {\n  NODE = 'node',\n  NODE_SET = 'nodeset',\n  NUMBER = 'number',\n  STRING = 'string',\n  BOOLEAN = 'boolean',\n  NATIVE_DATE = 'date',\n  NATIVE_DATE_TIME = 'datetime',\n  ENV = 'env'\n}\n\ninterface QueryStatistics {\n  checkedTemplates: Map<string, {count: number; value: Template}>;\n  checkedTypes: Map<TemplateFieldType, {count: number; keys: Set<string>}>;\n  validTemplates: Template[];\n  needOptions: Array<{key: string; index: number; template: string}>;\n  hasOptions: Set<string>;\n}\n\ninterface TemplateFieldComponents {\n  key: {value: string; highlight: ErrorHighlight};\n  type: {value: string; highlight: ErrorHighlight};\n  jsonOptions?: {value: string; highlight: ErrorHighlight};\n}\n\nexport type TemplateDataValue = string | string[] | number | Date;\n\nexport default class QueryTemplateParser<E> {\n  private readonly checkType: Valcheck<E>;\n  private readonly checkOptions: Valcheck<E>;\n  private readonly handleError: (error: string, highlight?: ErrorHighlight) => E;\n  private readonly handleBug: (error: string) => E;\n  private readonly templateCheckers: GenericObject<RawFieldChecker<E>>;\n\n  constructor(\n    errorHandler: (error: string, highlight?: ErrorHighlight) => E,\n    bugHandler?: (bugMessage: string) => E\n  ) {\n    const throwTypeError = (message: Message) => {\n      throw ParserError.type(message);\n    };\n    const throwOptionsError = (message: Message) => {\n      throw ParserError.options(message);\n    };\n    this.checkType = new Valcheck(throwTypeError as (error: string) => E, bugHandler);\n    this.checkOptions = new Valcheck(throwOptionsError as (error: string) => E, bugHandler);\n    this.handleError = errorHandler;\n    this.handleBug =\n      bugHandler ||\n      ((bug) => {\n        throw new Error(bug);\n      });\n    this.templateCheckers = {\n      [TemplateFieldType.NUMBER]: new NumberChecker(this.checkOptions),\n      [TemplateFieldType.STRING]: new StringChecker(this.checkOptions),\n      [TemplateFieldType.ENUM]: new EnumChecker(this.checkOptions),\n      [TemplateFieldType.NODE]: new NodeChecker(this.checkOptions),\n      [TemplateFieldType.NODE_SET]: new NodeSetChecker(this.checkOptions),\n      [TemplateFieldType.DATE]: new DateChecker(this.checkOptions),\n      [TemplateFieldType.DATE_TIME]: new DateTimeChecker(this.checkOptions),\n      [TemplateFieldType.BOOLEAN]: new BooleanChecker(this.checkOptions),\n      [TemplateFieldType.ENV]: new EnvChecker(this.checkOptions)\n    };\n  }\n\n  private static get TEMPLATE_RX(): RegExp {\n    // Captures anything within templateFields brackets. Format: {{...}}\n    // 1) [{]{2} opening brackets for the template field\n    // 2) ([^{].*?) match any character, excludes additional opening brackets\n    // 3) [}]{2,3} closing brackets, can be 3 if json-options are defined as json\n    // [\\s\\S] Match whitespace and non whitespace characters equivalent to (. | \\n)\n    return /[{]{2}(?:[^{][\\s\\S]*?)?[}]{2,3}/g;\n  }\n\n  private static get FIELD_RX(): RegExp {\n    // Captures `JSON-name`, `type` and `JSON-options`. Format: \"`JSON-name` : `type` [ : `JSON-options` ]\"\n    // 1) \\s*\"(.*)\"\\s* matches `JSON-name`, must be within quotes, spaces around are ignored\n    // 2) :\\s*(\\w*)\\s* matches `type`, must be a word, spaces around are ignored\n    // 3) (?::(.*))? Non capturing group matches `JSON-options` only when `type` is followed by \":\"\n    // [\\s\\S] Match whitespace and non whitespace characters equivalent to (. | \\n)\n    return /^(\\s*\"([\\s\\S]+)\"\\s*):(\\s*\\w+\\s*)(?::([\\s\\S]*))?$/g;\n  }\n\n  /**\n   * Return true if the `query` contains template fields.\n   *\n   * @param query\n   */\n  public static isTemplate(query: string): boolean {\n    return QueryTemplateParser.TEMPLATE_RX.test(query);\n  }\n\n  /**\n   * Correct the offset with changes recorded in the correction table.\n   *\n   * @param offset\n   * @param correctionTable\n   */\n  public static correctOffset(offset: number, correctionTable: OffsetCorrection[]): number {\n    correctionTable = tools.sortBy(correctionTable, 'offset');\n    for (const correction of correctionTable) {\n      if (offset >= correction.offset) {\n        offset += correction.displacement;\n      }\n    }\n    return offset;\n  }\n\n  /**\n   * @param template\n   * @param statistics\n   */\n  private checkTemplateField(\n    template: Template,\n    statistics: QueryStatistics,\n    ignoreEnv?: boolean\n  ): void {\n    const {checkedTemplates, checkedTypes, validTemplates} = statistics;\n\n    // increment the types count in statistics\n    const checkedType = checkedTypes.get(template.type) || {\n      count: 0,\n      keys: new Set([template.key])\n    };\n\n    checkedType.count += 1;\n    checkedType.keys.add(template.key);\n    checkedTypes.set(template.type, checkedType);\n\n    // 1) template fields with more than 2 node templates with different keys\n    if (template.type === TemplateFieldType.NODE && checkedType.keys.size > 2) {\n      throw ParserError.template(Message.AT_MOST_2_NODE_INPUT);\n    }\n\n    // 2) template fields contain more than 1 nodeset input\n    if (template.type === TemplateFieldType.NODE_SET && checkedType.keys.size > 1) {\n      throw ParserError.template(Message.AT_MOST_1_NODE_SET_INPUT);\n    }\n\n    const duplicate = checkedTemplates.get(template.key);\n\n    if (duplicate === undefined) {\n      checkedTemplates.set(template.key, {count: 1, value: template});\n      if (template.type !== TemplateFieldType.ENV || !ignoreEnv) {\n        validTemplates.push(template);\n      }\n    } else {\n      // the query contains duplicate templates\n      duplicate.count += 1;\n      const existingTemplate = duplicate.value;\n\n      // 3) template is already seen but types don't match\n      if (existingTemplate.type !== template.type) {\n        throw ParserError.template(Message.CONFLICTING_TYPES, {\n          key: template.key,\n          existingType: existingTemplate.type,\n          newType: template.type\n        });\n      }\n\n      const exists = (o: unknown) => o !== undefined && o !== null;\n\n      // 4) template is already seen but options don't match\n      if (\n        exists(template.options) &&\n        exists(existingTemplate.options) &&\n        !tools.isEqual(existingTemplate.options, template.options)\n      ) {\n        const currentOptions = JSON.stringify(template.options);\n        const existingOptions = JSON.stringify(existingTemplate.options);\n        throw ParserError.template(Message.CONFLICTING_OPTIONS, {\n          key: template.key,\n          existingOptions: existingOptions,\n          newOptions: currentOptions\n        });\n      }\n\n      // 5) template was already seen but options were not defined\n      if (exists(template.options)) {\n        existingTemplate.options = template.options;\n      }\n    }\n\n    // 6) template fields contain a mix of nodes and nodeset inputs\n    if (checkedTypes.has(TemplateFieldType.NODE) && checkedTypes.has(TemplateFieldType.NODE_SET)) {\n      throw ParserError.template(Message.MIXED_NODE_NODE_SET_INPUT);\n    }\n\n    // 7) template fields contain an env template field but no node or nodeset inputs\n    if (\n      checkedTypes.has(TemplateFieldType.ENV) &&\n      !(checkedTypes.has(TemplateFieldType.NODE_SET) || checkedTypes.has(TemplateFieldType.NODE))\n    ) {\n      throw ParserError.template(Message.ENV_INPUT_WITHOUT_GRAPH_INPUT);\n    }\n  }\n\n  /**\n   * @param templateString\n   */\n  private parseTemplateKey(templateString: string): string | E {\n    const parsedField = QueryTemplateParser.FIELD_RX.exec(templateString);\n    const key = parsedField && parsedField[2];\n\n    if (key === null || key === undefined) {\n      return this.handleBug(Message.BUG_CANNOT_PARSE_TEMPLATE_KEY);\n    }\n\n    return key;\n  }\n\n  private findFailedMatchCause(templateString: string): ParserError {\n    const quoted = (s: string) => /^\\s*[\"]([\\s\\S]*?)[\"]/g.test(s);\n    const quotedButEmpty = (s: string) => /^\\s*[\"](\\s*?)[\"]/g.test(s);\n    const quotedAndTyped = (s: string) => /^\\s*[\"]([\\s\\S]*?)[\"]\\s*[:][^\\s]+/g.test(s);\n\n    if (!quoted(templateString)) {\n      // e.g: {{a}} or {{\"a}} or {{a\"}} or {{}}\n      return ParserError.key(Message.KEY_NOT_QUOTED);\n    } else if (quotedButEmpty(templateString)) {\n      // e.g: {{\"\"}} or {{\"   \"}}\n      return ParserError.key(Message.EMPTY_NAME);\n    }\n\n    if (!quotedAndTyped(templateString)) {\n      // e.g: {{\"a\":}} or {{\"a\":  }} or {{\"a\"}}\n      return ParserError.type(Message.TYPE_MISSING);\n    }\n\n    // we could not find the cause, let's return a generic message.\n    return ParserError.field(Message.INVALID_TEMPLATE_FORMAT, {template: templateString});\n  }\n\n  /**\n   * Return the position of any template field left opened.\n   */\n  private findNonClosedTemplateField(text: string, offset = 0): ErrorHighlight | undefined {\n    const beforeNextTemplateRx = /^([\\s\\S]*?)(?:[{]{2}|$)/g; // grab everything before the next opening brackets \"...{{\"\n    const isClosedRx = /[}]{2}/g; // if the tested section contains closing brackets \"}}\"\n    const isOpenedRx = /[{]{2}([^{][\\s\\S]*)/g; // grab everything after the opening brackets \"{{...\"\n\n    const match = isOpenedRx.exec(text);\n    if (match !== null) {\n      // the template is definitely opened let's grab the content.\n      const content = match[1];\n      const beforeNext = beforeNextTemplateRx.exec(content);\n      if (beforeNext !== null) {\n        // we reached the start of the next template or the end of the string.\n        // let's check if the template was closed.\n        if (isClosedRx.test(beforeNext[1])) {\n          // the template is definitely closed, now let's check the rest of the string\n          // +2 to exclude the opening brackets in content offset\n          return this.findNonClosedTemplateField(content, offset + match.index + 2);\n        }\n        // the template was not closed let's return the position.\n        // +2 to include the opening brackets in the highlight\n        return {offset: offset + match.index, length: beforeNext[1].length + 2};\n      }\n    }\n  }\n\n  /**\n   * Extract JSON-name, type and JSON-options from `templateString`.\n   */\n  private static extractComponents(templateString: string): TemplateFieldComponents | null {\n    const match = QueryTemplateParser.FIELD_RX.exec(templateString);\n    if (match === null) {\n      return null;\n    }\n\n    const [, key, strippedKey, type, jsonOptions] = match;\n\n    const components: TemplateFieldComponents = {\n      key: {\n        value: strippedKey,\n        highlight: {\n          offset: match.index,\n          length: key.length\n        }\n      },\n      type: {\n        value: type.trim(),\n        highlight: {\n          offset: match.index + key.length + 1,\n          length: type.length\n        }\n      }\n    };\n\n    if (jsonOptions !== undefined) {\n      components.jsonOptions = {\n        value: jsonOptions,\n        highlight: {\n          offset: components.type.highlight.offset + type.length + 1,\n          length: jsonOptions.length\n        }\n      };\n    }\n\n    return components;\n  }\n\n  /**\n   * Extract and parse JSON-name, type and JSON-options from `templateString`.\n   *\n   * @param templateString\n   * @param nodeCategories\n   * @throws {Error} If `templateFieldDescription` does not match the format `JSON-name : type [ : JSON-options ]`\n   */\n  private parseTemplateField(templateString: string, nodeCategories?: string[]): Template {\n    const components = QueryTemplateParser.extractComponents(templateString);\n\n    if (components === null) {\n      throw this.findFailedMatchCause(templateString);\n    }\n\n    if (tools.includes(components.key.value, '\\n')) {\n      throw ParserError.key(Message.SINGLE_LINE_NAME);\n    }\n\n    const type = components.type.value as TemplateFieldType;\n\n    this.checkType.values('type', type, tools.values(TemplateFieldType));\n\n    const templateChecker = this.templateCheckers[type];\n\n    const jsonOptions = tools.get(components, 'jsonOptions.value');\n\n    const parsedOptions = templateChecker.parseJsonOptions(jsonOptions, nodeCategories);\n\n    // JSON-options could be optional depending on the type\n    if (parsedOptions !== undefined) {\n      return {\n        key: components.key.value,\n        type: type,\n        options: parsedOptions\n      } as Template;\n    } else {\n      return {\n        key: components.key.value,\n        type: type\n      } as Template;\n    }\n  }\n\n  /**\n   * Parse a raw query template into template fields.\n   * - Extract from `rawQueryTemplate` all template fields with the format `{{ JSON-name : type [ : JSON-options ] }}`\n   * - Create a `templateFields` object mapping each `JSON-name` to it's type and JSON-options\n   *\n   * e.g.: MATCH (n)-[e]->(n2) where id(n)={{\"n\":node:\"Person\"}} and id(n2)={{\"n2\":node}}\n   * => {\n   *      n: {\n   *        type: 'node',\n   *        options: {categories: ['Person']}\n   *      },\n   *      n2: {\n   *        type: 'node'\n   *      }\n   *    }\n   *\n   * @param rawQueryTemplate\n   * @param nodeCategories\n   * @param strict           Whether to fail if `query` contains not template fields\n   */\n  public parse(\n    rawQueryTemplate: string,\n    nodeCategories?: string[],\n    strict?: boolean,\n    ignoreEnv?: boolean\n  ): Template[] | E {\n    const notClosedHighlight = this.findNonClosedTemplateField(rawQueryTemplate);\n\n    if (notClosedHighlight !== undefined) {\n      return this.handleError(Message.TEMPLATE_NOT_CLOSED, notClosedHighlight);\n    }\n\n    if (!QueryTemplateParser.isTemplate(rawQueryTemplate)) {\n      if (strict) {\n        return this.handleError(Message.NO_TEMPLATE_FOUND);\n      }\n      return [];\n    }\n\n    const templateRx = QueryTemplateParser.TEMPLATE_RX;\n    const statistics: QueryStatistics = {\n      checkedTemplates: new Map(),\n      checkedTypes: new Map(),\n      validTemplates: [],\n      needOptions: [],\n      hasOptions: new Set()\n    };\n\n    do {\n      const match = templateRx.exec(rawQueryTemplate);\n      if (match === null) {\n        break;\n      }\n      const template = this.getTemplateFieldContent(match[0]);\n\n      if (template.length === 0) {\n        return this.handleError(Message.EMPTY_NAME, {offset: match.index, length: match[0].length});\n      }\n\n      try {\n        const templateField = this.parseTemplateField(template, nodeCategories);\n        this.checkTemplateField(templateField, statistics, ignoreEnv);\n        if (this.templateCheckers[templateField.type].needOptions(nodeCategories)) {\n          if (templateField.options === undefined) {\n            statistics.needOptions.push({\n              key: templateField.key,\n              index: match.index,\n              template: template\n            });\n          } else {\n            statistics.hasOptions.add(templateField.key);\n          }\n        }\n      } catch (error) {\n        const highlight = this.calculateHighlight(\n          error.level,\n          QueryTemplateParser.extractComponents(template),\n          match.index,\n          // Add +4 on template length to include brackets `{{}}`\n          template.length + 4\n        );\n\n        return this.handleError(error.message, highlight);\n      }\n    } while (true);\n\n    for (const {key, index, template} of statistics.needOptions) {\n      if (!statistics.hasOptions.has(key)) {\n        const highlight = this.calculateHighlight(\n          Level.OPTIONS,\n          QueryTemplateParser.extractComponents(template),\n          index,\n          // Add +4 on template length to include brackets `{{}}`\n          template.length + 4\n        );\n\n        return this.handleError(Message.MISSING_OPTIONS, highlight);\n      }\n    }\n\n    return this.orderTemplateFields(statistics.validTemplates);\n  }\n\n  private getTemplateFieldContent(template: string) {\n    // we get the content of the template by removing the enclosing brackets '{{}}'\n    // the reason we don't use the capture group is that it removes the last `}` if json-options are used\n    return template.substring(2, template.length - 2);\n  }\n\n  /**\n   * Calculate error highlight based on `level`.\n   */\n  private calculateHighlight(\n    level: Level,\n    components: TemplateFieldComponents | null,\n    templateOffset: number,\n    templateLength: number\n  ): ErrorHighlight {\n    if (components !== null) {\n      if (level === Level.KEY) {\n        return {\n          offset: components.key.highlight.offset + templateOffset + 2,\n          length: components.key.highlight.length\n        };\n      }\n\n      if (level === Level.TYPE) {\n        return {\n          offset: components.type.highlight.offset + templateOffset + 2,\n          length: components.type.highlight.length\n        };\n      }\n\n      if (level === Level.OPTIONS) {\n        if (components.jsonOptions && components.jsonOptions.highlight) {\n          return {\n            offset: components.jsonOptions.highlight.offset + templateOffset + 2,\n            length: components.jsonOptions.highlight.length\n          };\n        } else {\n          return {\n            offset:\n              components.type.highlight.offset +\n              (components.type.highlight.length || 0) +\n              templateOffset +\n              2\n          };\n        }\n      }\n    }\n\n    if (level !== Level.TEMPLATE) {\n      // we couldn't highlight a specific component, let's highlight the content of the template\n      return {\n        offset: templateOffset + 2,\n        length: templateLength - 4\n      };\n    }\n\n    return {offset: templateOffset, length: templateLength};\n  }\n\n  /**\n   * Enforce the ordering of the template fields.\n   * nodeset and nodes fields should appear first\n   *\n   *\n   * @param templateFields\n   */\n  private orderTemplateFields(templateFields: Template[]): Template[] {\n    const [graph, nonGraph] = tools.partition(\n      templateFields,\n      ({type}) => type === TemplateFieldType.NODE || type === TemplateFieldType.NODE_SET\n    );\n    return tools.concat(graph, nonGraph);\n  }\n\n  /**\n   * Get graph query input type from template fields.\n   *\n   * @param templateFields\n   */\n  public static getInputType(templateFields: Template[]): GraphQueryInputType {\n    let seenNode = false;\n\n    for (const templateField of templateFields) {\n      if (templateField.type === 'nodeset') {\n        return GraphQueryInputType.NODESET;\n      }\n\n      if (templateField.type === 'node') {\n        if (seenNode) {\n          return GraphQueryInputType._2_NODES;\n        }\n        seenNode = true;\n      }\n    }\n\n    if (seenNode) {\n      return GraphQueryInputType._1_NODE;\n    }\n\n    return GraphQueryInputType.NONE;\n  }\n\n  /**\n   * Validate each `templateData` value against the type\n   * in `templateFields` mapped with the same key.\n   *\n   * Return a list of `templateData` for each node input of a `1-node` query\n   * Return a list with a single `templateData` for other input types\n   *\n   * Each templateData is validated and the values are quoted with the `quote` method\n   *\n   * @param templateData\n   * @param templateFields\n   * @param quote          Vendor specific method to validate ids and serialize values\n   * @throws {Error} If values in `templateData` are not valid with respect to `templateFields`\n   */\n  private getValidTemplateDataSet(\n    templateData: GenericObject<unknown>,\n    templateFields: Template[],\n    quote?: (data: TemplateDataValue, serializer: InputSerialization) => string\n  ): Array<GenericObject<string>> {\n    const validTemplateData: GenericObject<string> = {};\n    let batched = false;\n    const firstKey: string = templateFields[0].key;\n    let checkedBatchValues: string[] = [];\n\n    // 1) decide whether we created a batched template data or not\n    if (QueryTemplateParser.getInputType(templateFields) === GraphQueryInputType._1_NODE) {\n      // If graph input is 1_NODE, the first template field is the node template\n      if (Array.isArray(templateData[firstKey])) {\n        batched = true;\n      }\n    }\n\n    // validate and quote template data\n    for (const templateField of templateFields) {\n      const value = templateData[templateField.key];\n      if (value === undefined) {\n        throw ParserError.data(Message.MISSING_DATA, {\n          field: templateField.key,\n          type: templateField.type\n        });\n      }\n      const checker = this.templateCheckers[templateField.type];\n      const check = checker.validateInput.bind(checker);\n\n      if (batched && templateField.key === firstKey) {\n        // 2) If we create a batched template data, validate all the values\n        checkedBatchValues = (value as Array<unknown>).map((v) =>\n          check({key: templateField.key, value: v}, quote, templateField.options)\n        );\n      } else {\n        validTemplateData[templateField.key] = check(\n          {key: templateField.key, value: value},\n          quote,\n          templateField.options\n        );\n      }\n    }\n\n    // 3) Duplicate template data for each checked value.\n    if (checkedBatchValues.length > 0) {\n      return checkedBatchValues.map((v) => tools.defaults({[firstKey]: v}, validTemplateData));\n    }\n\n    return [validTemplateData];\n  }\n\n  /**\n   * @param rawQueryTemplate\n   * @param templateData\n   */\n  private bindTemplate(\n    rawQueryTemplate: string,\n    templateData: GenericObject<string>\n  ): ModifiedQuery {\n    const offsetCorrectionTable: OffsetCorrection[] = [];\n    const query = rawQueryTemplate.replace(QueryTemplateParser.TEMPLATE_RX, (match, offset) => {\n      // When TEMPLATE_RX contains no capture group, the second param of the replacer is the offset\n      const templateString = this.getTemplateFieldContent(match);\n      const value = templateData[this.parseTemplateKey(templateString) as string];\n      offsetCorrectionTable.push({\n        offset: offset + value.length, // offset indicates that any index after the index needs to be corrected with the value of displacement\n        displacement: match.length - value.length // displacement is the correction to be applied after offset\n      });\n      return value;\n    });\n    return {\n      query: query,\n      correctionTable: offsetCorrectionTable\n    };\n  }\n\n  /**\n   * Replace `rawQueryTemplate` fields with `templateData` values.\n   * - Detect fields in `rawQueryTemplate` with the format `{{ JSON-name : type [ : JSON-options ] }}`\n   * - Replace the fields with corresponding `templateData[JSON-name]`\n   *\n   * e.g.:\n   * - rawQueryTemplate = MATCH (n)-[e]->(n2) where id(n)={{\"n\":node:\"Person\"}}\n   * - templateData = {n: 42}\n   * => MATCH (n)-[e]->(n2) where id(n)=42\n   *\n   * @param rawQueryTemplate Templated GraphQuery content\n   * @param templateData     Key/value pair to be filled in rawQueryTemplate\n   * @param templateFields\n   * @param quote\n   * @throws {Error} If any field found in `rawQueryTemplate` does not match the format `JSON-name : type [ : JSON-options ]`\n   */\n  public generateRawQueries(\n    rawQueryTemplate: string,\n    templateData: GenericObject<unknown>,\n    templateFields: Template[],\n    quote?: (data: TemplateDataValue, serializer: InputSerialization) => string\n  ): ModifiedQuery[] | E {\n    try {\n      return this.getValidTemplateDataSet(templateData, templateFields, quote).map((data) =>\n        this.bindTemplate(rawQueryTemplate, data)\n      );\n    } catch (error) {\n      return this.handleError(error.message);\n    }\n  }\n}\n"]}
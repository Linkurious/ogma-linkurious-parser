
/*
* Ogma - Graph visualization library
* Version: 2.7.16 (built on Thu Oct 29 2020 11:54:46 GMT+0100 (Central European Standard Time))
* Author: Linkurious SAS
* License: (c) Linkurious 2020. All rights reserved.
*/


declare module "utils/misc" {
    export function isInteger(x: number): boolean;
    /**
     * Convert a string representing a object property path (e.g "a.b.c") to an array indicating the path (["a", "b", "c"]).
     * If the argument is an array, ensures all the cells are string
     * @param name
     * @return {*}
     */
    export function toPropertyPath(name: string | string[]): string[];
    /**
     * Throttles function `fn` calls to occur not more than once per `time` ms
     *
     * https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js#L70
     *
     * @param  {Function} fn      Function to throttle
     * @param  {number}   time    ms
     * @param  {*=}       context optional function context
     * @return {Function} throttled function
     */
    export function throttle(fn: (...args: unknown[]) => unknown, time: number, context?: any): (...args: unknown[]) => void;
    interface Debounced {
        (...args: unknown[]): any;
        clear(): void;
        flush(): void;
    }
    export function debounce(func: (...args: unknown[]) => unknown, wait?: number, immediate?: boolean): Debounced;
    /**
     * Async queue processor
     * @param  {Array<any>} input Input values
     * @param  {function(item:any, i:number, input:Array<any>, stop: function():void, fail: function(msg: string):void):Promise<void>} fn Processor
     * @return {Promise<void>}
     */
    export function processQueue(input: unknown[], fn: (item: unknown, i: number, input: unknown[], stop: () => void, fail: (msg: string) => void) => Promise<unknown>): Promise<{}>;
    export function isLittleEndian(): boolean;
}
declare module "modules/core/graph/utils" {
    import { PropertyPath } from "api/data";
    export function getToJsonOptions(options: {
        attributes?: PropertyPath[] | 'all';
        data?: (data: any) => any;
    }): {
        attributes?: PropertyPath[];
        data?: (data: any) => any;
    };
    export function warn(nbArgs: number): void;
    export function deprecate(classes: Function[], deprecatedMethod: {
        [index: string]: string;
    }): void;
}
declare module "api/tools/brand" {
    import Ogma from "src/ogma";
    /**
     * @public
     * @typedef {object} BrandOptions
     * @property {"top-left"|"top-right"|"bottom-left"|"bottom-right"} [position="bottom-right"] Indicates the position of the brand.
     * @property {number} [horizontalMargin=0] Indicates the space in pixels between the brand and the top/bottom of the screen (depending on the position)
     * @property {number} [verticalMargin=0] Indicates the space in pixels between the brand and the right/left of the screen (depending on the position)
     * @property {string} [className] If specified, this class will be added to the HTML created HTML element.
     */
    export interface BrandOptions {
        position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        horizontalMargin?: number;
        verticalMargin?: number;
        className?: string;
    }
    const _default: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.brand.set
         * Display the specified HTML in one of the corner of the canvas.
         *
         * If the brand shows in one of the corner of the page instead of the Ogma container, change the css "position" attribute
         * of the container to "relative".
         * @param {string} html HTML content to display.
         * @param {BrandOptions} [options]
         * @return {HTMLElement}
         * @example
         * ogma.tools.brand.set('<a href="http://www.my-company.com">Powered by MyCompany</a>', {
         *   position: "top-right",
         *   className: "myCssClass"
         * });
         */
        set(html: string, options: BrandOptions): HTMLDivElement;
        /**
         * @method Ogma.tools.brand.remove
         * Remove the brand HTML element.
         */
        remove(): void;
    };
    export default _default;
}
declare module "api/geo" {
    import Ogma from "src/ogma";
    import { PropertyPath } from "api/data";
    import { BrandOptions } from "api/tools/brand";
    import { Color } from "types/utilities";
    import Node from "modules/core/graph/node";
    /**
     * @public
     * @typedef {Object} GeoCoordinate
     * @property {number} latitude Latitude (degrees)
     * @property {number} longitude Longitude (degrees)
     */
    export interface GeoCoordinate {
        latitude: number;
        longitude: number;
    }
    /**
     * @public
     * @typedef {Object} MapPosition
     * @property {number} latitude Latitude (degrees)
     * @property {number} longitude Longitude (degrees)
     * @property {number} zoom      Map scale
     */
    export interface MapPosition {
        latitude: number;
        longitude: number;
        zoom: number;
    }
    /**
     * @public
     * @typedef {Object} GeoModeOptions
     * @property {PropertyPath}  [latitudePath='latitude']    Node path which contains the latitude.
     * @property {PropertyPath}  [longitudePath='longitude']  Node path which contains the longitude.
     * @property {number}  [maxZoomLevel=20]            Maximum geo-spatial zoom.
     * @property {boolean} [wrapCoordinates=true]       Whether to wrap the coordinate to the projection space of
     *                                               [-180, 180] for longitude, [-85, 85] for longitude.
     *                                               If set to false, nodes with coordinates outside of that
     *                                               range will not be shown.
     * @property {number}  [sizeRatio=1]             Multiplier for the node radius an edge width.
     * @property {string}  [tileUrlTemplate='https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png']
     *                                               Format of the URL used to search for tiles.
     *                                               Must contain `'{z}'` (zoom level of the tile),
     *                                               `'{x}'` and `'{y}'` (coordinates of the tile).
     *                                               Possible `'{s}'` (replaced by one of the
     *                                               characters in the `tileUrlSubdomains` setting).
     * @property {string}  [tileUrlSubdomains='abc']    Values with which the '{s}' string in the URL can be replaced.
     * @property {number}  [tileBuffer=1]               Number of extra tiles to be downloaded around
     *                                               the viewport bounds, to make the panning smoother.
     * @property {string}  [attribution=null]           HTML string that will be displayed on the
     *                                               corner, indicates the source of the tiles
     * @property {BrandOptions} [attributionOptions]  Position and options for the attribution message
     * @property {Color}   [backgroundColor='silver']   Color of the map background (color of the missing tiles).
     * @property {number}  [opacity=1]                  Map baselayer opacity
     * @property {number}  [duration=0]                 Duration of the transition when swapping mode.
     * @property {boolean} [disableNodeDragging=true]   Disable node dragging when the mode is on. On by default.
     * @property {boolean} [detectRetina=false]         If user is on a retina display, tiles
     *                                               of deeper zoom level will be requested to
     *                                               utilize the high resolution.
     */
    export interface GeoModeOptions {
        latitude?: PropertyPath;
        longitude?: PropertyPath;
        maxZoomLevel?: number;
        sizeRatio?: number;
        tileUrlTemplate?: string;
        tileUrlSubdomains?: string;
        tileBuffer?: number;
        attribution?: string | null;
        attributionOption?: BrandOptions;
        opacity?: number;
        duration?: number;
        backgroundColor?: Color;
        disableNodeDragging?: boolean;
        detectRetina?: boolean;
    }
    const createGeoAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.geo.enable
         *
         * Enables geo mode layout
         *
         * @param  {GeoModeOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.geo.enable({ tileUrlTemplate: 'http://{s}.myTileProvider.com/{z}/{x}/{y}.png'})
         *   .then(function() { console.log('geo mode is on'); });
         */
        enable: (options?: GeoModeOptions) => Promise<void>;
        /**
         * @method Ogma.geo.disable
         *
         * Disables geo layout
         * @param  {GeoModeOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.geo.disable({ tileUrlTemplate: 'http://{s}.myTileProvider.com/{z}/{x}/{y}.png'})
         *   .then(function() { console.log('geo mode is off'); });
         */
        disable: (options?: GeoModeOptions) => Promise<void>;
        /**
         * @method Ogma.geo.setOptions
         * Update module settings
         *
         * @param  {GeoModeOptions} [options]
         *
         * @example
         * ogma.geo.setOptions({ latitudePath: 'geo.lat', longitudePath: 'geo.lng' });
         * ogma.enable().then(function() { console.log('geo mode is on'); });
         */
        setOptions: (options: GeoModeOptions) => any;
        /**
         * @method Ogma.geo.enabled
         *
         * Check whether geographical mode is enabled
         * @return {boolean}
         *
         * @example
         * if (ogma.geo.enabled()) console.log('geo mode is enabled');
         */
        enabled: () => boolean;
        /**
         * @method Ogma.geo.getCenter
         *
         * Returns current map position
         * @return {GeoCoordinate}
         *
         * @example
         * ogma.geo.enable()
         *   .then(function() {
         *     console.log(ogma.geo.getCenter());
         *     // { "latitude": 50.25, "longitude":1.14 }
         *   });
         */
        getCenter: () => GeoCoordinate;
        /**
         * @method Ogma.geo.getView
         *
         * Returns current map position
         * @return {MapPosition}
         * @example
         * ogma.geo.enable()
         *   .then(function() {
         *     console.log(ogma.geo.getView());
         *     // { "latitude": 50.25, "longitude":1.14, "zoom": 9 }
         *   });
         */
        getView: () => MapPosition;
        /**
         * @method Ogma.geo.getZoom
         *
         * Returns current map zoom level
         * @return {number}
         *
         * @example
         * ogma.geo.enable().then(function() {
         *   console.log(ogma.geo.getZoom()); // 9
         * });
         */
        getZoom: () => number;
        /**
         * @method Ogma.geo.setZoom
         *
         * Sets zoom level of the map
         * @param  {number} zoom
         *
         * @example
         * ogma.geo.setZoom(10);
         */
        setZoom: (zoom: number) => void;
        /**
         * @method Ogma.geo.setView
         *
         * Set map view - coordinates and zoom level
         * @param  {number} latitude
         * @param  {number} longitude
         * @param  {number} zoom
         *
         * @example
         * ogma.geo.setView(55.2, 46.12, 10);
         */
        setView: (latitude: number, longitude: number, zoom: number) => any;
        /**
         * @method Ogma.geo.setCenter
         *
         * Centers the map at given coodinates
         * @param  {number} latitude
         * @param  {number} longitude
         *
         * @example
         * ogma.geo.setCenter(12.5, 55.2);
         */
        setCenter: (latitude: number, longitude: number) => any;
        /**
         * @method Ogma.geo.toggle
         *
         * Toggles geo mode. Useful when you don't want to store information about
         * whether the mode was on or off(e.g. with an UI switcher).
         * @param {GeoModeOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * // switch geo mode on or off by a UI element without checking its state
         * checkbox.addEventListener('change', function () {
         *   ogma.geo.toggle({ tileUrlTemplate: URL });
         * });
         */
        toggle: (options: GeoModeOptions) => Promise<void>;
        /**
         * @method Ogma.geo.resetCoordinates
         *
         * Reset geographical coordinates of the nodes to the initial values
         *
         * @example
         * var node = ogma.getNode('id');
         * console.log(node.getGeoCoordinates()); // { latitude: 5, longitude: 10 }
         * ogma.getNode('id').setGeoCoordinates({ latitude: 0, longitude: 0 });
         * console.log(node.getGeoCoordinates()); // { latitude: 0, longitude: 0 }
         * ogma.geo.resetCoodinates();
         * console.log(node.getGeoCoordinates()); // { latitude: 5, longitude: 10 }
         */
        resetCoordinates: () => void;
        /**
         * @method Ogma.geo.updateCoordinates
         *
         * Recalculates geographical coordinates of the nodes from their position
         * on the screen. It is automatically invoked after user has dragged a node,
         * but you have to use it yourself in case you have moved the nodes
         * programmatically in order not to lose their new geographical positions.
         *
         * @example Updating the coordinates from node positions
         *
         * ogma.getNodes(['n1', 'n2']).setAttributes([{x: 15, y: 20}, {x: 100, y: 200}]);
         * ogma.geo.updateCoordinates();
         */
        updateCoordinates: () => void;
        /**
         * @method Ogma.geo.getUnprojectedCoordinates
         *
         * Returns underlying X and Y positions for the nodes that are currently
         * handled by the geo-mode.
         * @param {Array<NodeId>|Filter|Array<Node>} [selector="visible"]
         * @return {Array<{x: number, y: number}>}
         */
        getUnprojectedCoordinates: (selector: (string | number)[] | "all" | "visible" | "raw" | Node[]) => import('ogma').NodeAttributes[];
    };
    export default class GeoAPI {
        geo: ReturnType<typeof createGeoAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}

declare module "utils/boundingBox" {
    export interface SimpleBoundingBox {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
        width?: number;
        height?: number;
        cx?: number;
        cy?: number;
    }
    export const simpleBoundingBox: () => SimpleBoundingBox;
    export default class BoundingBox {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
        minScaledSize: number;
        maxScaledSize: number;
        minFixedSize: number;
        maxFixedSize: number;
        cx: number;
        cy: number;
        width: number;
        height: number;
    }
}
declare module "index" {
    import Ogma from "src/ogma";
    export default Ogma;
}
declare module "modules/transformations/transformation" {
    import Ogma from "index";
    export type TransformationName = 'node-filter' | 'edge-filter' | 'node-grouping' | 'edge-grouping';
    export type TransformationId = number;
    /**
     * @public
     * Control handle for the transformation.
     * @class Transformation
     */
    export class Transformation {
        /**
         * @method Transformation.getName
         * Returns the name of the transformation.
         * @returns {"node-filter"|"edge-filter"|"node-grouping"|"edge-grouping"}
         */
        getName(): TransformationName;
        /**
         * @method Transformation.getId
         * Returns the id of the transformation, a unique strictly positive integer.
         * @returns {number}
         */
        getId(): TransformationId;
        /**
         * @method Transformation.whenApplied
         * Returns a Promise that resolves the first time the transformation is applied.
         * @returns {Promise<void>}
         */
        whenApplied(): Promise<this>;
        /**
         * @method Transformation.isEnabled
         * Indicates if the transformation is enabled
         * @returns {boolean}
         */
        isEnabled(): boolean;
        /**
         * @method Transformation.enable
         * Enable the transformation over the specified amount of time.
         * @param {number} [duration=0] Animation duration in ms
         * @returns {Promise<void>}
         */
        enable(duration: number): void;
        /**
         * @method Transformation.disable
         * Disable the transformation over the specified amount of time.
         * @param {number} [duration=0] Animation duration in ms
         * @returns {Promise<void>}
         */
        disable(duration: number): void;
        /**
         * @method Transformation.toggle
         * Toggle the transformation over the specified amount of time.
         * @param {number} [duration=0] Animation duration in ms
         * @returns {Promise<void>}
         */
        toggle(duration: number): void;
        /**
         * @method Transformation.getIndex
         * Retrieves the index of the transformation in the pipeline.
         * @returns {number}
         */
        getIndex(): number;
        /**
         * @method Transformation.setIndex
         * Set the index of the transformation in the pipeline. The transformation with the lower index is applied first,
         * the one with the higher index is applied last.
         * @param index
         * @returns {Promise<void>}
         */
        setIndex(index: any): Promise<this>;
        /**
         * @method Transformation.destroy
         * Remove the transformation over the specified amount of time. After this methods is called,
         * the transformation is not manipulable anymore (cannot be enabled again for example).
         * Note: the animation will not be played if the transformation is not the last in the
         * transformation stack, because the transformations are sequential
         * @param {number} [duration=0] Animation duration in ms
         * @returns {Promise<void>}
         */
        destroy(duration?: number): Promise<void>;
        /**
         * @method Transformation.refresh
         * Refresh the transformation.
         * @returns {Promise<void>}
         */
        refresh(): Promise<void>;
        /**
         * @method Transformation.delete
         * Alias for `destroy`.
         * @param {number} [duration=0]
         * @returns {Promise<void>}
         * @deprecated
         */
        delete(duration?: number): Promise<void>;
    }
    /**
     * @typedef {object} TrainsformationMethods
     * @property {function({ogma: Ogma, duration: number, wrapper: Transformation}): Promise<any>} run
     * @property {function({ogma: Ogma, duration: number, wrapper: Transformation, context: any}): Promise<void>} undo
     * @property {function({ogma: Ogma, context: any}): Promise<void>} cleanup
     */
    export abstract class TrainsformationMethods {
        constructor(options?: any);
        abstract getName(): string;
        /**
         * @param {object} options
         * @param {Ogma} options.ogma
         * @param {number} options.duration,
         * @param {Transformation} options.wrapper
         * @param {any} options.context
         * @returns {Promise<any>}
         */
        abstract run(options: {
            ogma: Ogma;
            duration: number;
            context: any;
            wrapper: Transformation;
        }): Promise<any>;
        /**
         * @param {object} options
         * @param {Ogma} options.ogma
         * @param {number} options.duration,
         * @param {Transformation} options.wrapper
         * @param {any} options.context
         * @returns {Promise<void>}
         */
        abstract undo(options: {
            ogma: Ogma;
            duration: number;
            context: any;
            wrapper: Transformation;
        }): Promise<any>;
        /**
         * @param {object} options
         * @param {Ogma} options.ogma
         * @param {any} options.context
         * @returns {Promise<void>}
         */
        cleanup(options: {
            ogma: Ogma;
            context: any;
        }): Promise<void>;
    }
}
declare module "types/edgeAttributes" {
    import { Color, PixelSize, ScalingMethod, TextContent, LayerValue, OpacityValue } from "types/utilities";
    import { EdgeTextStyle } from "types/textStyles";
    /**
     * @public
     * @typedef {"line"|"arrow"|"tapered"|"dashed"|"dotted"} PredefinedEdgeShape These are valid values to ensure retro-compatibility with Ogma < 2.2
     * @typedef {"line"|"triangle"} EdgeType
     * @typedef {null|"arrow"|"circle-hole-arrow"|"triangle-hole-arrow"|"short-arrow"|"sharp-arrow"|"circle"|"square"} EdgeExtremity
     * @typedef {"plain"|"dotted"|"dashed"} EdgeStyle
     */
    export type PredefinedEdgeShape = 'line' | 'arrow' | 'tapered' | 'dashed' | 'dotted';
    export type EdgeType = 'line' | 'triangle';
    export type EdgeExtremity = null | 'arrow' | 'circle-hole-arrow' | 'triangle-hole-arrow' | 'short-arrow' | 'sharp-arrow' | 'circle' | 'square';
    export type EdgeStyle = 'plain' | 'dotted' | 'dashed';
    /**
     * @public
     * @typedef {object} EdgeAttributes
     * Default values indicate the system values (when an edge has not been assigned any value for that attribute).
     *
     * @property {PixelSize} [width=1]                                        Width of the edge (graph space)
     * @property {ScalingMethod} [scalingMethod="scaled"]                     Indicates if the edge width should be multiplied by the zoom when the edge is displayed.
     * @property {Color|"source"|"target"} [color="grey"]                     Color of the edge
     * @property {OpacityValue} [opacity=1]                                   Opacity of the edge. 0 = transparent, 1 = opaque.
     * @property {LayerValue} [layer=0]                                       Z-index of the node. Integer value between -1 and 3.
     * @property {number} [minVisibleSize=0]                                  If the edge width on screen is less than this value, it will not be displayed
     * @property {boolean} [detectable=true]                                  Indicates if the edge is detectable by the mouse.
     * @property {boolean} [adjustAnchors=true]                               If true, the edge's extremities' badges and shape will be taken into account when displaying it.
     *                                                                        Edges that ends with an arrow will stop at the node's badge/corner.
     *
     * @property {object|PredefinedEdgeShape} [shape]
     * @property {EdgeType} [shape.body="line"]                               Shape of the edge
     * @property {EdgeExtremity} [shape.head=null]                            Head of the edge
     * @property {EdgeExtremity} [shape.tail=null]                            Tail of the edge
     * @property {EdgeStyle} [shape.style="plain"]                            Style of the edge
     *
     * @property {object} [stroke]
     * @property {Color|"inherit"} [stroke.color="inherit"]                   Color of the edge stroke. If it is "inherit", uses the same color as for the body.
     * @property {PixelSize} [stroke.width=0]                                 Stroke width, in pixels.
     * @property {number} [stroke.minVisibleSize=0]                           If the edge width on screen is less than this value, the stroke will not be displayed
     *
     * @property {object|Color} [halo]                                        If not an object, alias to `halo.color`
     * @property {Color} [halo.color=null]                                    Color of the halo
     * @property {PixelSize} [halo.width=10]                                  Width of the halo, in pixels
     * @property {ScalingMethod} [halo.scalingMethod="fixed"]                 Indicates if the halo width should be multiplied by the zoom when the edge is displayed.
     *
     * @property {object}  [pulse]
     * @property {boolean} [pulse.enabled=false]                              If true, shows animated pulse around the edge.
     * @property {number}  [pulse.duration=1000]                              Lifespan of one pulse ripple (milliseconds).
     * @property {number}  [pulse.interval=800]                               Interval between two pulses (milliseconds).
     * @property {Color}   [pulse.startColor="rgba(0, 0, 0, 0.6)"]            Starting color of the pulse
     * @property {Color}   [pulse.endColor="rgba(0, 0, 0, 0)"]                End color of the pulse
     * @property {number}  [pulse.width=50]                                   Width of the pulse in pixels
     * @property {number}  [pulse.startRatio=1]                               Where the pulse starts, relative to the edge width (1 = at the edge border)
     * @property {number}  [pulse.endRatio=2]                                 Where the pulse ends, relative to the edge width (2 = 2x width of the edge)
     *
     * @property {object|boolean} [outline]                                   If not an object, alias to `outline.enabled`
     * @property {boolean} [outline.enabled=false]                            Indicates if the outline should be visible
     * @property {Color} [outline.color="rgba(0, 0, 0, 0.36)"]                Color of the outline
     * @property {number} [outline.minVisibleSize=0]                          If the edge width on screen is less than this value, the outline will ne be shown
     *
     * @property {object|TextContent} [text]                                  If not an object, alias to `text.content`
     * @property {TextContent} [text.content=null]                            Text to display
     * @property {string} [text.font="Arial"]                                 Font used to display the text
     * @property {Color} [text.color="black"]                                 Color of the text
     * @property {PixelSize} [text.size=12]                                   Text size (in pixels)
     * @property {number} [text.scale=1]                                      Text size relative to the edge width
     * @property {boolean} [text.scaling=false]                               Indicates if the `size` property (false) or the `scale` property (true) must be used to compute the text size
     * @property {FontStyle} [text.style="normal"]                              Style applied to the text
     * @property {TextAlign} [text.align="center"]                            Alignment of the text (for multi-line texts)
     * @property {Color|"inherit"} [text.backgroundColor=null]                Background color of the text
     * @property {PixelSize} [text.margin=2]                                  Space between the text and the edge, in pixels
     * @property {PixelSize} [text.padding=2]                                 Space between the text and its background's edge, in pixels
     * @property {PixelSize} [text.minVisibleSize=4]                          If the edge width on screen is less than this value, the text will not be shown
     * @property {number} [text.maxLineLength=0]                              If > 1, lines that have more characters than this value will be split across multiple lines. Affects both primary and secondary texts.
     * @property {boolean} [text.adjustAngle=true]                            In case the edge is shorter than the text, indicates if the text should be displayed horizontally. Only works for non-scaled texts.
     *
     * @property {object|TextContent} [text.secondary]                        If not an object, alias to `text.secondary.content`
     * @property {TextContent} [text.secondary.content=null]                  Text to display under the primary text
     * @property {string} [text.secondary.font="Arial"]                       Font used to display the secondary text
     * @property {Color} [text.secondary.color="black"]                       Color of the secondary text
     * @property {PixelSize} [text.secondary.size=12]                         Secondary text size (in pixels)
     * @property {number} [text.secondary.scale=0.8]                          Secondary text size (relative to the edge width)
     * @property {FontStyle} [text.secondary.style="normal"]                    Secondary text style
     * @property {TextAlign} [text.secondary.align="center"]                  Alignment of the secondary text (for multi-line texts)
     * @property {Color|"inherit"} [text.secondary.backgroundColor=null]      Background color of the secondary text
     * @property {PixelSize} [text.secondary.margin=2]                        Space between the secondary text and the edge
     * @property {PixelSize} [text.secondary.padding=2]                       Space between the secondary text and its background's edge, in pixels
     * @property {PixelSize} [text.secondary.minVisibleSize=4]                If the edge width on screen is less than this value, the secondary text will not be shown
     *
     * @deprecated
     * @property {boolean}   [hidden]                                         Alias for `opacity` (`true` -> opacity = 0, `false` -> opacity = 1)
     * @property {PixelSize} [strokeWidth]                                    Alias for `stroke.width`
     * @property {PixelSize} [halo.size]                                      Alias for `width`
     * @property {number}    [threshold]                                      Alias for `minVisibleSize`
     * @property {number}    [text.threshold]                                 Alias for `minVisibleSize`
     */
    export interface EdgeAttributes {
        width?: PixelSize;
        scalingMethod?: ScalingMethod;
        color?: Color | 'source' | 'target';
        opacity?: OpacityValue;
        layer?: LayerValue;
        minVisibleSize?: number;
        detectable?: boolean;
        adjustAnchors?: boolean;
        shape?: {
            body?: EdgeType;
            head?: EdgeExtremity;
            tail?: EdgeExtremity;
            style?: EdgeStyle;
        } | PredefinedEdgeShape;
        stroke?: {
            width?: PixelSize;
            color?: Color | 'inherit';
            minVisibleSize?: number;
        };
        halo?: {
            width?: PixelSize;
            color?: Color | 'inherit';
            scalingMethod?: ScalingMethod;
            size?: PixelSize;
        } | Color;
        pulse?: {
            enabled?: boolean;
            duration?: number;
            interval?: number;
            startColor?: Color;
            endColor?: Color;
            width?: number;
            startRatio?: number;
            endRatio?: number;
        };
        outline?: {
            enabled?: boolean;
            color?: Color;
            minVisibleSize?: number;
        } | boolean;
        text?: EdgeTextStyle | TextContent;
        hidden?: boolean;
        strokeWidth?: PixelSize;
        threshold?: number;
    }
}
declare module "modules/core/graph/edge" {
    import { Item, ItemIndex, PulseOptions } from "modules/core/graph/item";
    import { EdgeAttributesValue, AttributeAnimationOptions, EdgeId } from "types/utilities";
    import Ogma from "src/ogma";
    import { PropertyPath } from "api/data";
    import { EdgeDirection, Filter } from "types/utilities";
    import { LocateOptions } from "api/view";
    import BoundingBox from "utils/boundingBox";
    import { Transformation } from "modules/transformations/transformation";
    import EdgeList from "modules/core/graph/edgeList";
    import NodeList from "modules/core/graph/nodeList";
    import Node from "modules/core/graph/node";
    import { EdgeAttributes } from "types/edgeAttributes";
    export interface EdgeDirectionObject {
        direction: EdgeDirection;
        filter: Filter;
    }
    export default class Edge implements Item {
        readonly size = 1;
        readonly isNode = false;
        constructor(index: ItemIndex, ogma: Ogma);
        /**
         * @method Edge.setAttributes
         * Set the individual attributes of the edge.
         * @param {EdgeAttributesValue} attributes Attributes to update
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Edge>}
         */
        setAttributes(attributes: EdgeAttributesValue, options?: AttributeAnimationOptions, updatedAttributes?: boolean): Promise<Edge>;
        /**
         * @method Edge.setAttribute
         * Set the specified attribute of the edge.
         * @param {PropertyPath} attribute
         * @param {any} value
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Edge>}
         */
        setAttribute(attribute: PropertyPath, value: any, options?: AttributeAnimationOptions): Promise<Edge>;
        /**
         * @method Edge.getAttributes
         * Returns an object containing the specified attributes for the edge.
         * @param {Array<PropertyPath>} [attributeNames] List of attributes to include in the object. If not specified, includes all the edge attributes.
         * @return {EdgeAttributes}
         */
        getAttributes(attributeNames?: PropertyPath[]): EdgeAttributes;
        /**
         * @method Edge.getAttribute
         * Returns the value of the specified attribute for the edge.
         * @param {PropertyPath} attributeName Attribute to retrieve.
         * @return {any}
         */
        getAttribute(attributeName: PropertyPath): any;
        /**
         * @method Edge.resetAttributes
         * Remove all attributes that have been applied through `setAttributes`. Original attributes or attributes applied by the rules are not affected.
         * @param {Array<PropertyPath>} [attributeNames] List of attributes to clear. If no attribute is specified, clear all of them.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Edge>}
         */
        resetAttributes(attributeNames?: PropertyPath[], options?: AttributeAnimationOptions): Promise<Edge>;
        replaceOriginalAttributes(attributes: any, excluded: any): void;
        getPreviousAttributes(names: any): any;
        /**
         * @method Edge.isInView
         * Indicates if the edge is visible in the current view.
         * @param {object} [options]
         * @param {number} [options.margin=0] Tolerance in pixels.
         * @returns {boolean}
         */
        isInView(options?: {
            margin?: number;
        }): boolean;
        /**
         * @method Edge.getParallelEdges
         * Retrieves the list of edges parallel to the edge, including the source edge itself.
         * @param {object} [options]
         * @param {Filter} [options.filter="visible"] Indicates which edges to take into account
         * @returns {EdgeList}
         */
        getParallelEdges(options?: {
            filter: Filter;
        }): EdgeList;
        fastGetAdjacentElements(): {
            nodes: NodeList;
            edges: EdgeList;
        };
        /**
         * @method Edge.isVisible
         * Indicates if the edge is visible. A edge is not visible if it has been filtered out, or if it is used in a
         * transformation.
         * /!\ A edge with an opacity of 0 is considered visible!
         * @return {boolean}
         */
        isVisible(): boolean;
        isExcluded(): any;
        setExcluded(value: any): any;
        setVisible(value: any): any;
        /**
         * @method Edge.toList
         * Returns a new EdgeList that contains only the edge.
         * @return {EdgeList}
         */
        toList(): EdgeList;
        /**
         * @method Edge.getId
         * Returns the id of the edge.
         * @returns {EdgeId}
         */
        getId(): EdgeId;
        /**
         * @method Edge.getSource
         * Returns the source node of the edge
         * @return {Node}
         */
        getSource(): Node;
        /**
         * @method Edge.getTarget
         * Returns the target node of the edge
         * @return {Node}
         */
        getTarget(): Node;
        /**
         * @method Edge.getExtremities
         * Returns a `NodeList` containing the source and the target of the edge.
         * @return {NodeList}
         */
        getExtremities(): NodeList;
        /**
         * @method Edge.setSource
         * Set the source node of the edge.
         * @param {Node} source
         */
        setSource(source: Node): void;
        /**
         * @method Edge.setTarget
         * Set the target node of the edge.
         * @param {Node} target
         */
        setTarget(target: Node): void;
        slice(): EdgeList;
        /**
         * @method Edge.toJSON
         * Returns an object containing the id, source id, target id, attributes and data of the edge.
         * @param {object} [options]
         * @param {Array<PropertyPath>|"all"} [options.attributes="all"] List of attributes to retrieve. By default, retrieve all attributes.
         * @param {function (data: any): any} [options.data] Function that takes the edge's data in input and return
         * the data to retrieve. By default return the whole object.
         * @return {RawEdge}
         */
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): any;
        get(index: number): this;
        /**
         * @method Edge.setSelected
         * Add or remove the edge to/from the selection.
         * @param {boolean} active whether to select or unselect the edge.
         */
        setSelected(active: boolean): void;
        /**
         * @method Edge.isSelected
         * Indicates if the edge is currently selected.
         * @return {boolean}
         */
        isSelected(): boolean;
        /**
         * @method Edge.locate
         * Centers the view on the edge.
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.getEdge('e0').locate();
         */
        locate(options?: LocateOptions): Promise<void>;
        /**
         * @method Edge.getBoundingBox
         * Returns the bounding box of the edge, in graph coordinates.
         * @param {boolean} [ignoreCurvature=false] Use it if you want to only take into
         *                                          account the edge source and target.
         * @return {BoundingBox}
         */
        getBoundingBox(ignoreCurvature?: boolean): BoundingBox;
        /**
         * @method Edge.setData
         * Set the specified data property of the edge. If no property is specified, update the whole data object.
         * @param {PropertyPath} [property]
         * @param {any|function(edge: Edge): any} value
         * @return {Edge}
         */
        setData(value: any | ((edge: Edge) => any)): Edge;
        setData(property: PropertyPath, value: any | ((edge: Edge) => any)): Edge;
        /**
         * @method Edge.getData
         * Retrieve the specified data property of the edge. If no property is specified, retrieve the whole data object.
         * This method method returns the internal data object; modifying it could cause unexpected behavior.
         * @param {PropertyPath} [property]
         * @return {any}
         */
        getData(property?: PropertyPath): any;
        /**
         * @method Edge.addClass
         * Add the specified class to the edge.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Edge>}
         */
        addClass(className: string, options?: AttributeAnimationOptions): Promise<Edge>;
        /**
         * @method Edge.addClasses
         * Add the specified classes to the edge.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Edge>}
         */
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<Edge>;
        /**
         * @method Edge.removeClass
         * Remove the specified class from the edge.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Edge>}
         */
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<Edge>;
        /**
         * @method Edge.removeClasses
         * Remove the specified class from the edge.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Edge>}
         */
        removeClasses(classNames: string[], options: AttributeAnimationOptions): Promise<Edge>;
        /**
         * @method Edge.hasClass
         * Indicates if the edge has the specified class.
         * @param {string} className
         * @return {boolean}
         */
        hasClass(className: string): boolean;
        /**
         * @method Edge.getClassList
         * Returns the list of classes that the edge has.
         * @returns {Array<string>}
         */
        getClassList(): string[];
        getAnimationInformation(): any;
        /**
         * @method Edge.isVirtual
         * Indicates if the edge was created by a transformation (`true`) or not (`false`).
         * @returns {boolean}
         */
        isVirtual(): boolean;
        /**
         * @method Edge.getTransformation
         * Returns the transformation that created the edge, if it is virtual. Otherwise returns `null`.
         * @returns {Transformation|null}
         */
        getTransformation(): Transformation | null;
        /**
         * @method Edge.getMetaEdge
         * If the edge is grouped inside a meta-edge, returns this meta-edge. Otherwise, returns null.
         * @returns {Edge|null}
         */
        getMetaEdge(): Edge | null;
        /**
         * @method Edge.getSubEdges
         * If the edge is a meta-edge (result of a grouping), returns the list of edges that are part of the group
         * it represents. If it's not a meta-edge, returns `null`.
         * @returns {EdgeList|null}
         */
        getSubEdges(): EdgeList | null;
        /**
         * @method Edge.pulse
         * Highlights the edge. It's a shorthand for the case when you
         * want the elements pulse for `number * (interval - 1) + duration` milliseconds.
         * It will also update the pulse attributes of the items with the one provided
         * in the `.pulse()` call.
      
         * @param {object} [options]
         * @param {number} [options.number=1]                             Number of pulses
         * @param {number} [options.duration=1000]                        Duration of a pulse (milliseconds)
         * @param {number} [options.interval=800]                         Interval between two pulses (milliseconds)
         * @param {Color|"inherit"} [options.startColor="rgb(0,0,0,0.6)"] Starting color of the pulse
         * @param {Color|"inherit"} [options.endColor="rgb(0,0,0,0.0)"]   Ending color of the pulse
         * @param {number} [options.width=10]                             Width of the pulse in pixels
         * @param {number} [options.startRatio=1]                         Where the pulse starts, relative to the edge siz (1 = at the edge's border)
         * @param {number} [options.endRatio=2]                           Where the pulse ends, relative to the edge siz (1 = at the edge's border)
         */
        pulse(options?: PulseOptions): void;
    }
}
declare module "api/view" {
    import Ogma from "src/ogma";
    import { Easing, Point, Size, RawGraph } from "types/utilities";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import BoundingBox from "utils/boundingBox";
    /**
     * @public
     * @typedef  {object}             LocateOptions
     * @property {number}             [duration=0]              Duration of the camera movement, in milliseconds.
     * @property {EasingFunction}     [easing="quadraticInOut"] Easing function applied to the movement of the camera.
     * @property {boolean}            [ignoreZoomLimits=false]  If `true`, the options `interactions.zoom.minValue` and
     *                                                          `interactions.zoom.maxValue` are ignored.
     * @property {number}             [maxNodeSizeOnScreen=200] Additional restriction on the zoom that makes sure no node
     *                                                          is displayed with a diameter greater than this value, in pixels.
     *                                                          Set to 0 to disable this feature.
     * @property {object|number}      [padding]                 If a number, indicates the padding for the four sides.
     * @property {number}             [padding.top=40]          Top padding (in pixels).
     * @property {number}             [padding.bottom=40]       Bottom padding (in pixels).
     * @property {number}             [padding.left=40]         Left padding (in pixels).
     * @property {number}             [padding.right=40]        Right padding (in pixels).
     */
    export interface LocateOptions {
        duration?: number;
        easing?: Easing;
        ignoreZoomLimits?: boolean;
        maxNodeSizeOnScreen?: number;
        padding?: number | {
            top?: number;
            bottom?: number;
            left?: number;
            right?: number;
        };
    }
    /**
     * @public
     * @typedef {function(params: {smallestNodeSize: number, biggestNodeSize: number, graphWidth: number, graphHeight: number, viewWidth: number, viewHeight: number}): number} ZoomBoundaryFunction
     * @property {number} smallestNodeSize Diameter of the smallest node (graph space)
     * @property {number} biggestNodeSize Diameter of the biggest node (graph space)
     * @property {number} graphWidth Width of the graph (graph space)
     * @property {number} graphHeight Height of the graph (graph space)
     * @property {number} viewWidth Width of the view (pixels)
     * @property {number} graphHeight Height of the view (pixels)
     */
    export type ZoomBoundaryFunction = (params: {
        smallestNode?: number;
        biggestNodeSize?: number;
        graphWidth?: number;
        graphHeight?: number;
        viewWidth?: number;
        viewHeight?: number;
    }) => number;
    /**
     * @extends Options.interactions
     * @property {object}               [zoom]
     * @property {boolean}              [zoom.enabled=true] Indicates if zoom on mouse wheel should be enabled.
     * @property {boolean}              [zoom.onDoubleClick=false] Indicates if zoom on double click should be enabled.
     * @property {number}               [zoom.duration=150] Indicate the duration of a manual zoom.
     * @property {number}               [zoom.modifier=1.8] Indicate the zoom multiplier on the manual zoom.
     * @property {null|ZoomBoundaryFunction} [zoom.minValue]
     * Function indicating the minimum possible zoom. By default, it's not possible to zoom so the graph takes less
     * than 20% of the view. Set to `null` to remove the limit.
     * @property {null|ZoomBoundaryFunction} [zoom.maxValue]
     * Function indicating the maximum possible zoom. By default, it's not possible to zoom so the smallest node takes
     * more than 50% of the view. Set to `null` to remove the limit.
     * @property {EasingFunction}       [zoom.easing="quadraticOut"] Easing function to use for the zoom.
     * @property {boolean}              [zoom.hideNodes=false] Indicates if the nodes should be hidden when zooming manually.
     * @property {boolean}              [zoom.hideEdges=false] Indicates if the edges should be hidden when zooming manually.
     * @property {boolean}              [zoom.hideNodeTexts=false] Indicates if the node texts should be hidden when zooming manually.
     * @property {boolean}              [zoom.hideEdgeTexts=false] Indicates if the edge texts should be hidden when zooming manually.
     */
    /**
     * @extends Options.interactions
     * @property {object}   [pan]
     * @property {boolean}  [pan.enabled=true] Indicates if moving the view with the mouse should be enabled.
     * @property {boolean}  [pan.hideNodes=false] Indicates if the nodes should be hidden when moving the view.
     * @property {boolean}  [pan.hideEdges=false] Indicates if the edges should be hidden when moving the view.
     * @property {boolean}  [pan.hideNodeTexts=false] Indicates if the node texts should be hidden when moving the view.
     * @property {boolean}  [pan.hideEdgeTexts=false] Indicates if the edge texts should be hidden when moving the view.
     */
    /**
     * @extends Options.interactions
     * @property {object}   [rotation]
     * @property {boolean}  [rotation.enabled=true] Indicates if rotating the view with the mouse should be enabled.
     * @property {boolean}  [rotation.hideNodes=false] Indicates if the nodes should be hidden when rotating the view.
     * @property {boolean}  [rotation.hideEdges=false] Indicates if the edges should be hidden when rotating the view.
     * @property {boolean}  [rotation.hideNodeTexts=false] Indicates if the node texts should be hidden when rotating the view.
     * @property {boolean}  [rotation.hideEdgeTexts=false] Indicates if the edge texts should be hidden when rotating the view.
     */
    /**
     * @extends Options.interactions
     * @property {object}   [gesture]
     * @property {boolean}  [gesture.enabled=true] Indicates if zooming/rotating using two fingers should be enabled.
     * @property {boolean}  [gesture.hideNodes=false] Indicates if the nodes should be hidden when zooming/rotating the view using two fingers.
     * @property {boolean}  [gesture.hideEdges=false] Indicates if the edges should be hidden when zooming/rotating the view using two fingers.
     * @property {boolean}  [gesture.hideNodeTexts=false] Indicates if the node texts should be hidden when zooming/rotating the view using two fingers.
     * @property {boolean}  [gesture.hideEdgeTexts=false] Indicates if the edge texts should be hidden when zooming/rotating the view using two fingers.
     */
    /**
     * @public
     * @typedef {object} View
     * @property {number} x
     * @property {number} y
     * @property {number} zoom
     * @property {number} angle
     *
     * @typedef {object} CameraAnimationOptions
     * @property {number} [duration=0] Duration of the animation, in milliseconds.
     * @property {EasingFunction} [easing="linear"] Easing used by the animation.
     * @property {boolean} [ignoreZoomLimits=false]
     * If `false`, the options `interactions.zoom.minValue` and `interactions.zoom.maxValue` are ignored.
     * @property {number} [startAfter=0] Advanced usage. Number from 0 to 1 indicating after which percentage of the duration the animation must be started. For example,
     *                                   specifying 0.5 would cause the animation to start after half of its total duration, and to be played
     *                                   two times faster as a consequence.
     */
    export interface CameraAnimationOptions {
        duration?: number;
        easing?: Easing;
        ignoreZoomLimits?: boolean;
        startAfter?: number;
    }
    export interface View {
        x?: number;
        y?: number;
        zoom?: number;
        angle?: number;
        width?: number;
        height?: number;
    }
    export function createViewAPI(ogma: Ogma): {
        /**
         * @method Ogma.view.setZoom
         * Set the zoom level.
         * @param {number} zoom
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        setZoom: (zoom: number, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.zoomIn
         * Multiply the current zoom level by the specified amount.
         * @param {number|CameraAnimationOptions} [modifier] If not specified, uses the value used for manual (mouse wheel zoom.
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        zoomIn: (modifier: number | CameraAnimationOptions, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.zoomOut
         * Divide the current zoom level by the specified amount.
         * @param {number|CameraAnimationOptions} [modifier] If not specified, uses the value used for manual (mouse wheel) zoom.
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        zoomOut: (modifier: number | CameraAnimationOptions, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.getZoom
         * Indicates the current zoom level.
         * @return {number}
         */
        getZoom: () => number;
        /**
         * @method Ogma.view.setCenter
         * Set the center of the view, in graph coordinates.
         * @param {{x: number, y: number}} center
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        setCenter: (center: Point, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.move
         * Move the center of the view by the specified amount of pixels (NOT graph coordinates).
         * @param {{x: number, y: number}} offset
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        move: (offset: Point, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.getCenter
         * Indicates the center of the view.
         * @return {{x: number, y: number}}
         */
        getCenter: () => Point;
        /**
         * @method Ogma.view.setAngle
         * Set the angle of the view.
         * @param {number} angle Angle, in radians.
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        setAngle: (angle: number, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.rotate
         * Rotate the view by the specified angle.
         * @param {number} angle Angle, in radians.
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        rotate: (angle: number, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.getAngle
         * Indicates the current angle of the view.
         * @return {number} Angle, in radians.
         */
        getAngle: () => number;
        /**
         * @method Ogma.view.set
         * Set the view.
         * @param {object} view
         * @param {number} [view.x] X coordinate of the center of the view.
         * @param {number} [view.y] Y coordinate of the center of the view.
         * @param {number} [view.zoom] Zoom level of the view.
         * @param {number} [view.angle] Angle of the view, in radians.
         * @param {CameraAnimationOptions} [options]
         * @return {Promise<void>}
         */
        set: (view: Partial<View>, options?: CameraAnimationOptions) => Promise<void>;
        /**
         * @method Ogma.view.get
         * Retrieve the current view.
         * @return {{x: number, y: number, zoom: number, angle: number, width: number, height: number}}
         */
        get: () => View;
        /**
         * @method Ogma.view.graphToScreenCoordinates
         * Returns a position on the screen from graph coordinates (e.g a node's position).
         * @param {{x: number, y: number}} coordinates
         * @return {{x: number, y: number}}
         */
        graphToScreenCoordinates: (coordinates: Point) => Point;
        /**
         * @method Ogma.view.screenToGraphCoordinates
         * Returns graph coordinates from a position on the screen.
         * @param {{x: number, y: number}} coordinates
         * @return {{x: number, y: number}}
         */
        screenToGraphCoordinates: (coordinates: Point) => Point;
        /**
         * @method Ogma.view.getImageData
         * Returns a new [`ImageData`](https://developer.mozilla.org/en-US/docs/Web/API/ImageData), containing the pixels
         * that are displayed by the current renderer. If the current renderer is not canvas or WebGL, the method returns
         * `null`.
         *
         * If the screen has a pixel density greater than one (for example, retina screen), the retrieved ImageData will
         * not be rescaled and will have a bigger width and height than the view.
         *
         * Note: since it's simply copying pixels, this method is way faster than an image export
         * (`ogma.export.png()` for example).
         *
         * @returns {Promise<ImageData|null>}
         */
        getImageData: () => Promise<ImageData>;
        /**
         * @method Ogma.view.getElementAt
         * Returns the element located at the specified screen coordinates.
         * @param {object} pos
         * @param {number} pos.x
         * @param {number} pos.y
         * @return {Node|Edge|null}
         */
        getElementAt: (pos: Point) => Node | Edge;
        /**
         * @method Ogma.view.beforeNextFrame
         * Returns a Promise that resolves before the next frame is rendered.
         * @returns {Promise<void>}
         */
        beforeNextFrame: () => Promise<void>;
        /**
         * @method Ogma.view.afterNextFrame
         * Returns a Promise that resolves after the next frame is rendered.
         * @returns {Promise<void>}
         */
        afterNextFrame: () => Promise<void>;
        /**
         * @method Ogma.view.setFullScreen
         * Enable or disable the full screen mode.
         * @param {boolean} value `true` to enable the full screen mode, `false` to disable it.
         * @example
         * ogma.events.onKeyPress('f', function () {
         *   ogma.view.setFullScreen(!ogma.view.isFullScreen());
         * });
         */
        setFullScreen: (value: boolean) => void;
        /**
         * @method Ogma.view.isFullScreen
         * Indicates if the full screen mode is currently enabled.
         * @return {boolean}
         */
        isFullScreen: () => boolean;
        /**
         * @method Ogma.view.forceResize
         * Forces the canvas to be re-sized according to the container. Typically useful when the visibility of the Ogma
         * container changes, to notify Ogma that it must refresh the scene.
         * @example
         * // Create a container and hide it
         * let container = document.createElement('div');
         * div.style.display = 'none';
         *
         * ogma.setContainer(container);
         *
         * // Display the container and notify Ogma about it
         * div.style.display = 'block';
         * ogma.view.forceResize();
         */
        forceResize: () => void;
        /**
         * @method Ogma.view.getSize
         * Returns the view width and height.
         * @return {{ width: number, height: number }}
         */
        getSize: () => Size;
        /**
         * @method Ogma.view.setSize
         * Set the size of the view. This method only has effect if this instance of Ogma has no container.
         * @param {object} size
         * @param {number} size.width
         * @param {number} size.height
         * @return {Promise<void>}
         */
        setSize: (size: Size) => Promise<void>;
        /**
         * @method Ogma.view.locateGraph
         * Centers the view on the graph.
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.view.locateGraph({
         *   duration: 500
         * }).then(function () {
         *   console.log('Locate done!');
         * });
         */
        locateGraph: (options?: LocateOptions) => Promise<void>;
        /**
         * @method Ogma.view.locateRawGraph
         * Centers the view on the specified raw graph.
         * @param {RawGraph} graph
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * // We center the camera where the graph will be when added to Ogma,
         * // and then we add the graph progressively.
         * ogma.parse.gexfFromUrl('graphs/myBigGraph.gexf').then(function (graph) {
         *   ogma.view.locateRawGraph(graph);
         *   ogma.setGraph(graph, {batchSize: 1000});
         * });
         */
        locateRawGraph: (graph: RawGraph, options?: LocateOptions) => Promise<void>;
        /**
         * @method Ogma.view.getGraphBoundingBox
         * Returns the bounding box of the graph, in graph coordinates.
         * @return {BoundingBox}
         */
        getGraphBoundingBox: () => BoundingBox;
    };
    export default class ViewAPI {
        view: ReturnType<typeof createViewAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "modules/core/graph/itemList" {
    import { Item, ItemId, ItemAttributes, ItemAttributesValue } from "modules/core/graph/item";
    import { PropertyPath } from "api/data";
    import { LocateOptions } from "api/view";
    import { Color, RawItem, AttributeAnimationOptions } from "types/utilities";
    export type ItemListIndexes = Uint32Array;
    export interface ItemList {
        readonly isNode: boolean;
        readonly size: number;
        addClass(className: string, options?: AttributeAnimationOptions): Promise<ItemList>;
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<ItemList>;
        hasClass(className: string): boolean[];
        concat(items: ItemList): ItemList;
        dedupe(): ItemList;
        fillData(value: any): ItemList;
        fillData(property: PropertyPath, value: any): ItemList;
        filter(callback: (item: Item, index: number) => boolean): ItemList;
        forEach(callback: (item: Item, index: number) => void): void;
        get(index: number): Item;
        getAttribute(attributeName: PropertyPath): any[];
        getAttributes(attributes?: PropertyPath[]): Partial<ItemAttributes>[];
        getClassList(): string[][];
        getData(property?: PropertyPath): any[];
        getId(): ItemId[];
        includes(item: Item): boolean;
        inverse(): ItemList;
        isSelected(): boolean[];
        isVisible(): boolean[];
        locate(options?: LocateOptions): Promise<void>;
        map(callback: (item: Item, index: number) => any): any[];
        pulse(options?: {
            number?: number;
            duration?: number;
            interval?: number;
            startColor?: Color | 'inherit';
            endColor?: Color | 'inherit';
            width?: number;
            startRatio?: number;
            endRatio?: number;
        }): void;
        reduce(callback: (accumulator: any, currentValue: Item, index: number) => any, initialValue: any): any;
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<ItemList>;
        removeClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<ItemList>;
        resetAttributes(attributes?: PropertyPath[], options?: AttributeAnimationOptions): Promise<ItemList>;
        setAttributes(attributes: ItemAttributesValue | ItemAttributesValue[], options?: AttributeAnimationOptions): Promise<ItemList>;
        setData(values: any[] | ((edge: Item) => any)): ItemList;
        setData(property: PropertyPath, values: any[] | ((edge: Item) => any)): ItemList;
        setSelected(active: boolean | boolean[]): void;
        slice(start?: number, end?: number): ItemList;
        toArray(): Item[];
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): RawItem[];
        toList(): ItemList;
    }
}
declare module "modules/core/graph/edgeList" {
    import { ItemList, ItemListIndexes } from "modules/core/graph/itemList";
    import { EdgeAttributesValue, AttributeAnimationOptions, RawEdge } from "types/utilities";
    import Ogma from "src/ogma";
    import { PropertyPath } from "api/data";
    import { EdgeAttributes } from "types/edgeAttributes";
    import { Filter, EdgeId } from "types/utilities";
    import { LocateOptions } from "api/view";
    import BoundingBox from "utils/boundingBox";
    import { PulseOptions } from "modules/core/graph/item";
    import Edge from "modules/core/graph/edge";
    import NodeList from "modules/core/graph/nodeList";
    export default class EdgeList implements ItemList {
        readonly isNode = false;
        constructor(indexes: ItemListIndexes, ogma: Ogma);
        readonly size: number;
        /**
         * @method EdgeList.setAttributes
         * Set the individual attributes of all the edges in the list.
         * @param {EdgeAttributesValue|Array<EdgeAttributesValue>} attributes If a single attribute is specified, it is applied to all edges.
         * If an array is specified, each index of the array is assigned to the corresponding edge.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<EdgeList>}
         */
        setAttributes(attributes: EdgeAttributesValue | EdgeAttributesValue[], options?: AttributeAnimationOptions): Promise<EdgeList>;
        /**
         * @method EdgeList.setAttribute
         * Set the specified attribute of all the edges in the list.
         * @param {PropertyPath} attribute
         * @param {any|Array<any>} value If it is an array, the values will be spread across the edges of the list.
         * Otherwise the value will be assigned to all edges.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<EdgeList>}
         */
        setAttribute(attribute: PropertyPath, value: any | any[], options?: AttributeAnimationOptions): Promise<this>;
        /**
         * @method EdgeList.getAttributes
         * Returns an array of objects containing the specified attributes for each edge.
         * @param {Array<PropertyPath>} [attributes] List of attributes to include in the object. If not specified, includes all the edge attributes.
         * @return {EdgeAttributes[]}
         */
        getAttributes(attributes?: PropertyPath[]): EdgeAttributes[];
        /**
         * @method EdgeList.getAttribute
         * Returns an array containing the value of the specified attribute for each edge.
         * @param {PropertyPath} attributeName Attribute to retrieve.
         * @return {any[]}
         */
        getAttribute(attributeName: PropertyPath): any[];
        /**
         * @method EdgeList.resetAttributes
         * Remove all attributes that have been applied through `setAttributes` of all the edges in the list.
         * Original attributes or attributes applied by the rules are not affected.
         * @param {Array<PropertyPath>} [attributes] List of attributes to clear. If no attribute is specified, clear all of them.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<EdgeList>}
         */
        resetAttributes(attributes?: PropertyPath[], options?: AttributeAnimationOptions): Promise<EdgeList>;
        replaceOriginalAttributes(attributes: any, excluded?: any): void;
        /**
         * @method EdgeList.getParallelEdges
         * Retrieves the list of edges parallel to the edges, including the source edges themselves.
         * @param {object} [options]
         * @param {Filter} [options.filter="visible"] Indicates which edges to take into account
         * @returns {EdgeList}
         */
        getParallelEdges(options?: {
            filter?: Filter;
        }): EdgeList;
        fastGetAdjacentElements(): any;
        /**
         * @method EdgeList.isVisible
         * Call [`isVisible`](#Edge-isVisible) on each edge in the list, and returns the array of results.
         * @return {Array<boolean>}
         */
        isVisible(): boolean[];
        isExcluded(): any;
        setExcluded(value: any): any;
        setVisible(value: any): any;
        /**
         * @method EdgeList.toList
         * Returns itself.
         * @return {EdgeList}
         */
        toList(): EdgeList;
        /**
         * @method EdgeList.toArray
         * Returns an array of edges from the EdgeList.
         * @return {Array<Edge>}
         */
        toArray(): Edge[];
        clone(): any;
        /**
         * @method EdgeList.getId
         * Returns the id of each edge.
         * @returns {Array<EdgeId>}
         */
        getId(): EdgeId[];
        /**
         * @method EdgeList.getSource
         * Returns the list of source nodes of the edges
         * @return {NodeList}
         */
        getSource(): NodeList;
        /**
         * @method EdgeList.getTarget
         * Returns the list of target nodes of the edges
         * @return {NodeList}
         */
        getTarget(): NodeList;
        /**
         * @method EdgeList.getExtremities
         * Returns a `NodeList` containing the sources and targets of the edges. Duplicate nodes are not removed.
         * @return {NodeList}
         */
        getExtremities(): NodeList;
        /**
         * @method EdgeList.get
         * Returns the edge at the specified index.
         * @param {number} index
         * @return {Edge}
         */
        get(index: number): Edge;
        /**
         * @method EdgeList.forEach
         * @param {function(edge: Edge, index: number)} callback
         */
        forEach(callback: (edge: Edge, index: number) => void): void;
        /**
         * @method EdgeList.map
         * @param {function(edge: Edge, index: number): any} callback
         * @return {Array<any>}
         */
        map(callback: (edge: Edge, index: number) => any): any[];
        /**
         * @method EdgeList.filter
         * @param {function(edge: Edge, index: number): boolean} callback
         * @return {EdgeList}
         */
        filter(callback: (edge: Edge, index: number) => boolean): EdgeList;
        /**
         * @method EdgeList.reduce
         * @param {function(accumulator: any, currentValue: Edge, index: number): any} callback
         * @param {any} initialValue
         * @return {any}
         */
        reduce(callback: (accumulator: any, currentValue: Edge, index: number) => any, initialValue: any): any;
        /**
         * @method EdgeList.concat
         * @param {EdgeList} edges
         * @return {EdgeList}
         */
        concat(edges: EdgeList): EdgeList;
        /**
         * @method EdgeList.dedupe
         * Returns a new EdgeList which does not contain any duplicate edge.
         * @return {EdgeList}
         */
        dedupe(): EdgeList;
        partition(callback: any): any;
        /**
         * @method EdgeList.slice
         * Returns a new EdgeList which contains only the edges from index `start` to `end` (excluding `end`).
         * @param {number} [start]
         * @param {number} [end]
         * @return {EdgeList}
         */
        slice(start?: number, end?: number): EdgeList;
        indexOf(edge: any): number;
        /**
         * @method EdgeList.includes
         * Indicates if the `EdgeList` contains the specified edge.
         * @param {Edge} edge
         * @return {boolean}
         */
        includes(edge: Edge): boolean;
        sort(f: any): any;
        /**
         * @method EdgeList.inverse
         * Returns a new EdgeList containing all the visible edges that are not in the list.
         * @return {EdgeList}
         */
        inverse(): EdgeList;
        /**
         * @method EdgeList.toJSON
         * Runs `toJSON` on all the edges in the list and returns the list of objects.
         * @param {object} [options]
         * @param {Array<PropertyPath>|"all"} [options.attributes="all"]
         * @param {function (data: any): any} [options.data]
         * @return {Array<RawEdge>}
         */
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): RawEdge[];
        /**
         * @method EdgeList.setSelected
         * @param {boolean|Array<boolean>} active whether to select or unselect the edges.
         */
        setSelected(active: boolean | boolean[]): void;
        /**
         * @method EdgeList.isSelected
         * Indicates if the edges are currently selected.
         * @return {Array<boolean>}
         */
        isSelected(): boolean[];
        /**
         * @method EdgeList.locate
         * Centers the view on the edges.
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.getSelectedEdges().locate();
         */
        locate(options?: LocateOptions): Promise<void>;
        /**
         * @method EdgeList.getBoundingBox
         * Returns the bounding box of the edges, in graph coordinates.
         * @param {boolean} [ignoreCurvature=false] Use it if you want to only take into
         *                                          account the edge sources and targets.
         * @return {BoundingBox}
         */
        getBoundingBox(ignoreCurvature?: boolean): BoundingBox;
        /**
         * @method EdgeList.setData
         * Set the specified data property of the edges. If no property is specified, update the whole data object.
         * @param {PropertyPath} [property] Path of the data property to update.
         * @param {Array<any>|function(edge: Edge): any} values If it's an array, each value is assigned to the corresponding edge,
         * meaning the array must have the same length as the EdgeList. If it's a function, it will be applied to each edge to
         * @return {EdgeList}
         * determine which value to assign.
         */
        setData(values: any[] | ((edge: Edge) => any)): EdgeList;
        setData(property: PropertyPath, values: any[] | ((edge: Edge) => any)): EdgeList;
        /**
         * @method EdgeList.fillData
         * Set the specified data property of the edges with the same value.
         * @param {PropertyPath|any} [property] Path of the data property to update. If no property is specified, update the whole data object.
         * @param {any} value Value that will be assigned to all the edges.
         * @return {EdgeList}
         */
        fillData(value: any): EdgeList;
        fillData(property: PropertyPath, value: any): EdgeList;
        /**
         * @method EdgeList.getData
         * Retrieve the specified data property. If no property is specified, retrieve the whole data object.
         * This method method returns the internal data object; modifying it could cause unexpected behavior.
         * @param {PropertyPath} [property]
         * @return {Array<any>}
         */
        getData(property?: PropertyPath): any[];
        /**
         * @method EdgeList.addClass
         * Add the specified class to the edges.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<EdgeList>}
         */
        addClass(className: string, options?: AttributeAnimationOptions): Promise<EdgeList>;
        /**
         * @method EdgeList.addClasses
         * Add the specified classes to the edges.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<EdgeList>}
         */
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<EdgeList>;
        /**
         * @method EdgeList.removeClass
         * Remove the specified class from the edges.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<EdgeList>}
         */
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<EdgeList>;
        /**
         * @method EdgeList.removeClasses
         * Remove the specified class from the edges.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<EdgeList>}
         */
        removeClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<EdgeList>;
        /**
         * @method Edge.hasClass
         * Indicates if the edges have the specified class.
         * @param {string} className
         * @return {Array<boolean>}
         */
        hasClass(className: string): boolean[];
        /**
         * @method EdgeList.getClassList
         * Returns the list of classes that each edge has.
         * @returns {Array<Array<string>>}
         */
        getClassList(): string[][];
        getAnimationInformation(): any;
        /**
         * @method EdgeList.getMetaEdge
         * Run `getMetaEdge` on each edge in the list and returns the array of results.
         * @returns {Array<Edge|null>}
         */
        getMetaEdge(): (Edge | null)[];
        /**
         * @method EdgeList.getSubEdges
         * Run `getSubEdges` on all the edges in the list and returns the array of results
         * @returns {Array<EdgeList|null>}
         */
        getSubEdges(): (EdgeList | null)[];
        /**
         * @method EdgeList.pulse
         * Highlights the edges. It's a shorthand for the case when you
         * want the elements pulse for `number * (interval - 1) + duration` milliseconds.
         * It will also update the pulse attributes of the items with the one provided
         * in the `.pulse()` call
         * @param {object} [options]
         * @param {number} [options.number=1]                             Number of pulses
         * @param {number} [options.duration=1000]                        Duration of a pulse (milliseconds)
         * @param {number} [options.interval=800]                         Interval between two pulses (milliseconds)
         * @param {Color|"inherit"} [options.startColor="rgb(0,0,0,0.6)"] Starting color of the pulse
         * @param {Color|"inherit"} [options.endColor="rgb(0,0,0,0.0)"]   Ending color of the pulse
         * @param {number} [options.width=10]                             Width of the pulse in pixels
         * @param {number} [options.startRatio=1]                         Where the pulse starts, relative to the edge siz (1 = at the edge's border)
         * @param {number} [options.endRatio=2]                           Where the pulse ends, relative to the edge siz (1 = at the edge's border)
         */
        pulse(options?: PulseOptions): void;
    }
}
declare module "modules/core/graph/node" {
    import { Item, ItemIndex, PulseOptions } from "modules/core/graph/item";
    import Ogma from "src/ogma";
    import { NodeAttributesValue, AttributeAnimationOptions, AdjacencyOptions, EdgeDirection, NodeId, RawNode, Point, Filter } from "types/utilities";
    import { GeoCoordinate } from "api/geo";
    import EdgeList from "modules/core/graph/edgeList";
    import NodeList from "modules/core/graph/nodeList";
    import { EdgeDirectionObject } from "modules/core/graph/edge";
    import { PropertyPath } from "api/data";
    import { LocateOptions } from "api/view";
    import BoundingBox from "utils/boundingBox";
    import { Transformation } from "modules/transformations/transformation";
    import { NodeAttributes } from "types/nodeAttributes";
    export default class Node implements Item {
        readonly size = 1;
        readonly isNode = true;
        constructor(index: ItemIndex, ogma: Ogma);
        /**
         * @method Node.setAttributes
         * Set the individual attributes of the node.
         * @param {NodeAttributesValue} attributes Attributes to update
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Node>}
         * @example
         * node.setAttributes({
         *   x: 100,
         *   y: 50,
         *   color: 'blue',
         *   radius: 15
         * }, {
         *   duration: 500
         * });
         */
        setAttributes(attributes: NodeAttributesValue, options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.setAttribute
         * Set the specified attribute of the node.
         * @param {PropertyPath} attribute
         * @param {any} value
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Node>}
         * @example
         * // Change the color of the node
         * node.setAttribute('color', 'blue');
         *
         * // Change the scale of the top left badge
         * // The two lines do the same thing
         * node.setAttribute('badges.topLeft.scale', 0.5);
         * node.setAttribute(['badges', 'topLeft', 'scale'], 0.5);
         */
        setAttribute(attribute: PropertyPath, value: any, options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.resetAttributes
         * Remove all attributes that have been applied through `setAttributes`. Original attributes or attributes applied by  the rules are not affected.
         * @param {Array<PropertyPath>} [attributeNames] List of attributes to clear. If no attribute is specified, clear all  of them.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<Node>}
         * @example
         * node.setAttributes({color: 'blue'});
         * node.resetAttributes();
         */
        resetAttributes(attributeNames?: PropertyPath[], options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.getAttributes
         * Returns an object containing the specified attributes for the node.
         * @param {Array<PropertyPath>} [attributeNames] List of attributes to include in the object. If not specified,  includes all the node attributes.
         * @return {NodeAttributes}
         * @example
         * node.setAttributes({x: 50, y: 100, color: 'blue'});
         * console.log(node.getAttributes(['x', 'y', 'color'])); // {x: 50, y: 100, color: 'blue'}
         */
        getAttributes(attributeNames?: PropertyPath[]): Partial<Required<NodeAttributes>>;
        /**
         * @method Node.getAttribute
         * Returns the value of the specified attribute for the node.
         * @param {PropertyPath} attributeName Attribute to retrieve.
         * @return {any}
         */
        getAttribute(attributeName: PropertyPath): any;
        /**
         * @method Node.getPosition
         * Retrieve the position of the node. This is strictly equivalent to `node.getAttributes(['x', 'y'])`.
         * @return {{x: number, y: number}}
         */
        getPosition(): Point;
        getPositionOnScreen(): Point;
        isInScreen(): boolean;
        replaceOriginalAttributes(attributes: any, excluded: any): void;
        getPreviousAttributes(names: any): any;
        /**
         * @method Node.isInView
         * Indicates if the node is visible in the current view.
         * @param {object} [options]
         * @param {number} [options.margin=0] Tolerance in pixels.
         * @returns {boolean}
         */
        isInView(options?: {
            margin?: number;
        }): boolean;
        /**
         * @method Node.getAdjacentNodes
         * Returns the list of adjacent nodes of the node.
         * @param {AdjacencyOptions} [options]
         * @return {NodeList}
         */
        getAdjacentNodes(options?: AdjacencyOptions): NodeList;
        /**
         * @method Node.getAdjacentEdges
         * Returns the list of adjacent edges of the node.
         * @param {AdjacencyOptions} [options]
         * @return {EdgeList}
         */
        getAdjacentEdges(options?: AdjacencyOptions): EdgeList;
        /**
         * @method Node.getDegree
         * Retrieve the number of neighbors of the node.
         * @param {object|EdgeDirection} [options]
         * @param {EdgeDirection} [options.direction="both"] Direction of the edges to follow.
         * @param {Filter} [options.filter="visible"] Indicates which edges to take into account
         * @return {number}
         */
        getDegree(options?: EdgeDirectionObject | EdgeDirection): number;
        fastGetAdjacentElements(): any;
        /**
         * Returns weakly connected component to which the node belongs
         * @method  Node.getConnectedComponent
         * @param {object} [options]
         * @param {Filter} [options.filter='visible']
         * @param {boolean} [options.returnIds=false] Return node ids instead of Nodes
         * @return {NodeList}
         *
         * @example
         * // detect whether the nodes belong to the same component
         * var node1 = ogma.getNode('1');
         * var node2 = ogma.getNode('2');
         * var sameSubGraph = node1.getConnectedComponent().includes(node2);
         */
        getConnectedComponent(options?: {
            filter?: Filter;
            returnIds?: boolean;
        }): NodeList;
        /**
         * @method Node.isVisible
         * Indicates if the node is visible. A node is not visible if it has been filtered out, or if it is used in a
         * transformation.
         * /!\ A node with an opacity of 0 is considered visible!
         * @return {boolean}
         */
        isVisible(): boolean;
        isExcluded(): any;
        setExcluded(value: any): any;
        setVisible(value: any): any;
        /**
         * @method Node.toList
         * Returns a new NodeList that contains only the node.
         * @return {NodeList}
         */
        toList(): NodeList;
        /**
         * @method Node.getId
         * Returns the id of the node.
         * @returns {NodeId}
         */
        getId(): NodeId;
        slice(): NodeList;
        /**
         * @method Node.toJSON
         * Returns an object containing the id, attributes and data of the node.
         * @param {object} [options]
         * @param {Array<PropertyPath>|"all"} [options.attributes="all"] List of attributes to retrieve. By default, retrieve all attributes.
         * @param {function (data: any): any} [options.data] Function that takes the node's data in input and return
         * the data to retrieve. By default return the whole object.
         * @return {RawNode}
         * @example
         * // Simple case: serialize a node as JSON
         * var toSerialize = node.toJSON();
         * var serialized = JSON.stringify(toSerialize);
         *
         * // Since the `toJSON()` method doesn't take any argument in this example, it's also possible
         * // to not call it explicitly:
         * var serialized = JSON.stringify(node);
         * @example
         * // Only serialize a few attributes and the `customerInfo` data property
         * var toSerialize = node.toJSON({
         *   attributes: ['color', 'radius', 'text.content', 'text.font'],
         *   data: function (data) {
         *     return data.customerInfo;
         *   }
         * });
         */
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): RawNode;
        get(index: any): this;
        /**
         * @method Node.setSelected
         * Add or remove the node to/from the selection.
         * @param {boolean} active whether to select or unselect the node.
         * @example
         * ogma.getNode('n0').setSelected(true);
         */
        setSelected(active: boolean): void;
        /**
         * @method Node.isSelected
         * Indicates if the node is currently selected.
         * @return {boolean}
         * @example
         * console.log(ogma.getNode('n0').isSelected());
         */
        isSelected(): boolean;
        /**
         * @method Node.locate
         * Centers the view on the node.
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         * @example
         * ogma.getNode('n0').locate();
         */
        locate(options?: LocateOptions): Promise<void>;
        /**
         * @method Node.getBoundingBox
         * Returns the bounding box of the node, in graph coordinates.
         * @return {BoundingBox}
         */
        getBoundingBox(): BoundingBox;
        /**
         * @method Node.setData
         * Set the specified data property of the node. If no property is specified, update the whole data object.
         * @param {PropertyPath} [property]
         * @param {any|function(node: Node): any} value
         * @return {Node}
         * @example
         * // Simple case
         * ogma.getNode('n0').setData('propName', 'propValue');
         *
         * // Setting a nested property
         * ogma.getNode('n0').setData(['foo', 'bar'], 'value');
         */
        setData(value: any | ((node: Node) => any)): Node;
        setData(property: PropertyPath, value: any | ((node: Node) => any)): Node;
        /**
         * @method Node.getData
         * Retrieve the specified data property of the node. If no property is specified, retrieve the whole data object.
         * This method method returns the internal data object; modifying it could cause unexpected behavior.
         * @param {PropertyPath} [property]
         * @return {any}
         * @example
         * // Simple case
         * ogma.getNode('n0').getData('propName');
         *
         * // Accessing a nested property
         * ogma.getNode('n0').getData(['foo', 'bar']);
         */
        getData(property?: PropertyPath): any;
        /**
         * @method Node.addClass
         * Add the specified class to the node.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Node>}
         */
        addClass(className: string, options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.addClasses
         * Add the specified classes to the node.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Node>}
         */
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.removeClass
         * Remove the specified class from the node.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Node>}
         */
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.removeClasses
         * Remove the specified class from the node.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<Node>}
         */
        removeClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<Node>;
        /**
         * @method Node.hasClass
         * Indicates if the node has the specified class.
         * @param {string} className
         * @return {boolean}
         */
        hasClass(className: string): boolean;
        /**
         * @method Node.getClassList
         * Returns the list of classes that the node has.
         * @returns {Array<string>}
         */
        getClassList(): string[];
        /**
         * @method Node.getGeoCoordinates
         *
         * Returns node's geographical coordinate
         * @return {GeoCoordinate}
         *
         * @exmaple
         * var ogma = new Ogma({
         *   graph: {
         *     nodes: [{id: 0, data: { latitude: 5, longitude: 10}}]
         *   }
         * });
         * ogma.getNode(0).getGeoCoordinates(); // { latitude: 5, longitude: 10}
         */
        getGeoCoordinates(): GeoCoordinate;
        /**
         * @method Node.setGeoCoordinates
         *
         * Set geographical position of the node. Passing null will erase the
         * coordinates and remove the node from the visualisation in geo mode.
         * @param {GeoCoordinate|null} coords
         * @param {number} [duration]  Animation duration
         * @return {Promise<Node>}
         *
         * @example
         * var node = ogma.getNode('id');
         * node.setGeoCoodinates({ latitude: 5, longitude: 10 });
         * console.log(node.getGeoCoordinates()); // { latitude: 5, longitude: 10}
         */
        setGeoCoordinates(coords: GeoCoordinate | null, duration?: number): Promise<Node>;
        getAnimationInformation(): any;
        /**
         * @method Node.isVirtual
         * Indicates if the node was created by a transformation (`true`) or not (`false`).
         * @returns {boolean}
         */
        isVirtual(): boolean;
        /**
         * @method Node.getTransformation
         * Returns the transformation that created the node, if it is virtual. Otherwise returns `null`.
         * @returns {Transformation|null}
         */
        getTransformation(): Transformation | null;
        /**
         * @method Node.getMetaNode
         * If the node is grouped inside a meta-node, returns this meta-node. Otherwise, returns null.
         * @returns {Node|null}
         */
        getMetaNode(): Node | null;
        /**
         * @method Node.getSubNodes
         * If the node is a meta-node (result of a grouping), returns the list of nodes that are part of the group
         * it represents. If it's not a meta-node, returns `null`.
         * @returns {NodeList|null}
         */
        getSubNodes(): NodeList | null;
        /**
         * @method Node.pulse
         * Highlights the node. It's a shorthand for the case when you
         * want the elements pulse for `number * (interval - 1) + duration` milliseconds.
         * It will also update the pulse attributes of the items with the one provided
         * in the `.pulse()` call.
         *
         * @param {object} [options]
         * @param {number} [options.number=1]                             Number of pulses
         * @param {number} [options.duration=1000]                        Duration of a pulse (milliseconds)
         * @param {number} [options.interval=800]                         Interval between two pulses (milliseconds)
         * @param {Color|"inherit"} [options.startColor="rgb(0,0,0,0.6)"] Starting color of the pulse
         * @param {Color|"inherit"} [options.endColor="rgb(0,0,0,0.0)"]   Ending color of the pulse
         * @param {number} [options.width=50]                             Width of the pulse in pixels
         * @param {number} [options.startRatio=1]                         Where the pulse starts, relative to the node siz (1 = at the node's border)
         * @param {number} [options.endRatio=2]                           Where the pulse ends, relative to the node siz (1 = at the node's border)
         */
        pulse(options?: PulseOptions): void;
    }
}
declare module "types/textStyles" {
    import { PixelSize, TextContent, FontStyle, Color, TextAlign, AttributeNestedValue } from "types/utilities";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    export interface NodeTextStyle {
        content?: TextContent;
        font?: string;
        color?: Color | 'inherit';
        size?: PixelSize;
        scale?: number;
        scaling?: boolean;
        style?: FontStyle;
        align?: TextAlign;
        margin?: PixelSize;
        padding?: PixelSize;
        maxLineLength?: number;
        backgroundColor?: Color | 'inherit' | null;
        minVisibleSize?: number;
        backgroundArrowBaseSize?: PixelSize;
        backgroundMargin?: PixelSize;
        tip?: boolean;
        position?: 'right' | 'left' | 'top' | 'bottom' | 'center';
        threshold?: number;
        secondary?: AttributeNestedValue<SecondaryNodeTextStyle, Node>;
    }
    export type NodeTextStyleValue = AttributeNestedValue<NodeTextStyle, Node>;
    export interface SecondaryNodeTextStyle {
        content?: TextContent;
        font?: string;
        color?: Color | 'inherit';
        size?: PixelSize;
        scale?: number;
        style?: FontStyle;
        align?: TextAlign;
        margin?: PixelSize;
        padding?: PixelSize;
        backgroundColor?: Color | 'inherit' | null;
        minVisibleSize?: number;
        backgroundArrowBaseSize?: PixelSize;
        backgroundMargin?: PixelSize;
    }
    export interface EdgeTextStyle {
        content?: TextContent;
        font?: string;
        color?: Color;
        size?: PixelSize;
        scale?: number;
        scaling?: boolean;
        style?: FontStyle;
        align?: TextAlign;
        backgroundColor?: Color | 'inherit';
        margin?: PixelSize;
        padding?: PixelSize;
        minVisibleSize?: PixelSize;
        maxLineLength?: number;
        adjustAngle?: boolean;
        threshold?: number;
        secondary?: AttributeNestedValue<SecondaryEdgeTextStyle, Edge>;
    }
    export interface SecondaryEdgeTextStyle {
        content?: TextContent;
        font?: string;
        color?: Color;
        size?: PixelSize;
        scale?: number;
        style?: FontStyle;
        align?: TextAlign;
        backgroundColor?: Color | 'inherit';
        margin?: PixelSize;
        padding?: PixelSize;
        minVisibleSize?: PixelSize;
    }
    export type EdgeTextStyleValue = AttributeNestedValue<EdgeTextStyle, Edge>;
}
declare module "types/badge" {
    import { Color, PixelSize, TextContent, FontStyle, ScalingMethod } from "types/utilities";
    import Node from "modules/core/graph/node";
    export type BadgeImage = string | {
        url?: string | ((node: Node) => string);
        scale?: number | ((node: Node) => number);
    };
    /**
     * @public
     * @typedef {object} Badge
     * @property {Color} [color="white"]                                           Fill color of the badge.
     * @property {number} [scale=0.45]                                             Size of the badge relative to the node.
     * @property {number} [positionScale=1]                                        Center of the badge relative to the node size (1 = at the node's border)
     * @property {number} [minVisibleSize=12]                                      If the node diameter on screen is less than this value, the badge will not be displayed
     * @property {object|null|string} [image]                                      If not an object, alias to `image.url`
     * @property {null|string} [image.url=null]                                    URL of the image to display in the badge
     * @property {number} [image.scale=1]                                          Size of the image relative to the badge diameter
     * @property {object} [stroke]
     * @property {Color|"inherit"} [stroke.color="black"]                          Color of the badge stroke
     * @property {PixelSize} [stroke.width=2]                                      Width of the badge stroke
     * @property {ScalingMethod} [stroke.scalingMethod="fixed"]                    Indicates if the badge width should be multiplied by the zoom when the node is displayed.
     * @property {object|TextContent} [text]                                       If not an object, alias for `text.content`
     * @property {TextContent} [text.content=null]                                 Text to display in the badge
     * @property {"inherit"|Color} [text.color="black"]                            Color of the badge text
     * @property {string} [text.font="Arial"]                                      Font to use for the badge text
     * @property {FontStyle} [text.style="normal"]                                   Style applied to the badge text
     * @property {number} [text.scale=0.5]                                         Size of the text relative to the badge diameter
     *
     * @deprecated
     * @property {number} [threshold] Alias for `minVisibleSize`
     */
    export interface Badge {
        color?: Color | ((node: Node) => Color);
        scale?: number | ((node: Node) => number);
        positionScale?: number | ((node: Node) => number);
        minVisibleSize?: number | ((node: Node) => number);
        threshold?: number | ((node: Node) => number);
        image?: BadgeImage | ((node: Node) => BadgeImage);
        stroke?: {
            color?: Color | 'inherit' | ((node: Node) => Color | 'inherit');
            width?: PixelSize | ((node: Node) => PixelSize);
            scalingMethod?: ScalingMethod | ((node: Node) => ScalingMethod);
        };
        text?: {
            content: TextContent | ((node: Node) => TextContent);
            color?: Color | 'inherit' | ((node: Node) => Color);
            font?: string | ((node: Node) => string);
            style?: FontStyle | ((node: Node) => FontStyle);
            scale?: number | ((node: Node) => number);
        } | TextContent | ((node: Node) => TextContent);
    }
}
declare module "types/nodeAttributes" {
    import { PixelSize, ScalingMethod, TextContent, FontStyle, Color, OpacityValue, LayerValue } from "types/utilities";
    import { NodeTextStyle } from "types/textStyles";
    import { Badge } from "types/badge";
    /**
     * @public
     * @typedef {"circle"|"cross"|"diamond"|"pentagon"|"square"|"star"|"equilateral"} NodeShape
     */
    export type NodeShape = 'circle' | 'cross' | 'diamond' | 'pentagon' | 'square' | 'star' | 'equilateral';
    interface Stroke {
        width?: PixelSize;
        scalingMethod?: ScalingMethod;
        color?: Color | 'inherit';
        minVisibleSize?: number;
        threshold?: number;
    }
    /**
     * @public
     * @typedef {object} NodeAttributes
     *
     * @property {number} [x=0]                                                    X coordinate of the node (graph space)
     * @property {number} [y=0]                                                    Y coordinate of the node (graph space)
     * @property {OpacityValue} [opacity=1]                                        Opacity of the node.
     * @property {PixelSize} [radius=5]                                            Indicates the radius of the node (graph size)
     * @property {ScalingMethod} [scalingMethod="scaled"]                          Indicates if the radius should be multiplied by the zoom when the node is displayed.
     * @property {Color|Array<Color>} [color="grey"]                               Color of the node
     * @property {NodeShape} [shape="circle"]                                      Shape of the node
     * @property {LayerValue} [layer=0]                                            Z-index of the node. Integer value between 1 and 3.
     * @property {boolean} [detectable=true]                                       Indicates if the node is detectable by the mouse.
     * @property {boolean} [draggable=true]                                        Indicates if the node is draggable by the user
     * @property {boolean} [layoutable=true]                                       Indicates if the node movable by the layout algorithm
     *                                                                             Some of the layouts (ForceLink) would take the non-movable nodes
     *                                                                             into account by making other nodes avoid them, others
     *                                                                             would just ignore them in calculations.
     *
     * @property {object|Color|"inherit"} [innerStroke]                            If not an object, alias for `innerStroke.color`
     * @property {PixelSize} [innerStroke.width=2]                                 Width of the node's inner stroke
     * @property {ScalingMethod} [innerStroke.scalingMethod="fixed"]               Indicates if the inner stroke width should be multiplied by the zoom when the node is displayed.
     * @property {Color|"inherit"} [innerStroke.color="white"]                     Color of the node's inner stroke
     * @property {number} [innerStroke.minVisibleSize=12]                           If the node diameter on screen is less than this value, the inner stroke will not be shown
     *
     * @property {object|Color|"inherit"} [outerStroke]                            If not an object, alias for `outerStroke.color`
     * @property {PixelSize} [outerStroke.width=5]                                 Width of the node's outer stroke
     * @property {ScalingMethod} [outerStroke.scalingMethod="fixed"]               Indicates if the outer stroke width should be multiplied by the zoom when the node is displayed.
     * @property {Color|"inherit"} [outerStroke.color=null]                        Color of the node's outer stroke
     * @property {number} [outerStroke.minVisibleSize=0]                           If the node diameter on screen is less than this value, the outer stroke will not be shown
     *
     * @property {object|Color|null} [halo]                                        If not an object, alias for `halo.color`
     * @property {Color} [halo.color=null]                                         Color of the halo
     * @property {PixelSize} [halo.width=50]                                       Width of the halo, in pixels
     * @property {ScalingMethod} [halo.scalingMethod="fixed"]                      Indicates if the halo width should be multiplied by the zoom when the node is displayed.
     * @property {Color} [halo.strokeColor=null]                                   Color of the stroke of the halo
     * @property {PixelSize} [halo.strokeWidth=1]                                  Width of the stroke of the halo
     * @property {boolean} [halo.hideNonAdjacentEdges=false]                       If true, the halo hides edges which don't have at least one extremity with `halo.hideNonAdjacentEdges` to `true`.
     *
     * @property {object|null} [pulse]
     * @property {boolean} [pulse.enabled=false]                                   If true, shows animated pulse around the node.
     * @property {number} [pulse.duration=1000]                                    Lifespan of one pulse ripple (milliseconds).
     * @property {number} [pulse.interval=800]                                     Interval between two pulses (milliseconds).
     * @property {Color}  [pulse.startColor="rgba(0, 0, 0, 0.6)"]                  Starting color of the pulse
     * @property {Color}  [pulse.endColor="rgba(0, 0, 0, 0)"]                      End color of the pulse
     * @property {number} [pulse.width=50]                                         Width of the pulse in pixels
     * @property {number} [pulse.startRatio=1]                                     Where the pulse starts, relative to the node size (1 = at the node's border)
     * @property {number} [pulse.endRatio=2]                                       Where the pulse ends, relative to the node size (2 = 2x size of the node)
     *
     * @property {object|TextContent} [icon]                                       If not an object, alias for `icon.content`
     * @property {TextContent} [icon.content]                                      Text to display inside the icon
     * @property {string} [icon.font="Arial"]                                      Font used to display the icon text
     * @property {Color} [icon.color="black"]                                      Color used to display the icon text
     * @property {number} [icon.scale=0.7]                                         Text size relative to the node diameter
     * @property {FontStyle} [icon.style="normal"]                                   Style applied to the icon.
     * @property {number} [icon.minVisibleSize=12]                                 If the node diameter on screen is less than this value, the icon will not be shown
     *
     * @property {object|string|null} [image]                                      If not an object, alias for `image.url`
     * @property {string|null} [image.url=null]                                    URL of the image to display
     * @property {number} [image.scale=1]                                          Size of the image relative to the node diameter
     * @property {boolean} [image.fit=true]                                        Indicates if the image should be rescaled to fit the node
     * @property {boolean} [image.tile=false]                                      If the image is smaller than the node, indicates if the image should be duplicated to fill the node. If true, `fit` will be considered to be `false`.
     * @property {number} [image.minVisibleSize=12]                                If the node diameter on screen is less than this value, the image will not be shown
     *
     * @property {object|boolean} [outline]                                        If not an object, alias for `outline.enabled`
     * @property {boolean} [outline.enabled=false]                                 Indicates if the outline should be visible
     * @property {Color} [outline.color="rgba(0, 0, 0, 0.36)"]                     Color of the outline
     * @property {number} [outline.minVisibleSize=12]                              If the node diameter on screen is less than this value, the outline will ne be shown
     *
     * @property {object} [badges]
     * @property {Badge} [badges.topLeft]
     * @property {Badge} [badges.topRight]
     * @property {Badge} [badges.bottomLeft]
     * @property {Badge} [badges.bottomRight]
     *
     * @property {object|TextContent} [text]                                       If not an object, alias for `text.content`
     * @property {TextContent} [text.content=null]                                 Text to display
     * @property {string} [text.font="Arial"]                                      Font used to display the text
     * @property {Color|"inherit"} [text.color="black"]                            Color of the text
     * @property {PixelSize} [text.size=12]                                        Text size (in pixels)
     * @property {number} [text.scale=0.1]                                         Text size relative to the node diameter
     * @property {boolean} [text.scaling=false]                                    Indicates if the `size` property (false) or the `scale` property (true) must be used to compute the text size. Affects both primary and secondary text.
     * @property {FontStyle} [text.style="normal"]                                   Style applied to the text
     * @property {TextAlign} [text.align="center"]                                 Alignment of the text (for multi-line texts)
     * @property {PixelSize} [text.margin=10]                                      Additional space (in pixels) between the node and the text
     * @property {PixelSize} [text.padding=2]                                      Space between the text and its background's edge, in pixels
     * @property {Color|"inherit"|null} [text.backgroundColor=null]                Background color of the text
     * @property {boolean} [text.tip=true]                                         Indicates if the margin between the text and the background should be filled with a small arrow pointing towards the node
     * @property {"right"|"left"|"top"|"bottom"|"center"} [text.position="bottom"] Position of the text relative to the node
     * @property {number} [text.minVisibleSize=24]                                 If the node diameter on screen is less than this value, the text will not be shown
     * @property {number} [text.maxLineLength=0]                                   If > 1, lines that have more characters than this value will be split across multiple lines. Affects both primary and secondary texts.
     *
     * @property {object|TextContent} [text.secondary]                             If not an object, alias for `text.secondary.content`
     * @property {TextContent} [text.secondary.content=null]                       Secondary text content. The secondary text is always displayed below the node.
     * @property {string} [text.secondary.font="Arial"]                            Font used to display the secondary text
     * @property {Color|"inherit"} [text.secondary.color="black"]                  Color of the secondary text
     * @property {PixelSize} [text.secondary.size=10]                              Secondary text size (in pixels)
     * @property {number} [text.secondary.scale=0.08]                              Secondary text size (relative to the node diameter)
     * @property {FontStyle} [text.secondary.style="normal"]                         Secondary text style
     * @property {TextAlign} [text.secondary.align="center"]                       Alignment of the secondary text (for multi-line texts)
     * @property {PixelSize} [text.secondary.margin=2]                             Space (in pixels) on top of the secondary text.
     * @property {PixelSize} [text.secondary.padding=2]                            Space (in pixels) between the text and its background's edge
     * @property {Color|"inherit"|null} [text.secondary.backgroundColor=null]      Background color of the secondary text
     * @property {number} [text.secondary.minVisibleSize=24]                       If the node diameter on screen is less than this value, the secondary text will not be shown
     *
     * @deprecated
     * @property {boolean} [hidden]                                               Alias for `opacity` (`true` -> opacity = 0, `false` -> opacity = 1)
     * @property {boolean} [image.rescale]                                        Alias for `fit`
     * @property {boolean} [image.duplicate]                                      Alias for `duplicate`
     * @property {PixelSize} [halo.size]                                          Alias for `width`
     * @property {PixelSize} [text.backgroundArrowBaseSize]                       Alias for `margin`
     * @property {PixelSize} [text.backgroundMargin]                              Alias for `padding`
     * @property {PixelSize} [text.secondary.backgroundArrowBaseSize]             Alias for `margin`
     * @property {PixelSize} [text.secondary.backgroundMargin]                    Alias for `padding`
     * @property {number} [innerStroke.threshold]                                 Alias for `minVisibleSize`
     * @property {number} [outerStroke.threshold]                                 Alias for `minVisibleSize`
     * @property {number} [icon.threshold]                                        Alias for `minVisibleSize`
     * @property {number} [image.threshold]                                       Alias for `minVisibleSize`
     * @property {number} [text.threshold]                                        Alias for `minVisibleSize`
     */
    export interface NodeAttributes {
        x?: number;
        y?: number;
        opacity?: OpacityValue;
        radius?: PixelSize;
        scalingMethod?: ScalingMethod;
        color?: Color | Color[];
        shape?: NodeShape;
        layer?: LayerValue;
        detectable?: boolean;
        draggable?: boolean;
        layoutable?: boolean;
        innerStroke?: Stroke | Color | 'inherit';
        outerStroke?: Stroke | Color | 'inherit';
        halo?: Color | null | {
            color?: Color;
            width?: PixelSize;
            scalingMethod?: ScalingMethod;
            strokeColor?: Color;
            strokeWidth?: PixelSize;
            hideNonAdjacentEdges?: boolean;
            size?: PixelSize;
        };
        pulse?: {
            enabled?: boolean;
            duration?: number;
            interval?: number;
            startColor?: Color;
            endColor?: Color;
            width?: number;
            startRatio?: number;
            endRatio?: number;
        } | null;
        icon?: {
            content?: TextContent;
            font?: string;
            color?: Color;
            scale?: number;
            style?: FontStyle;
            minVisibleSize?: number;
            threshold?: number;
        } | TextContent;
        image?: {
            url?: string | null;
            scale?: number;
            fit?: boolean;
            tile?: boolean;
            minVisibleSize?: number;
            rescale?: boolean;
            duplicate?: boolean;
            threshold?: number;
        } | string | null;
        outline?: {
            enabled?: boolean;
            color?: Color;
            minVisibleSize?: number;
        } | boolean;
        badges?: {
            topLeft?: Badge;
            topRight?: Badge;
            bottomLeft?: Badge;
            bottomRight?: Badge;
        };
        text?: NodeTextStyle | TextContent;
        hidden?: boolean;
    }
}
declare module "types/utilities" {
    import { NodeAttributes } from "types/nodeAttributes";
    import { EdgeAttributes } from "types/edgeAttributes";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import EdgeList from "modules/core/graph/edgeList";
    import NodeList from "modules/core/graph/nodeList";
    import { PropertyPath } from "api/data";
    export interface Point {
        x: number;
        y: number;
    }
    export interface Size {
        width: number;
        height: number;
    }
    /**
     * @typedef {object} Padding
     * @property {number} top    Top padding (in pixels).
     * @property {number} bottom Bottom padding (in pixels).
     * @property {number} left   Left padding (in pixels).
     * @property {number} right  Right padding (in pixels).
     */
    export type Padding = number | {
        bottom?: number;
        left?: number;
        top?: number;
        right?: number;
    };
    export interface CameraPosition {
        x: number;
        y: number;
        zoom: number;
    }
    /**
     * @public
     * @typedef {string|number} NodeId
     */
    export type NodeId = string | number;
    /**
     * @public
     * @typedef {string|number} EdgeId
     */
    export type EdgeId = string | number;
    /**
     * Edge direction
     * @public
     * @typedef {"both"|"in"|"out"} EdgeDirection
     */
    export type EdgeDirection = 'both' | 'in' | 'out';
    /**
     * @public
     * @typedef {"visible"|"raw"|"all"} Filter Indicates which nodes and edges to take into account.
     * "visible" refers to visible element, "raw" refers to elements that are not the result of a transformation (the
     * "original" graph), and "all" refers to all elements, including the non-visible ones.
     */
    export type Filter = 'visible' | 'raw' | 'all';
    /**
     * @public
     * @typedef {object} RawNode
     * @property {NodeId} [id]
     * @property {NodeAttributes} [attributes]
     * @property {any} [data]
     */
    export interface RawNode {
        id?: NodeId;
        attributes?: NodeAttributes;
        data?: any;
    }
    /**
     * @public
     * @typedef {object} RawEdge
     * @property {EdgeId} [id]
     * @property {NodeId} source
     * @property {NodeId} target
     * @property {EdgeAttributes} [attributes]
     * @property {any} [data]
     */
    export interface RawEdge {
        id?: EdgeId;
        source: NodeId;
        target: NodeId;
        attributes?: EdgeAttributes;
        data?: any;
    }
    export type RawItem = RawNode | RawEdge;
    /**
     * @public
     * @typedef {object} RawGraph
     * @property {Array<RawNode>} nodes
     * @property {Array<RawEdge>} edges
     */
    export interface RawGraph {
        nodes: RawNode[];
        edges: RawEdge[];
    }
    /**
     *
     * @public
     * @typedef {Node|NodeList|NodeId|Array<Node|NodeId>} NodeCollection
     *
     *
     * @typedef {Edge|EdgeList|EdgeId|Array<Edge|EdgeId>} EdgeCollection
     *
     * @class Node
     * @property {boolean} isNode Read-only property that is always `true`.
     *
     * @class Edge
     * @property {boolean} isNode Read-only property that is always `false`.
     *
     * @class NodeList
     * @property {boolean} isNode Read-only property that is always `true`.
     * @property {number} size Read-only property that indicates the number of nodes in the list.
     *
     * @class EdgeList
     * @property {boolean} isNode Read-only property that is always `false`.
     * @property {number} size Read-only property that indicates the number of edges in the list.
     *
     */
    export type AttributeNestedValue<T, U> = Exclude<Extract<T, object>, Function> extends object ? ((item?: U) => Exclude<T, Function>) | {
        [K in keyof T]: AttributeNestedValue<T[K], U>;
    } : T | ((item?: U) => T | undefined);
    export type NodeAttributesValue = {
        [K in keyof NodeAttributes]: AttributeNestedValue<NodeAttributes[K], Node>;
    };
    export type EdgeAttributesValue = {
        [K in keyof EdgeAttributes]: AttributeNestedValue<EdgeAttributes[K], Edge>;
    };
    export type AdjacencyPolicy = 'union' | 'include-sources' | 'exclude-sources';
    export type NodeCollection = Node | NodeList | NodeId | (Node | NodeId)[];
    export type EdgeCollection = Edge | EdgeList | EdgeId | (Edge | EdgeId)[];
    /**
     * @public
     *
     * @typedef {object} AdjacencyOptions
     * @property {"both"|"in"|"out"} [options.direction="both"] Direction of the edges to follow.
     * @property {Filter} [options.filter="visible"] Indicates what kind of elements should be retrieved.
     * @property {"union"|"include-sources"|"exclude-sources"} [options.policy="union"]
     * If "include-sources", the source node(s) will be added to the result.
     * If "exclude-sources", the source node(s) will be removed from the result.
     * If "union", the result is not modified.
     * This parameter is ignored when retrieving adjacent edges.
     * @property {boolean} [options.bothExtremities=false] Relevant only for `getAdjacentEdges`. If `true`, only edges for
     * which both extremities are in the `NodeList` are retrieved.
     * @deprecated
     * @property {boolean} [options.includeSources]
     * If specified, overrides the `policy` parameter: `true` -> `"include-sources"`, `false` -> `"exclude-sources"`
     */
    export interface AdjacencyOptions {
        direction?: EdgeDirection;
        filter?: Filter;
        policy?: AdjacencyPolicy;
        bothExtremities?: boolean;
        includeSources?: boolean;
    }
    /**
     * @public
     * @typedef {"linear"|"quadraticIn"|"quadraticOut"|"quadraticInOut"|"cubicIn"|"cubicOut"|"cubicInOut"|function(x: number): number} EasingFunction
     */
    export type Easing = 'linear' | 'quadraticIn' | 'quadraticOut' | 'quadraticInOut' | 'cubicIn' | 'cubicOut' | 'cubicInOut';
    export type EasingFunction = Easing | ((x: number) => number);
    export type RendererType = 'webgl' | 'canvas' | 'svg' | null;
    /**
     * Indicates a renderer state. <br>
     * <code>"requested"</code> is fired right after Ogma is initialized or the `renderer`
     * option has been changed, and means that the renderer has not been initialized yet. <br>
     * <code>"ok"</code> indicates that the renderer has been initialized and runs properly. <br>
     * <code>"error"</code> indicates that an error has occurred that prevents the renderer from running.
     */
    export type RendererState = 'requested' | 'ok' | 'error';
    /**
     * A non-null value indicates that an error has occurred and provides information on that error. <br>
     * <code>"NO_WEBGL"</code> indicates that WebGL is not available, most likely a browser or GPU issue. <br>
     * <code>"NO_ANGLE_INSTANCED_ARRAYS</code>" indicates that the
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays">ANGLE_instanced_arrays</a>
     * WebGL extension is not available. Also most likely a browser or GPU issue. <br>
     * <code>"OTHER"</code> indicates an unexpected error, most likely due to a specific combination of browser/GPU/OS that was not
     * handled correctly by Ogma. If you happen to encounter this error code , please contact support@linkurio.us and
     * provide the error message along with the browser, operating system and graphics card used.
     */
    export type RendererErrorCode = 'NO_WEBGL' | 'NO_ANGLE_INSTANCED_ARRAYS' | 'OTHER' | null;
    /**
     * @public
     * @typedef {object|number} AttributeAnimationOptions If a number is specified, it specifies the `duration` property.
     * @param {number}  [duration=0]      Indicates the duration of the attribute transition, in milliseconds.
     * @param {Easing}  [easing="linear"] Indicates the animation easing
     */
    export type AttributeAnimationOptions = {
        duration: number;
        easing?: Easing;
    } | number;
    export type CrossOriginValue = 'anonymous' | 'use-credentials' | null;
    /**
     * @public
     * @typedef {number|string} PixelSize
     * Indicates a size in pixels. A string in the format `X%` (e.g "200%") can be specified instead of a number,
     * in which case it is treated as `X percent of the default value`. `X` should be parsable using `parseFloat`.
     */
    export type PixelSize = number | string;
    /**
     * @public
     * @typedef {null|string} Color CSS color name (e.g `"red"`), `"transparent"`, rgb(a) notation (e.g: `"rgb(128, 128, 128)"` or `"rgba(128, 128, 128, 0.2)"`), hexadecimal notation (e.g: `"#FFFFFF"`) or `null` (transparent).
     */
    export type Color = string | null;
    /**
     * @public
     * @typedef {string|number|null} TextContent
     */
    export type TextContent = string | number | null;
    /**
     * @public
     * @typedef {"normal"|"bold"|"italic"} FontStyle
     */
    export type FontStyle = 'none' | 'bold' | 'italic' | 'normal';
    /**
     * @public
     * @typedef {"left"|"center"} TextAlign
     */
    export type TextAlign = 'left' | 'center';
    /**
     * @public
     * @typedef {"scaled"|"fixed"} ScalingMethod
     */
    export type ScalingMethod = 'scaled' | 'fixed';
    /**
     * @public
     * @typedef {number} LayerValue Integer between -1 and 3 (included). By default elements are on the layer 0.
     * Selected elements are on the layer 2. Hovered elements are on the layer 3.
     *
     * @typedef {number} OpacityValue Value between 0 (transparent) and 1 (opaque) indicating the opacity of the node/edge.
     * Note that Ogma doesn't perform real opacity, but background blending: the lower the opacity value is, the more
     * the color of the node/edge is blended towards the background color, but it retains its original alpha value.
     * This has one important implication: when using a transparent background and an image is displayed behind Ogma,
     * it is necessary to set the RGB values to the background color that are close to the image, even if the color is
     * transparent. For example, assuming the image is mainly grey, you should do
     * <span style="background-color: lightgrey;">`ogma.setOptions({backgroundColor: "rgba(128, 128, 128, 0)"})`</span>
     * so the nodes/edges are nicely blended towards the image color. */
    export type LayerValue = number;
    export type OpacityValue = number;
    /**
     * @public
     * @typedef {null|function(node: Node): boolean} NodeSelector
     * Used to indicate if a style rule should be applied to a given node. `null` is equivalent to a function that always returns true.
     */
    export type NodeSelector = (node: Node) => boolean | null;
    /**
     * @public
     * @typedef {null|function(edge: Edge): boolean} EdgeSelector
     * Used to indicate if a style rule should be applied to a given edge. `null` is equivalent to a function that always returns true.
     */
    export type EdgeSelector = (edge: Edge) => boolean | null;
    /**
     * @public
     * @typedef {object|true} Dependency `true` indicates that the rule/class depends on the existence of the node(s)/edge(s), but not on their attributes
     * @property {"all"|Array<PropertyPath>} [attributes] List of attributes the rule/class depends on
     * @property {boolean} [data] Indicates if the result of the rule is based on the node/edge's data
     * @property {boolean} [selection] Indicates if the result of the rule changes depending on whether the node/edge is selected or not
     * @property {boolean} [hover] Indicates if the result of the rule changes depending on whether the node/edge is hovered or not
     */
    export type Dependency = true | {
        attributes?: 'all' | PropertyPath[];
        data?: boolean;
        selection?: boolean;
        hover?: boolean;
    };
    /**
     * @public
     * @typedef {object|null} NodeDependencies
     * If `null`, indicates that the node attributes defined by the rule/class does not depend on any attribute of any node/edge.
     * If unspecified, the `self`, `adjacentNodes` and `adjacentEdges` fields are treated as `{attributes: "all", data: true, selection: true, hover: false}`,
     * and the `allNodes` and `allEdges` fields are treated as `null`.
     * @property {Dependency} [self] Indicates that the rule/class for that node should be updated when the specified attributes of the node change
     * @property {Dependency} [adjacentNodes] Indicates that the rule/class for that node should be updated when the specified attributes of the node's adjacent nodes change
     * @property {Dependency} [adjacentEdges] Indicates that the rule/class for that node should be updated when the specified attributes of the node's adjacent edges change
     * @property {Dependency} [allNodes] Indicates that the rule/class for that node should be updated when the specified attributes of any node change
     * @property {Dependency} [allEdges] Indicates that the rule/class for that node should be updated when the specified attributes of any edge change
     */
    export interface NodeDependencies {
        self?: Dependency;
        adjacentNodes?: Dependency;
        adjacentEdges?: Dependency;
        allNodes?: Dependency;
        allEdges?: Dependency;
    }
    /**
     * @public
     * @typedef {object|null} EdgeDependencies
     * If `null`, indicates that the edge attributes defined by the rule/class does not depend on any attribute of any node/edge.
     * If unspecified, the `self`, `extremities` and `parallelEdges` fields are treated as `{attributes: "all", data: true, selection: true, hover: false}`,
     * and the `allNodes` and `allEdges` fields are treated as `null`.
     * @property {Dependency} [self] Indicates that the rule/class for that edge should be updated when the specified attributes of the edge change
     * @property {Dependency} [extremities] Indicates that the rule/class for that edge should be updated when the specified attributes of the edge's extremities change
     * @property {Dependency} [parallelEdges] Indicates that the rule/class for that edge should be updated when the specified attributes of the node's parallel edges change
     * @property {Dependency} [allNodes] Indicates that the rule/class for that edge should be updated when the specified attributes of any node change
     * @property {Dependency} [allEdges] Indicates that the rule/class for that edge should be updated when the specified attributes of any edge change
     */
    export interface EdgeDependencies {
        self?: Dependency;
        extremities?: Dependency;
        parallelEdges?: Dependency;
        allNodes?: Dependency;
        allEdges?: Dependency;
    }
    /**
     * @public
     * @typedef {object|null} NodeOutput
     * If unspecified, the assigned attributes are inferred to the best possible extent from the `NodeAttributesValue` value.
     * @property {"all"|Array<PropertyPath>} [attributes] List of node attributes assigned by the rule/class
     */
    export type NodeOutput = null | {
        attributes?: 'all' | PropertyPath[];
    };
    /**
     * @public
     * @typedef {object|null} EdgeOutput
     * If unspecified, the assigned attributes are inferred to the best possible extent from the `EdgeAttributesValue` value.
     * @property {"all"|Array<PropertyPath>} [attributes] List of edge attributes assigned by the rule/class
     */
    export type EdgeOutput = null | {
        attributes?: 'all' | PropertyPath[];
    };
}
declare module "modules/core/graph/item" {
    import { PropertyPath } from "api/data";
    import { RawNode, RawEdge, NodeId, EdgeId, Color } from "types/utilities";
    import { LocateOptions } from "api/view";
    import { NodeAttributes } from "types/nodeAttributes";
    import { EdgeAttributes } from "types/edgeAttributes";
    import { Transformation } from "modules/transformations/transformation";
    import { AttributeAnimationOptions, NodeAttributesValue, EdgeAttributesValue } from "types/utilities";
    import { ItemList } from "modules/core/graph/itemList";
    export type ItemId = NodeId | EdgeId;
    export type ItemAttributes = NodeAttributes | EdgeAttributes;
    export type ItemAttributesValue = NodeAttributesValue | EdgeAttributesValue;
    export type RawItem = RawNode | RawEdge;
    export type ItemIndex = number;
    /**
     * @param {object} [options]
     * @param {number} [options.number=1]                             Number of pulses
     * @param {number} [options.duration=1000]                        Duration of a pulse (milliseconds)
     * @param {number} [options.interval=800]                         Interval between two pulses (milliseconds)
     * @param {Color|"inherit"} [options.startColor="rgb(0,0,0,0.6)"] Starting color of the pulse
     * @param {Color|"inherit"} [options.endColor="rgb(0,0,0,0.0)"]   Ending color of the pulse
     * @param {number} [options.width=50]                             Width of the pulse in pixels
     * @param {number} [options.startRatio=1]                         Where the pulse starts, relative to the node siz (1 = at the node's border)
     * @param {number} [options.endRatio=2]                           Where the pulse ends, relative to the node siz (1 = at the node's border)
     */
    export interface PulseOptions {
        number?: number;
        duration?: number;
        interval?: number;
        startColor?: Color | 'inherit';
        endColor?: Color | 'inherit';
        width?: number;
        startRatio?: number;
        endRatio?: number;
    }
    export interface Item {
        readonly isNode: boolean;
        addClass(className: string, options?: AttributeAnimationOptions): Promise<Item>;
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<Item>;
        getAttribute(attributeName: PropertyPath): any;
        getAttributes(attributeNames?: PropertyPath[]): Partial<ItemAttributes>;
        getClassList(): string[];
        getData(property?: PropertyPath): any;
        getId(): ItemId;
        getTransformation(): Transformation | null;
        hasClass(className: string): boolean;
        isInView(options?: {
            margin?: number;
        }): void;
        isSelected(): boolean;
        isVirtual(): boolean;
        isVisible(): boolean;
        locate(options?: LocateOptions): Promise<void>;
        pulse(options?: {
            number?: number;
            duration?: number;
            interval?: number;
            startColor?: Color | 'inherit';
            endColor?: Color | 'inherit';
            width?: number;
            startRatio?: number;
            endRatio?: number;
        }): void;
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<Item>;
        removeClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<Item>;
        resetAttributes(attributeNames?: PropertyPath[], options?: AttributeAnimationOptions): Promise<Item>;
        setAttribute(attribute: PropertyPath, value: any, options?: AttributeAnimationOptions): Promise<Item>;
        setAttributes(attributes: ItemAttributesValue, options?: AttributeAnimationOptions): Promise<Item>;
        setData(property?: PropertyPath, value?: any | ((item: Item) => any)): Item;
        setSelected(active: boolean): void;
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): RawItem;
        toList(): ItemList;
    }
}
declare module "modules/core/graph/nodeList" {
    import Ogma from "src/ogma";
    import { PulseOptions } from "modules/core/graph/item";
    import { EdgeDirectionObject } from "modules/core/graph/edge";
    import { PropertyPath } from "api/data";
    import { NodeId, NodeAttributesValue, RawNode, AdjacencyOptions, EdgeDirection, AttributeAnimationOptions, Point, Filter } from "types/utilities";
    import { LocateOptions } from "api/view";
    import { NodeAttributes } from "types/nodeAttributes";
    import { ItemList, ItemListIndexes } from "modules/core/graph/itemList";
    import EdgeList from "modules/core/graph/edgeList";
    import { GeoCoordinate } from "api/geo";
    import Node from "modules/core/graph/node";
    import BoundingBox from "utils/boundingBox";
    export default class NodeList implements ItemList {
        readonly isNode = true;
        constructor(indexes: ItemListIndexes, ogma: Ogma);
        readonly size: number;
        /**
         * @method NodeList.setAttributes
         * Set the individual attributes of all the nodes in the list.
         * @param {NodeAttributesValue|Array<NodeAttributesValue>} attributes If a single attribute is specified, it is applied to all nodes.
         * If an array is specified, each index of the array is assigned to the corresponding node.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<NodeList>}
         */
        setAttributes(attributes: NodeAttributesValue | NodeAttributesValue[], options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.setAttribute
         * Set the specified attribute of all the nodes in the list.
         * @param {PropertyPath} attribute
         * @param {any|Array<any>} values If it is an array, the values will be spread across the nodes of the list.
         * Otherwise the value will be assigned to all nodes.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<NodeList>}
         * @example
         * var nodes = ogma.getNodes([0, 1]);
         *
         * // Assign the same radius to the two nodes
         * nodes.setAttribute('radius', 7);
         *
         * // Assign different texts to the two nodes
         * nodes.setAttribute('text', ['Node 0', 'Node 1']);
         */
        setAttribute(attribute: PropertyPath, values: any | any[], options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.getAttributes
         * Returns an array of objects containing the specified attributes for each node.
         * @param {Array<PropertyPath>} [attributes] List of attributes to include in the object. If not specified, includes all the node attributes.
         * @return {NodeAttributes[]}
         */
        getAttributes(attributes?: PropertyPath[]): NodeAttributes[];
        /**
         * @method NodeList.getAttribute
         * Returns an array containing the value of the specified attribute for each node.
         * @param {PropertyPath} attributeName Attribute to retrieve.
         * @return {Array<any>}
         */
        getAttribute(attributeName: PropertyPath): any[];
        /**
         * @method NodeList.resetAttributes
         * Remove all attributes that have been applied through `setAttributes` of all the nodes in the list.
         * Original attributes or attributes applied by the rules are not affected.
         * @param {Array<PropertyPath>} [attributes] List of attributes to clear. If no attribute is specified, clear all of them.
         * @param {AttributeAnimationOptions} [options]
         * @return {Promise<NodeList>}
         */
        resetAttributes(attributes?: PropertyPath[], options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.getPosition
         * Retrieve the position of each node in the list. This is strictly equivalent to `nodeList.getAttributes(['x', 'y'])`.
         * @return {Array<{x: number, y: number}>}
         */
        getPosition(): Pick<NodeAttributes, keyof Point>[];
        getPositionOnScreen(): Point[];
        replaceOriginalAttributes(attributes: any, excluded: any): void;
        /**
         * @method NodeList.getAdjacentNodes
         * Returns the list of adjacent nodes of the nodes.
         * @param {AdjacencyOptions} [options]
         * @return {NodeList}
         */
        getAdjacentNodes(options?: AdjacencyOptions): NodeList;
        /**
         * @method NodeList.getAdjacentEdges
         * Returns the list of adjacent edges of the nodes.
         * @param {AdjacencyOptions} [options]
         * @return {EdgeList}
         */
        getAdjacentEdges(options?: AdjacencyOptions): EdgeList;
        /**
         * @method NodeList.getDegree
         * Runs `getDegree` on each node in the list and returns the array of results.
         */
        getDegree(options?: EdgeDirectionObject | EdgeDirection): any;
        /**
         * @method NodeList.getConnectedComponents
         * Returns weakly connected components of the list of nodes.
         * @param {object} [options]
         * @param {Filter} [options.filter='visible']
         * @param {boolean} [options.returnIds=false] Return node ids instead of Nodes
         * @return {Array<NodeList>}
         */
        getConnectedComponents(options: {
            filter?: Filter;
            returnIds?: boolean;
        }): NodeList[];
        fastGetAdjacentElements(): any;
        /**
         * @method NodeList.isVisible
         * Call [`isVisible`](#Node-isVisible) on each node in the list, and returns the array of results.
         * @return {Array<boolean>}
         */
        isVisible(): boolean[];
        isExcluded(): any;
        setExcluded(value: any): any;
        setVisible(value: any): any;
        /**
         * @method NodeList.toList
         * Returns itself.
         * @return {NodeList}
         */
        toList(): NodeList;
        /**
         * @method NodeList.toArray
         * Returns an array of nodes from the NodeList.
         * @return {Array<Node>}
         */
        toArray(): Node[];
        clone(): any;
        /**
         * @method NodeList.getId
         * Returns the id of each node.
         * @returns {Array<NodeId>}
         */
        getId(): NodeId[];
        /**
         * @method NodeList.get
         * Returns the node at the specified index.
         * @param {number} index
         * @return {Node}
         */
        get(index: number): Node;
        /**
         * @method NodeList.forEach
         * @param {function(node: Node, index: number)} callback
         */
        forEach(callback: (node: Node, index: number) => void): void;
        /**
         * @method NodeList.map
         * @param {function(node: Node, index: number): any} callback
         * @return {Array<any>}
         */
        map(callback: (node: Node, index: number) => any): any[];
        /**
         * @method NodeList.filter
         * @param {function(node: Node, index: number): boolean} callback
         * @return {NodeList}
         */
        filter(callback: (node: Node, index: number) => boolean): NodeList;
        /**
         * @method NodeList.reduce
         * @param {function(accumulator: any, currentValue: Node, index: number): any} callback
         * @param {any} initialValue
         * @return {any}
         */
        reduce(callback: any, initialValue: any): any;
        /**
         * @method NodeList.concat
         * @param {NodeList} nodes
         * @return {NodeList}
         */
        concat(nodes: NodeList): NodeList;
        /**
         * @method NodeList.dedupe
         * Returns a new NodeList which does not contain any duplicate node.
         * @return {NodeList}
         */
        dedupe(): NodeList;
        /**
         * @method NodeList.slice
         * Returns a new NodeList which contains only the nodes from index `start` to `end` (excluding `end`).
         * @param {number} [start]
         * @param {number} [end]
         * @return {NodeList}
         */
        slice(start?: number, end?: number): NodeList;
        partition(callback: any): any;
        indexOf(node: any): number;
        /**
         * @method NodeList.includes
         * Indicates if the `NodeList` contains the specified node.
         * @param {Node} node
         * @return {boolean}
         */
        includes(node: Node): boolean;
        /**
         * @method NodeList.inverse
         * Returns a new NodeList containing all the visible nodes that are not in the list.
         * @return {NodeList}
         */
        inverse(): NodeList;
        sort(f: any): any;
        /**
         * @method NodeList.toJSON
         * Runs `toJSON` on all the nodes in the list and returns the list of objects.
         * @param {object} [options]
         * @param {Array<PropertyPath>|"all"} [options.attributes="all"]
         * @param {function (data: any): any} [options.data]
         * @return {Array<RawNode>}
         */
        toJSON(options?: {
            attributes?: PropertyPath[] | 'all';
            data?: (data: any) => any;
        }): RawNode[];
        /**
         * @method NodeList.setSelected
         * Add or remove the nodes from the selection.
         * @param {boolean|Array<boolean>} active whether to select or unselect the nodes.
         * @example
         * var nodes = ogma.getNodes(['n0', 'n1', 'm2']);
         *
         * // Select all the nodes
         * nodes.setSelected(true);
         *
         * // Select one of them, and unselect the other two
         * nodes.setSelected([true, false, false]);
         */
        setSelected(active: boolean | boolean[]): void;
        /**
         * @method NodeList.isSelected
         * Indicates for each node if it is selected.
         * @return {Array<boolean>}
         */
        isSelected(): boolean[];
        /**
         * @method NodeList.locate
         * Centers the view on the nodes.
         * @param {LocateOptions} [options]
         * @return {Promise<void>}
         *
         * @example
         * ogma.getSelectedNodes().locate();
         */
        locate(options?: LocateOptions): Promise<void>;
        /**
         * @method NodeList.getBoundingBox
         * Returns the bounding box of the nodes, in graph coordinates.
         * @return {BoundingBox}
         */
        getBoundingBox(): BoundingBox;
        /**
         * @method NodeList.setData
         * Set the specified data property of the nodes. If no property is specified, update the whole data object.
         * @param {PropertyPath} [property] Path of the data property to update.
         * @param {Array<any>|function(node: Node): any} values If it's an array, each value is assigned to the corresponding node,
         * meaning the array must have the same length as the NodeList. If it's a function, it will be applied to each node to
         * determine which value to assign.
         *
         * @return {NodeList}
         * @example
         * var nodes = ogma.getNodes(['n0', 'n1']);
         *
         * // Assigning data with a function
         * nodes.setData('aPlusB', function (node) {
         *   return node.getData('a') + node.getData('b');
         * });
         *
         * // Assigning data using an array
         * nodes.setData('foo', [23, 42]);
         */
        setData(values: any[] | ((node: Node) => any)): NodeList;
        setData(property: PropertyPath, values: any[] | ((node: Node) => any)): NodeList;
        /**
         * @method NodeList.fillData
         * Set the specified data property of the nodes with the same value.
         * @param {PropertyPath|any} [property] Path of the data property to update. If no property is specified, update the whole data object.
         * @param {any} value Value that will be assigned to all the nodes.
         * @return {NodeList}
         * @example
         * ogma.getNodes().fillData('propName', 'value');
         */
        fillData(value: any): NodeList;
        fillData(property: PropertyPath, value: any): NodeList;
        /**
         * @method NodeList.getData
         * Retrieve the specified data property. If no property is specified, retrieve the whole data object.
         * This method method returns the internal data object; modifying it could cause unexpected behavior.
         * @param {PropertyPath} [property]
         * @return {Array<any>}
         * @example
         * var nodes = ogma.getNodes(['n0', 'n1']);
         *
         * nodes.setData('foo', [42, 23]);
         *
         * console.log(nodes.getData('foo')); // Displays: "42,23"
         */
        getData(property?: PropertyPath): any[];
        /**
         * @method NodeList.addClass
         * Add the specified class to the nodes.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<NodeList>}
         */
        addClass(className: string, options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.addClasses
         * Add the specified classes to the nodes.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<NodeList>}
         */
        addClasses(classNames: string[], options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.removeClass
         * Remove the specified class from the nodes.
         * @param {string} className
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<NodeList>}
         */
        removeClass(className: string, options?: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method NodeList.removeClasses
         * Remove the specified class from the nodes.
         * @param {Array<string>} classNames
         * @param {AttributeAnimationOptions} [options]
         * @returns {Promise<NodeList>}
         */
        removeClasses(classNames: string[], options: AttributeAnimationOptions): Promise<NodeList>;
        /**
         * @method Node.hasClass
         * Indicates if the nodes have the specified class.
         * @param {string} className
         * @return {Array<boolean>}
         */
        hasClass(className: string): boolean[];
        /**
         * @method NodeList.getClassList
         * Returns the list of classes that each node has.
         * @returns {Array<Array<string>>}
         */
        getClassList(): string[][];
        /**
         * @method NodeList.getGeoCoordinates
         *
         * Returns geographical coordinates of all the nodes in the collection
         * @return {Array<GeoCoordinate>}
         *
         * @exmaple
         * var ogma = new Ogma({
         *   graph: {
         *     nodes: [
         *       {id: 0, data: { latitude: 5, longitude: 10}},
         *       {id: 1, data: { latitude: 10, longitude: 5}}
         *     ]
         *   }
         * });
         * console.log(ogma.getNodes().getGeoCoordinates());
         * // [
         * //   { latitude: 5, longitude: 10},
         * //   { latitude: 10, longitude: 5}
         * //  ]
         */
        getGeoCoordinates(): GeoCoordinate[];
        /**
         * @method NodeList.setGeoCoordinates
         *
         * Assign geographical coordinates to the nodes in collection
         * @param {Array<GeoCoordinate|null>|null} coordinates
         * @param {number} [duration]              Animation duration
         * @return {Promise<NodeList>}
         *
         * @example
         * ogma.getNodes().setGeoCoordinates([
         *   { latitude: 5, longitude: 10},
         *   { latitude: 10, longitude: 5}
         * ]); // will trigger a redraw, if geo mode is on
         */
        setGeoCoordinates(coordinates: (GeoCoordinate | null)[] | null, duration: number): Promise<NodeList>;
        getAnimationInformation(): any;
        /**
         * @method NodeList.getMetaNode
         * Run `getMetaNode` on each node in the list and returns the array of results.
         * @returns {Array<Node|null>}
         */
        getMetaNode(): (Node | null)[];
        /**
         * @method NodeList.getSubNodes
         * Run `getSubNodes` on all the nodes in the list and returns the array of results
         * @returns {Array<NodeList|null>}
         */
        getSubNodes(): (NodeList | null)[];
        /**
         * @method NodeList.pulse
         * Highlights the nodes with a pulse. It's a shorthand for the case when you
         * want the elements pulse for `number * (interval - 1) + duration` milliseconds.
         * It will also update the pulse attributes of the items with the one provided
         * in the `.pulse()` call.
         *
         *
         * @param {object} [options]
         * @param {number} [options.number=1]                             Number of pulses
         * @param {number} [options.duration=1000]                        Duration of a pulse (milliseconds)
         * @param {number} [options.interval=800]                         Interval between two pulses (milliseconds)
         * @param {Color|"inherit"} [options.startColor="rgb(0,0,0,0.6)"] Starting color of the pulse
         * @param {Color|"inherit"} [options.endColor="rgb(0,0,0,0.0)"]   Ending color of the pulse
         * @param {number} [options.width=50]                             Width of the pulse in pixels
         * @param {number} [options.startRatio=1]                         Where the pulse starts, relative to the node siz (1 = at the node's border)
         * @param {number} [options.endRatio=2]                           Where the pulse ends, relative to the node siz (1 = at the node's border)
         */
        pulse(options?: PulseOptions): void;
    }
}
declare module "api/data" {
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    /**
     * @public
     * @typedef {string|Array<string>} PropertyPath
     */
    export type PropertyPath = string | string[];
    export interface DataChange {
        property: PropertyPath;
        previousValues: any[];
        newValues: any[];
    }
    export interface NodesDataChange extends DataChange {
        nodes: NodeList;
    }
    export interface EdgesDataChange extends DataChange {
        edges: EdgeList;
    }
    export interface DataEvent {
        isNode: boolean;
    }
    export interface NodesDataEvent extends DataEvent {
        nodes: NodeList;
        changes: NodesDataChange[];
    }
    export interface EdgesDataEvent extends DataEvent {
        edges: EdgeList;
        changes: EdgesDataChange[];
    }
}




declare module "api/keyboard" {
    import Ogma from "src/ogma";
    /**
     * @public
     * @typedef {string} KeyName Lowercase letter (e.g `"a"`), digit (e.g `"3"`) or `"shift"|"ctrl"|"cmd"|"alt"|"space"|"enter"|"esc"|"del"|"backspace"`.
     * @typedef {number} KeyCode JavaScript key code.
     */
    export type ModifierKey = 'shift' | 'ctrl' | 'cmd' | 'alt' | 'space' | 'enter' | 'esc' | 'del' | 'backspace';
    export type KeyCode = number;
    export type KeyName = string | ModifierKey;
    const createKeyboardAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.keyboard.isKeyPressed
         * Indicates if the specified key is pressed.
         * @param {KeyName|KeyCode} key Key name or key code indicating the key to check.
         * @return {boolean}
         */
        isKeyPressed(key: string | number): boolean;
        /**
         * @method Ogma.keyboard.resetKeys
         * Resets the stored values for the keys that the user has pressed. Useful to
         * ensure that after a certain shortcut the next combination will be detected properly,
         * even if the user made a mistake. Also use it in the browsers which do not report loss of
         * focus when a dialog window is open.
         */
        resetKeys(): void;
    };
    export default class KeyboardAPI {
        keyboard: ReturnType<typeof createKeyboardAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "geometry/basics" {
    import { Point } from "types/utilities";
    import { SimpleBoundingBox } from "utils/boundingBox";
    /**
     * Axis-aligned bbox
     * @typedef {Array<number>} AABB
     */
    export type AABB = [number, number, number, number];
    export const defaultAABB: AABB;
    /** Oriented bounding box: x, y, w, h, angle */
    export type OBB = [number, number, number, number, number];
    /**
     * Rotate a point (px, py) around a rotation center (cx, cy) and give the new position.
     * @memberOf Geometry
     * @param {number} px
     * @param {number} py
     * @param {number} cx
     * @param {number} cy
     * @param {number} angle Angle of the rotation (in radians)
     * @param {object} [dest] If specified, modifies this object instead of allocating a new one.
     * @returns {{x: number, y: number}}
     */
    export function rotate(px: number, py: number, cx: number, cy: number, angle: number, dest?: Point): Point;
    /**
     * Move point by a distance and angle
     * @param  {Point} point
     * @param  {Number} angle
     * @param  {Number} [dist=0]
     * @param  {Point} [dest]
     * @return {Point}
     */
    export function move(point: Point, angle: number, dist?: number, dest?: Point): Point;
    /**
     * Compute the distance between two points (x1, y1) and (x2, y2).
     * @memberOf Geometry
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @returns {number} Distance between the two points.
     */
    export function distance(x1: number, y1: number, x2: number, y2: number): number;
    /**
     * Squared distance between the points - performance trick
     * for analytical usage
     *
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {number}
     */
    export function squaredDistance(x1: number, y1: number, x2: number, y2: number): number;
    export function radiansToDegrees(radians: number): number;
    export function degreesToRadians(degrees: number): number;
    export function extendBounds(bounds: SimpleBoundingBox, padding: number): SimpleBoundingBox;
}
declare module "geometry/bounds" {
    import { AABB } from "geometry/basics";
    import { Point } from "types/utilities";
    import { SimpleBoundingBox } from "utils/boundingBox";
    /**
     * Get bounds for a rotated axis aligned bounding box
     * @param {number} x0    left bottom X
     * @param {number} y0    left bottom Y
     * @param {number} w     Bounds width
     * @param {number} h     Bounds height
     * @param {number} angle Rotation angle
     * @param {number} [sin] Angle sinus. If not passed, will be calculated.
     * @param {number} [cos] Angle cosinus. If not passed, will be calculated.
     */
    export function getAABB(x0: number, y0: number, w: number, h: number, angle?: number, sin?: number, cos?: number, dest?: AABB): AABB;
    /**
     * Get points for a rotated axis aligned bounding box
     * @param {number} x0    left bottom X
     * @param {number} y0    left bottom Y
     * @param {number} w     Bounds width
     * @param {number} h     Bounds height
     * @param {number} angle Rotation angle
     */
    export function getOBBPoints(x0: number, y0: number, w: number, h: number, angle?: number): [Point, Point, Point, Point];
    /**
     * @param  {AABB} aabb
     * @param  {Number} angle
     * @param  {Number} dist
     * @param  {Array}  dest
     * @return {AABB}
     */
    export function moveAABB(aabb: AABB, angle?: number, dist?: number, dest?: AABB): AABB;
    export function padBounds(bounds: SimpleBoundingBox, padding: number): SimpleBoundingBox;
    /**
     * Bounds overlap
     * @param  {Array<number>} a
     * @param  {Array<number>} b
     * @return {boolean}
     */
    export function overlapsAABB(a: AABB, b: AABB): boolean;
    export function intersects(ax1: number, ay1: number, ax2: number, ay2: number, bx1: number, by1: number, bx2: number, by2: number): boolean;
    export function overlaps(ax1: number, ay1: number, ax2: number, ay2: number, bx1: number, by1: number, bx2: number, by2: number): boolean;
}
declare module "algorithms/quadtree" {
    import { AABB } from "geometry/basics";
    export type ObjectId = number;
    export function inside(ax1: number, ay1: number, ax2: number, ay2: number, bx1: number, by1: number, bx2: number, by2: number): boolean;
    export type BoundsGetter = (o: any) => AABB;
}
declare module "geometry/equations" {
    export function cubicEquation(n0: number, n1: number, n2: number, n3: number, t: number): number;
    export function quadraticEquation(start: number, control: number, end: number, t: number): number;
}
declare module "graphics-engine/curveUtils" {
    import { Point } from "types/utilities";
    export type ControlPoint = Point;
    export type QuadControlPoint = ControlPoint;
    export interface CubicControlPoint {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
    }
}
declare module "geometry/curves" {
    import { SimpleBoundingBox } from "utils/boundingBox";
    import { Point } from "types/utilities";
    /**
     * Compute the coordinates of the point positioned at length t in the quadratic bezier curve.
     *
     * @memberOf Geometry
     * @param  {number} t  In [0,1] the step percentage to reach
     *                     the point in the curve from the context point.
     * @param  {number} x1 The X coordinate of the context point.
     * @param  {number} y1 The Y coordinate of the context point.
     * @param  {number} x2 The X coordinate of the ending point.
     * @param  {number} y2 The Y coordinate of the ending point.
     * @param  {number} xi The X coordinate of the control point.
     * @param  {number} yi The Y coordinate of the control point.
     * @param {object} [dest] If specified, this object will be modified instead of allocating a new one.
     * @return {object}
     */
    export function getPointOnQuadraticCurve(t: number, x1: number, y1: number, x2: number, y2: number, xi: number, yi: number, dest?: Point): Point;
    /**
     * Check if a point is on a quadratic bezier curve segment with a thickness.
     *
     * @memberOf Geometry
     * @param  {number} px          The X coordinate of the point to check.
     * @param  {number} py          The Y coordinate of the point to check.
     * @param  {number} x1          The X coordinate of the curve start point.
     * @param  {number} y1          The Y coordinate of the curve start point.
     * @param  {number} x2          The X coordinate of the curve end point.
     * @param  {number} y2          The Y coordinate of the curve end point.
     * @param  {number} xi          The X coordinate of the curve control point.
     * @param  {number} yi          The Y coordinate of the curve control point.
     * @param  {number} width       Width of the curve.
     * @param  {number} margin
     * @param  {boolean} isTriangle Indicates if the width of the curves decreases over time
     * @return {boolean}            True if (px, py) is on the curve segment, false otherwise.
     */
    export function isPointOnQuadraticCurve(px: number, py: number, x1: number, y1: number, x2: number, y2: number, xi: number, yi: number, width: number, margin?: number, isTriangle?: boolean): boolean;
    /**
     * Compute the coordinates of the point positioned
     * at length t in the cubic bezier curve.
     *
     * @memberOf Geometry
     * @param  {number} t  In [0,1] the step percentage to reach
     *                     the point in the curve from the context point.
     * @param  {number} x1 The X coordinate of the context point.
     * @param  {number} y1 The Y coordinate of the context point.
     * @param  {number} x2 The X coordinate of the end point.
     * @param  {number} y2 The Y coordinate of the end point.
     * @param  {number} cx The X coordinate of the first control point.
     * @param  {number} cy The Y coordinate of the first control point.
     * @param  {number} dx The X coordinate of the second control point.
     * @param  {number} dy The Y coordinate of the second control point.
     * @param  {object} [dest] If specified, this object will be modified instead of allocating a new one.
     * @return {object} {x,y} The point at t.
     */
    export function getPointOnBezierCurve(t: number, x1: number, y1: number, x2: number, y2: number, cx: number, cy: number, dx: number, dy: number, dest?: Point): Point;
    /**
     * Check if a point is on a cubic bezier curve segment with a thickness.
     *
     * @memberOf Geometry
     * @param  {number} x       The X coordinate of the point to check.
     * @param  {number} y       The Y coordinate of the point to check.
     * @param  {number} x1      The X coordinate of the curve start point.
     * @param  {number} y1      The Y coordinate of the curve start point.
     * @param  {number} x2      The X coordinate of the curve end point.
     * @param  {number} y2      The Y coordinate of the curve end point.
     * @param  {number} cpx1    The X coordinate of the 1st curve control point.
     * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
     * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
     * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
     * @param  {number} width
     * @param  {number} margin
     * @return {boolean}        True if (x,y) is on the curve segment, false otherwise.
     */
    export function isPointOnBezierCurve(x: number, y: number, x1: number, y1: number, x2: number, y2: number, cpx1: number, cpy1: number, cpx2: number, cpy2: number, width: number, margin: number): boolean;
    /**
     * Bounding box of the quadratic curve
     * @param  {number} p0x  start Y
     * @param  {number} p0y  start Y
     * @param  {number} p1x  control point X
     * @param  {number} p1y  control point Y
     * @param  {number} p2x  end X
     * @param  {number} p2y  end Y
     * @param  {{minX: number, minY: number, minY: number, maxY: number}} [dest]
     * @return {{minX: number, minY: number, minY: number, maxY: number}}
     */
    export function getQuadraticCurveBoundingBox(p0x: number, p0y: number, p1x: number, p1y: number, p2x: number, p2y: number, dest?: SimpleBoundingBox): SimpleBoundingBox;
    /**
     * Bounding box of the bezier curve. Calculates for the 0-es
     * of the bezier curve derivative and hence the extremums of the curve
     *
     * https://github.com/uxebu/bonsai/blob/master/src/runner/path/curved_path.js#L605
     *
     * Optimized for no allocations
     *
     * @param  {number} p0x  start Y
     * @param  {number} p0y  start Y
     * @param  {number} cp1x  control point 1 X
     * @param  {number} cp1y  control point 1 Y
     * @param  {number} cp2x  control point 2 X
     * @param  {number} cp2y  control point 2 Y
     * @param  {number} p1x  end X
     * @param  {number} p1y  end Y
     * @param  {{minX: number, minY: number, minY: number, maxY: number}} [dest]
     * @return {{minX: number, minY: number, minY: number, maxY: number}}
     */
    export function getBezierCurveBoundingBox(p0x: any, p0y: any, cp1x: any, cp1y: any, cp2x: any, cp2y: any, p1x: any, p1y: any, dest?: SimpleBoundingBox): SimpleBoundingBox;
}
declare module "geometry/lines" {
    import { Point } from "types/utilities";
    /**
     * Checks if a point (px, py) is inside a line ((x1, y1), (x2, y2)).
     * @memberOf Geometry
     * @param {number} px
     * @param {number} py
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} width Width of the line
     * @param {number} margin
     * @param {boolean} isTriangle
     * @returns {boolean}
     */
    export function isPointInLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, width: number, margin?: number, isTriangle?: boolean): boolean;
    /**
     * Indicates if two segments intersect.
     * @memberOf Geometry
     * @param {Point} p1  First extremity of the first segment
     * @param {Point} p2  Second extremity of the first segment
     * @param {Point} p3  First extremity of the second segment
     * @param {Point} p4  Second extremity of the second segment
     * @param {boolean} [excludeBoundaries=false] If true, the segment will not be considered as
     *                                            intersecting if the intersection point is one
     *                                            of their extremities
     * @returns {boolean}
     */
    export function twoSegmentsIntersect(p1: Point, p2: Point, p3: Point, p4: Point, excludeBoundaries?: boolean): boolean;
    /**
     * Compute the angle formed by the line joining two points (x1, y1) and (x2, y2)
     * @returns {number}
     */
    export function lineAngle(x1: number, y1: number, x2: number, y2: number): number;
    export function angle(p1: Point, p2: Point, p3: Point): number;
    /**
     * Intersection between two lines (unbounded)
     * http://jsfiddle.net/justin_c_rounds/Gd2S2/
     *
     * @param  {number} ax0  The X coordinate of the start point of the first line.
     * @param  {number} ay0  The Y coordinate of the start point of the first line.
     * @param  {number} ax1  The X coordinate of the end point of the first line.
     * @param  {number} ay1  The Y coordinate of the end point of the first line.v
     * @param  {number} bx0  The X coordinate of the start point of the second line.
     * @param  {number} by0  The Y coordinate of the start point of the second line.
     * @param  {number} bx1  The X coordinate of the end point of the second line.
     * @param  {number} by1  The Y coordinate of the end point of the second line.
     */
    export function lineIntersection(ax0: number, ay0: number, ax1: number, ay1: number, bx0: number, by0: number, bx1: number, by1: number): Point | null;
    /**
     * Intersection between two segments
     * http://jsfiddle.net/justin_c_rounds/Gd2S2/
     *
     * @param  {number} ax0  The X coordinate of the start point of the first line.
     * @param  {number} ay0  The Y coordinate of the start point of the first line.
     * @param  {number} ax1  The X coordinate of the end point of the first line.
     * @param  {number} ay1  The Y coordinate of the end point of the first line.v
     * @param  {number} bx0  The X coordinate of the start point of the second line.
     * @param  {number} by0  The Y coordinate of the start point of the second line.
     * @param  {number} bx1  The X coordinate of the end point of the second line.
     * @param  {number} by1  The Y coordinate of the end point of the second line.
     */
    export function segmentIntersection(ax0: number, ay0: number, ax1: number, ay1: number, bx0: number, by0: number, bx1: number, by1: number): Point | null;
    /**
     * I thought about using Liang-Barsky algorithm there, but it's
     * the same - difficult to decide, whether the clipping occured
     * or not and which intersection point was the closest to either
     * endpoints of the line
     *            *
     *     B ----- C
     *     |*      |
     *    *|       |
     *  *  A ----- D
     *
     * @param  {Number} ax
     * @param  {Number} ay
     * @param  {Number} bx
     * @param  {Number} by
     * @param  {Number} minX
     * @param  {Number} minY
     * @param  {Number} maxX
     * @param  {Number} maxY
     * @return {Array<Point>}
     */
    export function segmentRectangleIntersection(ax: number, ay: number, bx: number, by: number, minX: number, minY: number, maxX: number, maxY: number): Point[];
    /**
     * Whether 2 line segments intersect
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @param  {number} x4
     * @param  {number} y4
     * @return {boolean}
     */
    export function lineLine(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): boolean;
    /**
     * Fast line - AABB intersection, returns boolean
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} rx1
     * @param  {number} ry1
     * @param  {number} rx2
     * @param  {number} ry2
     * @return {boolean}
     */
    export function lineAABB(x1: number, y1: number, x2: number, y2: number, rx1: number, ry1: number, rx2: number, ry2: number): boolean;
    export function distancePointSegment(p: any, v: any, w: any): number;
    export function distToSegmentSquared(px: number, py: number, vx: number, vy: number, wx: number, wy: number): number;
    export function getClosestPointOnSegment(px: number, py: number, ax: number, ay: number, bx: number, by: number): Point;
    export function getClosestPointOnLine(px: number, py: number, ax: number, ay: number, bx: number, by: number): Point;
}
declare module "geometry/polygons" {
    import { Point } from "types/utilities";
    /**
     * Check if a point (px, py) is inside a polygon.
     * @memberOf Geometry
     * @param {number} px
     * @param {number} py
     * @param {Array.<Point>} points Ordered list of point of the polygon.
     * @param {number} numPoints
     * @returns {boolean}
     */
    export function isPointInPolygon(px: number, py: number, points: Point[], numPoints?: number): boolean;
    export function polygonsIntersect(v1: Point[], v2: Point[]): boolean;
    /**
     * Returns the average of the specified points
     * @param {Array<{x: number, y: number}>} points
     * @returns {{x: number, y: number}}
     */
    export function computeCentroid(points: Point[]): Point;
}
declare module "modules/core/camera" {
    export const DEFAULT_MIN_ZOOM = 1e-8;
    export const DEFAULT_MAX_ZOOM = 100000000;
    export function computeFinalZoom(candidates: any): any;
}
declare module "geometry/circle" {
    import { Point } from "types/utilities";
    export type Circle = [number, number, number];
    /**
     * Intersection point of 2 circles
     *
     * http://paulbourke.net/geometry/circlesphere/
     *
     * @param  {number} x0
     * @param  {number} y0
     * @param  {number} r0
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} r1
     * @return {null|Array.<Array.<number>>}
     */
    export function circleCircleIntersection(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): null | [[number, number], [number, number]];
    /**
     * Vertical/horizontal comparator to sort points clockwise
     * around a center point
     *
     * @param  {number} ax
     * @param  {number} ay
     * @param  {number} bx
     * @param  {number} by
     * @param  {number} cx
     * @param  {number} cy
     * @return {number}
     */
    export function circleSortCompare(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): number;
    /**
     * Circle contains point (with an analytical touch)
     * @link https://stackoverflow.com/a/7227057/8438952
     *
     * @param  {Circle} c
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */
    export function circleContainsPoint([cx, cy, r]: Circle, x: number, y: number): boolean;
    /**
     * Circle contains disc
     * @param  {Circle} c
     * @param  {number} x
     * @param  {number} y
     * @param  {number} r
     * @return {boolean}
     */
    export function circleContainsCircle(c: Circle, x: number, y: number, r: number): boolean;
    /**
     * @param  {number}  cx
     * @param  {number}  cy
     * @param  {number}  r
     * @param  {number}  minX
     * @param  {number}  minY
     * @param  {number}  maxX
     * @param  {number}  maxY
     * @return {boolean}
     */
    export function circleIntersectsBox(cx: number, cy: number, r: number, minX: number, minY: number, maxX: number, maxY: number): boolean;
    /**
     * Finds the two points in which the line defined by the points (lx1, ly1) and (lx2, ly2) intersects the
     * circle of center (cx, cy) of radius cr, and returns the point that is closer to (lx1, ly1).
     *
     * Returns `null` if the line doesn't intersect the circle.
     * @param {number} lx1
     * @param {number} ly1
     * @param {number} lx2
     * @param {number} ly2
     * @param {number} cx
     * @param {number} cy
     * @param {number} cr
     * @param {object} [dest]
     * @returns {null|{x: number, y: number}}
     */
    export function circleLineIntersection(lx1: number, ly1: number, lx2: number, ly2: number, cx: number, cy: number, cr: number, dest?: Point): null | Point;
}


declare module "modules/spatial" {
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    import { ItemIndex } from "modules/core/graph/item";
    /**
     * @typedef {Object} RawSpatialQueryResult
     * @property {Array<number>} nodes Internal indexes of found nodes
     * @property {Array<number>} edges Internal indexes of found edges
     */
    export interface RawSpatialQueryResult {
        nodes: ItemIndex[];
        edges: ItemIndex[];
    }
    /**
     * @typedef {Object} SpatialQueryResult
     * @property {NodeList} nodes Found nodes
     * @property {EdgeList} edges Found edges
     */
    export interface SpatialQueryResult {
        nodes: NodeList;
        edges: EdgeList;
    }
}
declare module "api/captor" {
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    /**
     * @public
     * @extends Options
     * @property {object}  [detect]
     * @property {boolean} [detect.nodes=true]        Indicates if the detection of nodes should be enabled.
     * @property {boolean} [detect.edges=true]        Indicates if the detection of edges should be enabled.
     * @property {boolean} [detect.nodeTexts=true]    Indicates if the detection of node texts should be enabled.
     * @property {boolean} [detect.edgeTexts=true]    Indicates if the detection of edge texts should be enabled.
     * @property {number}  [detect.nodeErrorMargin=5] How far of the mouse a node can be and still be detected, in pixels.
     * @property {number}  [detect.edgeErrorMargin=7] How far of the mouse an edge can be and still be detected, in pixels.
     */
    export interface DetectOptions {
        nodes?: boolean;
        edges?: boolean;
        nodeTexts?: boolean;
        edgeTexts?: boolean;
        nodeErrorMargin?: number;
        edgeErrorMargin?: number;
    }
    /**
     * @public
     * @typedef {"left"|"right"|"middle"} MouseButton Identifies a mouse button.
     * @typedef {"mouse"|"touch"} InputSource         Indicates what kind of source emitted the event.
     * @typedef {Node|Edge|null} InputTarget          Element that is clicked/hovered. If it's not `null`, you can check
     * if it's a node or an edge with their `isNode` property.
     */
    export type MouseButton = 'left' | 'right' | 'middle';
    export type InputSource = 'mouse' | 'touch';
    export type InputTarget = Node | Edge | null;
    export default class CaptorAPI {
        /**
         * @method Ogma.getHoveredElement
         * Returns the element that is currently hovered.
         * @return {Node|Edge|null}
         * @example
         * var element = ogma.getHoveredElement();
         * if (!element) {
         *   console.log('No element is hovered.');
         * } else if (element.isNode) {
         *   console.log('Node ' + element.getId() + ' is hovered.');
         * } else {
         *   console.log('Edge ' + element.getId() + ' is hovered.');
         * }
         */
        getHoveredElement(): Node | Edge | null;
        /**
         * @method Ogma.getPointerInformation
         * Returns information on the cursor.
         * @return {{x: number, y: number, target: Node|Edge|null}}
         */
        getPointerInformation(): {
            x: number;
            y: number;
            target: Node | Edge | null;
        };
    }
}
declare module "types/events" {
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    import { EdgesDataChange, NodesDataChange } from "api/data";
    import { MouseButton, InputSource, InputTarget } from "api/captor";
    import { Point, NodeId, RendererType, RendererState, RendererErrorCode } from "types/utilities";
    export type TypedListener<T> = (evt: T) => void;
    export interface EdgesEvent {
        edges: EdgeList;
    }
    export interface NodesEvent {
        nodes: NodeList;
    }
    export interface NodesDragEvent {
        nodes: NodeList;
        start: Point[];
        end: Point[];
    }
    export interface DomEvent {
        domEvent: Event;
    }
    export interface NodesDataChangeEvent {
        changes: NodesDataChange[];
    }
    export interface EdgesDataChangeEvent {
        changes: EdgesDataChange[];
    }
    export interface BasicMouseEvent {
        x: number;
        y: number;
        domEvent: Event;
    }
    export type MouseButtonEvent = {
        button: MouseButton;
        source: InputSource;
        target: InputTarget;
    } & BasicMouseEvent;
    export type MouseMoveEvent = {
        dx: number;
        dy: number;
    } & BasicMouseEvent;
    export type MouseWheelEvent = {
        delta: number;
    } & BasicMouseEvent;
    export type HoverEvent = {
        target: InputTarget;
    } & BasicMouseEvent;
    export type GestureProgressEvent = {
        scale: number;
        angle: number;
    } & MouseMoveEvent;
    export interface RenderStateChangeEvent {
        type: RendererType;
        state: RendererState;
        code: RendererErrorCode;
        message: string;
    }
    export interface NodesConnectionEvent {
        source: Node;
        target: Node;
        edge: Edge;
    }
    export interface LayoutStartEvent {
        name: string;
        ids: NodeId[];
    }
    export type LayoutCompleteEvent = {
        positions: {
            before: Point[];
            after: Point[];
        };
    } & LayoutStartEvent;
    export interface LayoutComputedEvent {
        name: string;
    }
    export interface TooltipEvent {
        tooltip: HTMLElement;
    }
    /**
     * All event types that are emitted by Ogma.
     * This is not for DOM events, because it overlaps them
     * TODO: add the rest of the internal events to the enum
     */
    export enum EventTypes {
        MOVE = "move",
        DOWN = "down",
        UP = "up",
        CLICK = "click",
        DOUBLE_CLICK = "doubleClick",
        HOVER = "hover",
        UNHOVER = "unhover",
        WHEEL = "wheel",
        DRAG_START = "dragStart",
        DRAG_PROGRESS = "dragProgress",
        DRAG_END = "dragEnd",
        GESTURE_START = "gestureStart",
        GESTURE_PROGRESS = "gestureProgress",
        GESTURE_END = "gestureEnd"
    }
}





declare module "modules/labels/utils" {
    import { FontStyle, Point, Size } from "types/utilities";
    import { ItemIndex } from "modules/core/graph/item";
    import { AABB } from "geometry/basics";
    /**
     * @typedef {object} CollisionCameraInfo
     * @property {number} cameraAngle,
     * @property {number} zoom
     * @property {number} sin  Cashed sinus of camera angle
     * @property {number} cos  Cached cosinus of camera angle
     * @property {Array<number>} screen Rotated screen AABB
     */
    export interface CollisionCameraInfo {
        angle: number;
        zoom: number;
        sin: number;
        cos: number;
        screen: AABB;
    }
    /**
     * @typedef {object} CollisionData
     * @property {object} remove Items to remove
     * @property {Array<Id>} remove.nodes
     * @property {Array<Id>} remove.edges
     * @property {object} redraw Items to redraw
     * @property {Array<Id>} redraw.nodes
     * @property {Array<Id>} redraw.edges
     */
    export interface CollisionData {
        remove: {
            nodes: ItemIndex[];
            edges: ItemIndex[];
        };
        redraw: {
            nodes: ItemIndex[];
            edges: ItemIndex[];
        };
        bboxes: number[];
        rects: number[];
        intersects: Point[][];
    }
    export type TextMeasurer = (text: string, font: string, style: FontStyle, size: number) => Size;
    export const PADDING = 1;
}
declare module "utils/text" {
    export interface TextLinesInfo {
        data: string[];
        maxLength: number;
        lines: number;
    }
    /**
     * Split text into lines
     * @param  {String} text
     * @param  {Number} maxLineLength
     * @return {Object} lines and max line length
     */
    export function getLinesInfo(text: string, maxLineLength: number): TextLinesInfo;
    export function getLinesInfo(text: null, maxLineLength: number): null;
    global {
        interface Window {
            processBidirectionalText?: (str: string, arr: number[]) => string[];
            applyArabicShaping?: (str: string) => string;
        }
    }
}



declare module "modules/labels" {
    export type TextRemovalStrategy = 'topDown' | 'bottomUp';
}
declare module "modules/core/settings" {
    import { CursorStyle } from "modules/core/dom";
    import { KeyName } from "api/keyboard";
    import { ZoomBoundaryFunction } from "api/view";
    import { Color, RendererType, CrossOriginValue, Easing } from "types/utilities";
    interface FilterOptionDuringAction {
        hideNodes?: boolean;
        hideEdges?: boolean;
        hideNodeTexts?: boolean;
        hideEdgeTexts?: boolean;
    }
    export interface Options {
        detect?: {
            nodes?: boolean;
            edges?: boolean;
            nodeTexts?: boolean;
            edgeTexts?: boolean;
            nodeErrorMargin?: number;
            edgeErrorMargin?: number;
        };
        interactions?: {
            drag?: {
                enabled?: boolean;
                cursor?: CursorStyle;
            };
            selection?: {
                enabled?: boolean;
                multiSelectionKey?: KeyName | null;
            };
            transformations?: {
                updateOnDataChange?: boolean;
            };
            zoom?: {
                enabled?: boolean;
                onDoubleClick?: boolean;
                duration?: number;
                modifier?: number;
                minValue?: null | ZoomBoundaryFunction;
                maxValue?: null | ZoomBoundaryFunction;
                easing?: Easing | ((t: number) => number);
            } & FilterOptionDuringAction;
            pan?: {
                enabled?: boolean;
            } & FilterOptionDuringAction;
            rotation?: {
                enabled?: boolean;
            } & FilterOptionDuringAction;
            gesture?: {
                enabled?: boolean;
            } & FilterOptionDuringAction;
        };
        cursor?: {
            default?: CursorStyle;
            node?: CursorStyle;
            edge?: CursorStyle;
        };
        backgroundColor?: Color;
        renderer?: RendererType;
        imgCrossOrigin?: CrossOriginValue;
        texts?: {
            preventOverlap?: boolean;
            hideUntilFontsLoaded?: boolean;
        };
        mouse?: {
            enabled?: boolean;
            wheelEnabled?: boolean;
            disableWheelUntilMouseDown?: boolean;
            doubleClickTimer?: number;
        };
        touch?: {
            enabled?: boolean;
        };
        minimumWidth?: number;
        minimumHeight?: number;
        edgesAlwaysCurvy?: boolean;
        directedEdges?: boolean;
    }
    export interface InteractionZoomObject {
        smallestNodeSize: number;
        biggestNodeSize: number;
        graphWidth: number;
        graphHeight: number;
        viewWidth: number;
        viewHeight: number;
    }
}
declare module "modules/core/dom" {
    export type CursorStyle = string;
}


declare module "modules/classes/styleClass" {
    import { NodeAttributesValue, EdgeAttributesValue, NodeDependencies, EdgeDependencies, NodeOutput, EdgeOutput } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import EdgeList from "modules/core/graph/edgeList";
    /**
     * @public
     * @typedef {object} StyleClassDefinition
     * @property {NodeAttributesValue} [options.nodeAttributes]
     * @property {EdgeAttributesValue} [options.edgeAttributes]
     * @property {NodeDependencies}    [options.nodeDependencies]
     * @property {EdgeDependencies}    [options.edgeDependencies]
     * @property {NodeOutput}          [options.nodeOutput]
     * @property {EdgeOutput}          [options.edgeOutput]
     */
    export interface StyleClassDefinition {
        nodeAttributes?: NodeAttributesValue;
        edgeAttributes?: EdgeAttributesValue;
        nodeDependencies?: NodeDependencies;
        edgeDependencies?: EdgeDependencies;
        nodeOutput?: NodeOutput;
        edgeOutput?: EdgeOutput;
    }
    /**
     *
     * @public
     * @class StyleClass
     */
    export default class StyleClass {
        /**
         * @method StyleClass.getName
         * Returns the name of the class.
         * @returns {string}
         */
        getName(): string;
        /**
         * @method StyleClass.getIndex
         * Returns the index of the class in the internal class array. A higher index class is applied after a lower
         * index class.
         * @returns {number}
         */
        getIndex(): number;
        /**
         * @method StyleClass.setIndex
         * Set the index of the class in the internal class array. A higher index class is applied after a lower
         * index class.
         * @param {number} index
         */
        setIndex(index: any): void;
        /**
         * @method StyleClass.update
         * Updates the attributes assigned to nodes and edges that have that class.
         * @param {object} options
         * @param {NodeAttributesValue} [options.nodeAttributes]
         * @param {EdgeAttributesValue} [options.edgeAttributes]
         * @param {boolean} [options.fullOverwrite=false] Indicates if the specified attributes should be merge with current
         * ones (false) or if the specified attributes should entirely replace the current ones.
         * @param {NodeDependencies}    [options.nodeDependencies]
         * @param {EdgeDependencies}    [options.edgeDependencies]
         * @param {NodeOutput}          [options.nodeOutput]
         * @param {EdgeOutput}          [options.edgeOutput]
         * @example
         * var myClass = ogma.styles.createClass({ name: 'myCustomClass', nodeAttributes: { color: 'green' } });
         * ogma.getNode('n0').addClass('myCustomClass');
         * myClass.update({ nodeAttributes: { color: 'red' } });
         * ogma.getNode('n0').getAttribute('color'); // 'red'
         */
        update(options: StyleClassDefinition): this;
        /**
         * @method StyleClass.getDefinition
         * Returns the node and edge attributes associated with the class.
         * @returns {StyleClassDefinition}
         */
        getDefinition(): StyleClassDefinition;
        /**
         * @method StyleClass.getNodes
         * Returns the list of nodes that have the class. Does not include filtered nodes.
         * @returns {NodeList}
         */
        getNodes(): NodeList;
        /**
         * @method StyleClass.getEdges
         * Returns the list of edges that have the class. Does not include filtered edges.
         * @returns {EdgeList}
         */
        getEdges(): EdgeList;
        /**
         * @method StyleClass.clearNodes
         * Remove the class from all nodes.
         */
        clearNodes(): void;
        /**
         * @method StyleClass.clearEdges
         * Remove the class from all edges.
         */
        clearEdges(): void;
        /**
         * @method StyleClass.add
         * Add the class to the specified node(s)/edge(s). Equivalent to to `elements.addClass(myClass.getName())`.
         * @param {Node|Edge|NodeList|EdgeList} elements
         */
        add(elements: Node | Edge | NodeList | EdgeList): void;
        /**
         * @method StyleClass.remove
         * Remove the class from the specified node(s)/edge(s). Equivalent to to `elements.removeClass(myClass.getName())`.
         * @param {Node|Edge|NodeList|EdgeList} elements
         */
        remove(elements: Node | Edge | NodeList | EdgeList): void;
    }
}
declare module "modules/styleRules/styleRule" {
    import { NodeAttributesValue, EdgeAttributesValue, NodeSelector, EdgeSelector, NodeDependencies, EdgeDependencies, NodeOutput, EdgeOutput } from "types/utilities";
    export type StyleRuleId = number;
    /**
     * @public
     * @typedef {object} NodeStyleRuleDefinition
     * @property {NodeAttributesValue} [options.nodeAttributes]
     * @property {EdgeAttributesValue} [options.edgeAttributes]
     * @property {NodeSelector}        [options.nodeSelector]
     * @property {EdgeSelector}        [options.edgeSelector]
     * @property {NodeDependencies}    [options.nodeDependencies]
     * @property {EdgeDependencies}    [options.edgeDependencies]
     * @property {NodeOutput}          [options.nodeOutput]
     * @property {EdgeOutput}          [options.edgeOutput]
     */
    export interface NodeStyleRuleDefinition {
        nodeAttributes?: NodeAttributesValue;
        edgeAttributes?: EdgeAttributesValue;
        nodeSelector?: NodeSelector;
        edgeSelector?: EdgeSelector;
        nodeDependencies?: NodeDependencies;
        edgeDependencies?: EdgeDependencies;
        nodeOutput?: NodeOutput;
        edgeOutput?: EdgeOutput;
    }
    export type StyleRuleOptions = {
        fullOverwrite?: boolean;
    } & NodeStyleRuleDefinition;
    /**
     * @public
     * @class StyleRule
     */
    export default class StyleRule {
        /**
         * @method StyleRule.getId
         * Returns the unique positive integer rule id associated with the rule.
         * @returns {number}
         */
        getId(): number;
        /**
         * @method StyleRule.whenApplied
         * Call the specified function when the rule is applied for the first time.
         * @return {Promise<StyleRule>}
         * @example
         * var rule = ogma.styles.addRule({
         *   nodeAttributes: {
         *     text: function (node) {
         *       return node.getData('name');
         *     }
         *   }
         * });
         *
         * rule.whenApplied().then(function () {
         *   console.log('Attributes updated!');
         * });
         */
        whenApplied(): Promise<this>;
        /**
         * @method StyleRule.refresh
         * Refresh the rule for all nodes.
         * @return {Promise<void>}
         * @example
         * var myMapping = {
         *   person: 'red',
         *   country: 'blue',
         *   company: 'green'
         * };
         *
         * var rule = ogma.styles.addRule({
         *   nodeAttributes: {
         *     color: function (node) {
         *       return myMapping[node.getData('type')];
         *     }
         *   }
         * });
         *
         * // Change a variable referenced by the rule
         * myMapping.company = 'purple';
         *
         * // Manually refresh the rule
         * rule.refresh();
         */
        refresh(): Promise<void>;
        /**
         * @method StyleRule.getIndex
         * Retrieve the position of the rule in the internal rule list. Rules with a higher index are applied after rules
         * with a lower index.
         * @return {number}
         * @example
         * // Set rule 1 as less priority than rule 2
         * rule1.setIndex(rule2.getIndex());
         */
        getIndex(): number;
        /**
         * @method StyleRule.setIndex
         * Assign the position of the rule in the internal rule list. Rules with a higher index are applied after rules
         * with a lower index.
         * @param {number} index
         * @returns {Promise<void>}
         * @example
         * // Set rule 1 as less priority than rule 2
         * rule1.setIndex(rule2.getIndex());
         */
        setIndex(index: any): Promise<void>;
        /**
         * @method StyleRule.update
         * Updates the attributes and selectors associated with the rule.
         * @param options
         * @param {NodeAttributesValue} [options.nodeAttributes]
         * @param {EdgeAttributesValue} [options.edgeAttributes]
         * @param {boolean}             [options.fullOverwrite=false] Indicates if the specified attributes should be merged with current
         * ones (false) or if the specified attributes should entirely replace the current ones.
         * @param {NodeSelector}        [options.nodeSelector]
         * @param {EdgeSelector}        [options.edgeSelector]
         * @param {NodeDependencies}    [options.nodeDependencies]
         * @param {EdgeDependencies}    [options.edgeDependencies]
         * @param {NodeOutput}          [options.nodeOutput]
         * @param {EdgeOutput}          [options.edgeOutput]
         * @returns {Promise<void>}
         */
        update(options: StyleRuleOptions): Promise<void>;
        /**
         * @method StyleClass.getDefinition
         * Returns the attributes and selectors associated with the rule.
         * @returns {NodeStyleRuleDefinition}
         */
        getDefinition(): NodeStyleRuleDefinition;
        /**
         * @method StyleRule.destroy
         * Delete the rule. After this is called, a call to any method on this object will throw an error.
         * @return {Promise<void>}
         * @example
         * var rule = ogma.styles.addRule({
         *   nodeAttributes: {
         *     text: function (node) {
         *       return node.getData('name');
         *     }
         *   }
         * });
         *
         * rule.destroy();
         */
        destroy(): Promise<void>;
        /**
         * @deprecated
         * @method StyleRule.delete
         * Alias to [`destroy()`](#StyleRule-destroy)
         * @return {Promise<void>}
         */
        delete(): Promise<void>;
    }
}
declare module "api/styles" {
    import Ogma from "src/ogma";
    import { NodeAttributesValue, EdgeAttributesValue } from "types/utilities";
    import { NodeSelector, EdgeSelector, NodeDependencies, EdgeDependencies, NodeOutput, EdgeOutput } from "types/utilities";
    import StyleRule from "modules/styleRules/styleRule";
    import StyleClass from "modules/classes/styleClass";
    /**
     * @extends Options
     * @property {CursorStyle} [cursor.node="pointer"] Cursor style when a node is hovered.
     * @property {CursorStyle} [cursor.edge="pointer"] Cursor style when an edge is hovered.
     */
    export interface ClassDefinition {
        name: string;
        nodeAttributes?: NodeAttributesValue;
        edgeAttributes?: EdgeAttributesValue;
        nodeDependencies?: NodeDependencies;
        edgeDependencies?: EdgeDependencies;
        nodeOutput?: NodeOutput;
        edgeOutput?: EdgeOutput;
    }
    const createStylesAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.styles.setNodesVisibility
         * Show or hide all the nodes. This method has an internal counter; if it's called with `false`, the counter is
         * decreased by one, if it's called with `true` the counter is increased by one. The counter starts at 0, and
         * cannot go lower than 0.
         * The nodes are shown if the counter is equal to 0.
         * @param {boolean} value
         */
        setNodesVisibility(value: boolean): void;
        /**
         * @method Ogma.styles.setEdgesVisibility
         * Show or hide all the edges. This method has an internal counter; if it's called with `false`, the counter is
         * decreased by one, if it's called with `true` the counter is increased by one. The counter starts at 0, and
         * cannot go lower than 0.
         * The edges are shown if the counter is equal to 0.
         * @param {boolean} value
         */
        setEdgesVisibility(value: boolean): void;
        /**
         * @method Ogma.styles.setNodeTextsVisibility
         * Show or hide all the node texts. This method has an internal counter; if it's called with `false`, the counter is
         * decreased by one, if it's called with `true` the counter is increased by one. The counter starts at 0, and
         * cannot go lower than 0.
         * The node texts are shown if the counter is equal to 0.
         * @param {boolean} value
         */
        setNodeTextsVisibility(value: boolean): void;
        /**
         * @method Ogma.styles.setEdgeTextsVisibility
         * Show or hide all the edge texts. This method has an internal counter; if it's called with `false`, the counter is
         * decreased by one, if it's called with `true` the counter is increased by one. The counter starts at 0, and
         * cannot go lower than 0.
         * The edge texts are shown if the counter is equal to 0.
         * @param {boolean} value
         */
        setEdgeTextsVisibility(value: boolean): void;
        /**
         * @method Ogma.styles.addRule
         * Add a style rule, applying the specified attributes to all nodes & edges that match the specified selector.
         * The style of a node is re-computed when its degree or data changes, and automatically assigned when a node is added.
         * Rules are applied one after another. The latest added rule is applied last. Rules are applied before
         * attributes assigned through `setAttributes`, which are applied before classes.
         * @param {object} [options]
         * @param {NodeAttributesValue} [options.nodeAttributes] Attributes that will be assigned to the nodes.
         * @param {EdgeAttributesValue} [options.edgeAttributes] Attributes that will be assigned to the edges.
         * @param {NodeSelector}        [options.nodeSelector] Indicates if the rule should be applied to a given node. If unspecified, the rule is applied to all nodes.
         * @param {EdgeSelector}        [options.edgeSelector] Indicates if the rule should be applied to a given edge. If unspecified, the rule is applied to all edges.
         * @param {NodeDependencies}    [options.nodeDependencies] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Attributes on which the functions (if any) in the `nodeAttributes` field depend
         * @param {EdgeDependencies}    [options.edgeDependencies] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Attributes on which the functions (if any) in the `edgeAttributes` field depend
         * @param {NodeOutput} [options.nodeOutput] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Node attributes assigned by the rule. If unspecified, they are inferred from the `nodeAttributes` field.
         * This field is used together with the dependency fields of other rules/classes to know which rules/classes should be
         * updated when this rule is updated.
         * @param {EdgeOutput} [options.edgeOutput] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Edge attributes assigned by the rule. If unspecified, they are inferred from the `edgeAttributes` field.
         * This field is used together with the dependency fields of other rules/classes to know which rules/classes should be
         * updated when this rule is updated.
         * @returns {StyleRule}
         * @example
         * // Set the same color and size for all nodes, and the same shape to all edges
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     color: 'red',
         *     radius: 10
         *   },
         *   edgeAttributes: {
         *     shape: {
         *       type: 'line',
         *       style: 'plain',
         *       head: 'arrow',
         *       tail: null
         *     }
         *   }
         * });
         * @example
         * // Use a selector to restrict the rule to a subset of the graph
         * ogma.styles.addRule({
         *   nodeSelector: function(node) {
         *     return node.getData('a.b.c') !== undefined;
         *   },
         *   nodeAttributes: {
         *     color: 'red',
         *     radius: 10
         *   }
         * });
         * @example
         * // Assign node color and size using a function
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     color: function(node) {
         *       if (node.getData('foo') === 'bar') {
         *         return 'red';
         *       } else {
         *         return 'green';
         *       }
         *     },
         *     radius: function(node) {
         *       return node.getDegree() + 1;
         *     }
         *   }
         * });
         * @example
         * // It's possible to provide a function at any level of nesting
         * // Here we provide a function at the badges level for nodes and at the root level for edges
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     shape: 'square',
         *     badges: function(node) {
         *       // Display the node degree in either the top-left badge or the top-right badge depending on the `foo` data
         *       var badge = { text: node.getDegree() };
         *
         *       if (node.getData('foo') === 'bar') {
         *         return { topLeft: badge };
         *       } else {
         *         return { topRight: badge };
         *       }
         *     }
         *   },
         *   edgeAttributes: function(edge) {
         *     // We either want a blue arrow or a red line depending on the edge's data
         *     if (edge.getData('property') === 'value') {
         *       return {
         *         color: 'blue',
         *         shape: 'arrow'
         *       };
         *     } else {
         *       return {
         *         color: 'red',
         *         shape: 'line'
         *       };
         *     }
         *   }
         * });
         */
        addRule(options: {
            nodeAttributes?: NodeAttributesValue;
            edgeAttributes?: EdgeAttributesValue;
            nodeSelector?: NodeSelector;
            edgeSelector?: EdgeSelector;
            nodeDependencies?: NodeDependencies;
            edgeDependencies?: EdgeDependencies;
            nodeOutput?: {
                attributes?: "all" | (string | string[])[];
            };
            edgeOutput?: {
                attributes?: "all" | (string | string[])[];
            };
        }): StyleRule;
        /**
         * @method Ogma.styles.getRuleList
         * Returns the list of all rules, in the order they are applied.
         * @returns {Array<StyleRule>}
         */
        getRuleList(): StyleRule[];
        /**
         * @deprecated
         * @method Ogma.styles.addNodeRule
         * Add a rule that impacts only nodes.
         * @param {NodeSelector} [selector]
         * @param {NodeAttributesValue} rule
         * @returns {StyleRule}
         */
        addNodeRule(selector?: NodeSelector, rule?: NodeAttributesValue): StyleRule;
        /**
         * @deprecated
         * @method Ogma.styles.addEdgeRule
         * Add a rule that impacts only edges.
         * @param {EdgeSelector} [selector]
         * @param {EdgeAttributesValue} rule
         * @returns {StyleRule}
         */
        addEdgeRule(selector?: EdgeSelector, rule?: EdgeAttributesValue): StyleRule;
        /**
         * @deprecated
         * @method Ogma.styles.getNodeRules
         * Returns all rules that only impact nodes.
         * @returns {Array<StyleRule>}
         */
        getNodeRules(): StyleRule[];
        /**
         * @deprecated
         * @method Ogma.styles.getEdgeRules
         * Returns all rules that only impact edges.
         * @returns {Array<StyleRule>}
         */
        getEdgeRules(): StyleRule[];
        /**
         * @method Ogma.styles.createClass
         * Create a new class for nodes & edges. Classes are similar to style rules, except they are assigned on an
         * individual basis instead of according to a selector (assigned only to the nodes/edges that have been
         * assigned the class with `node.addClass('className')`).
         * @param {object} options
         * @param {string}              options.name Name of the class to be created.
         * @param {NodeAttributesValue} [options.nodeAttributes] Attributes applied to nodes when they have this class.
         * @param {EdgeAttributesValue} [options.edgeAttributes] Attributes applied to edges when they have this class.
         * @param {NodeDependencies}    [options.nodeDependencies] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Attributes on which the functions (if any) in the `nodeAttributes` field depend
         * @param {EdgeDependencies}    [options.edgeDependencies] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Attributes on which the functions (if any) in the `edgeAttributes` field depend
         * @param {NodeOutput} [options.nodeOutput] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Node attributes assigned by the class. If unspecified, they are inferred from the `nodeAttributes` field.
         * This field is used together with the dependency fields of other rules/classes to know which rules/classes should be
         * updated when this class is assigned/removed to/from a node.
         * @param {EdgeOutput} [options.edgeOutput] (Advanced - see [tutorial](tutorials/styling-optimization/))
         * Edge attributes assigned by the class. If unspecified, they are inferred from the `edgeAttributes` field.
         * This field is used together with the dependency fields of other rules/classes to know which rules/classes should be
         * updated when this class is assigned/removed to/from a edge.
         * @returns {StyleClass}
         * @example
         * ogma.createClass({ name: 'myCustomClass', nodeAttributes: {color: 'green'} });
         *
         * ogma.getNode('n0').addClass('myCustomClass');
         * ogma.getNode('n0').removeClass('myCustomClass');
         * @example
         * // Create a class that increase the radius of the nodes
         * ogma.createClass('myOtherClass', {
         *   nodeAttributes: {
         *     radius: function (node) {
         *       return node.getAttribute('radius') + 1;
         *     }
         *   }
         * });
         */
        createClass(options: ClassDefinition): StyleClass;
        /**
         * @method Ogma.styles.getClass
         * Returns the class with the specified name. Returns `null` if no class has the specified name.
         * @param {string} className
         * @returns {StyleClass|null}
         */
        getClass(className: string): StyleClass;
        /**
         * @method Ogma.styles.getClassList
         * Returns the list of existing classes by increasing priority, excluding builtin classes.
         * @returns {Array<StyleClass>}
         */
        getClassList(): StyleClass[];
        /**
         * @method Ogma.styles.setHoveredNodeAttributes
         * Set the style of nodes when they are hovered. If `null` is specified, no style will be applied to hovered nodes.
         * @param {NodeAttributesValue|null} attributes Attributes to apply to hovered nodes
         * @param {boolean} [fullOverwrite=false] If `false`, the specified attributes will be merged with the current attributes.
         * If `true`, the attributes applied on hover will be exactly the ones supplied.
         * @example
         * ogma.styles.setHoveredNodeAttributes({
         *   outline: false, // Disabling the shadow on hover
         *   outerStroke: {
         *     color: 'green' // Changing the shadow on hover,
         *  },
         *   text: function (node) { return node.getData('label'); }
         * });
         * @example
         * // Removing the style change on hover
         * ogma.styles.setHoveredNodeAttributes(null);
         * @example
         * // Restoring the default node hover attributes:
         * ogma.styles.setHoveredNodeAttributes({
         *   outline: true,
         *   outerStroke: {
         *     color: 'red',
         *     width: 5
         *   },
         *   text: {
         *     backgroundColor: 'rgb(220, 220, 220)',
         *     minVisibleSize: 0
         *   }
         * });
         */
        setHoveredNodeAttributes(attributes: NodeAttributesValue, fullOverwrite?: boolean): void;
        /**
         * @method Ogma.styles.setHoveredEdgeAttributes
         * Set the style of edges when they are hovered. If `null` is specified, no style will be applied to hovered edges.
         * @param {EdgeAttributesValue|null} attributes Attributes to apply to hovered edges
         * @param {boolean} [fullOverwrite=false] If `false`, the specified attributes will be merged with the current attributes.
         * If `true`, the attributes applied on hover will be exactly the ones supplied.
         * @example
         * // Restoring the default edge hover attributes:
         * ogma.styles.setHoveredEdgeAttributes({
         *   outline: true,
         *   color: 'red',
         *   text: {
         *     backgroundColor: 'rgb(220, 220, 220)',
         *     minVisibleSize: 0
         *   }
         * });
         */
        setHoveredEdgeAttributes(attributes: EdgeAttributesValue, fullOverwrite?: boolean): void;
        /**
         * @method Ogma.styles.setSelectedNodeAttributes
         * Set the style of nodes when they are selected. If `null` is specified, no style will be applied to selected nodes.
         * @param {NodeAttributesValue|null} attributes Attributes to apply to selected nodes
         * @param {boolean} [fullOverwrite=false] If `false`, the specified attributes will be merged with the current attributes.
         * If `true`, the attributes applied on selection will be exactly the ones supplied.
         * @example
         * // Change the outer stroke color on selection
         * ogma.styles.setSelectedNodeAttributes({
         *   outerStroke:{
         *     color: 'green'
         *   }
         * });
         */
        setSelectedNodeAttributes(attributes: NodeAttributesValue, fullOverwrite?: boolean): void;
        /**
         * @method Ogma.styles.setSelectedEdgeAttributes
         * Set the style of edges when they are selected. If `null` is specified, no style will be applied to selected edges.
         * @param {EdgeAttributesValue|null} attributes Attributes to apply to selected edges
         * @param {boolean} [fullOverwrite=false] If `false`, the specified attributes will be merged with the current attributes.
         * If `true`, the attributes applied on selection will be exactly the ones supplied.
         * @example
         * // Change the color on selection
         * ogma.styles.setSelectedEdgeAttributes({
         *   color: 'green'
         * });
         */
        setSelectedEdgeAttributes(attributes: EdgeAttributesValue, fullOverwrite?: boolean): void;
    };
    export default class StylesAPI {
        styles: ReturnType<typeof createStylesAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}





declare module "modules/mouse" {
    export interface MouseWheelEvent {
        domEvent: WheelEvent;
        x: number;
        y: number;
        delta: number;
    }
}



declare module "modules/lasso" {
    import { Color } from "types/utilities";
    import { CursorStyle } from "modules/core/dom";
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    export interface LassoOptions {
        strokeColor?: Color;
        strokeWidth?: number;
        fillColor?: Color;
        cursorStyle?: CursorStyle;
        callback?: (payload: {
            nodes: NodeList;
            edges: EdgeList;
        }) => void;
        bothExtremities?: boolean;
    }
}
declare module "modules/rectangleSelect" {
    import { LassoOptions } from "modules/lasso";
    export type RectangleSelectOptions = LassoOptions;
}


declare module "api/algorithms" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    import { Filter, NodeId } from "types/utilities";
    interface ShortestPathOptions {
        source: Node | NodeId;
        target: Node | NodeId;
        directed?: boolean;
        filter?: Filter;
        edgeCostFunction?: (edge: Edge) => number;
        heuristicFunction?: (source: Node, target: Node) => number;
    }
    interface RawGraph {
        nodes?: NodeList;
        edges?: EdgeList;
    }
    const createAlgorithmsAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.algorithms.shortestPath
         * Compute the shortest path between the specified source and target nodes.
         * @param {object} options
         * @param {Node|NodeId} options.source
         * @param {Node|NodeId} options.target
         * @param {boolean} [options.directed=false] Indicates if the graph should be considered as directed.
         * @param {Filter} [options.filter="visible"] Indicates on which elements to perform the algorithm.
         * @param {function(edge: Edge): number} [options.edgeCostFunction] Function retrieving the cost of an edge. By default, returns 1 for all edges.
         * @param {function(source: Node, target: Node): number} [options.heuristicFunction] Function retrieving an estimation
         * of the distance between two nodes. By default no heuristic is used.
         * @returns {Promise<null|{nodes: NodeList, edges: EdgeList}>} Shortest path. `nodes` has exactly one more node than `edges` has edges.
         * If there is no path, returns `null`.
         * @example
         * ogma.algorithms.shortestPath({
         *   source: 'nodeId1',
         *   target: 'nodeId2',
         *   edgeCostFunction: function(edge) {
         *     return edge.getData('cost');
         *   }
         * }).then(function(path) {
         *   if (path) {
         *     path.nodes.setAttributes({color: 'green'});
         *     path.edges.setAttributes({color: 'green'});
         *   }
         * });
         */
        shortestPath: (options: ShortestPathOptions) => Promise<Required<RawGraph>>;
        /**
         * @method Ogma.algorithms.hasCycle
         * Checks whether the given graph has cycles in it.
         * @param  {Object}    [options]
         * @param  {NodeList}  [options.nodes] If omitted, the whole graph will be taken as input.
         * @param  {EdgeList}  [options.edges] If omitted, adjacent edges of the
         *                                     provided nodes are going to be used.
         * @return {Boolean}
         */
        hasCycle: ({ nodes, edges }?: RawGraph) => boolean;
        /**
         * @method Ogma.algorithms.getAllSimpleCycles
         * Implements Tarjan's algorithm of finding all simple cycles in the directed graph.
         *
         * @param  {Object}    [options]
         * @param  {NodeList}  [options.nodes] If omitted, the whole graph will be taken as input.
         * @param  {EdgeList}  [options.edges] If omitted, adjacent edges of the
         *                                     provided nodes are going to be used.
         * @return {Array<NodeList>}
         */
        getAllSimpleCycles: ({ nodes, edges }?: RawGraph) => NodeList[];
        /**
         * @method Ogma.algorithms.detectCycle
         * Returns the first cycle found as a NodeList.
         *
         * @param  {Object}    [options]
         * @param  {NodeList}  [options.nodes] If omitted, the whole graph will be taken as input.
         * @param  {EdgeList}  [options.edges] If omitted, adjacent edges of the
         *                                     provided nodes are going to be used.
         * @return {boolean|NodeList}
         */
        detectCycle: ({ nodes, edges }?: RawGraph) => boolean | NodeList[];
    };
    export default class AlgorithmsAPI {
        algorithms: ReturnType<typeof createAlgorithmsAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/classes" {
    import { NodeAttributesValue, EdgeAttributesValue } from "types/utilities";
    import StyleClass from "modules/classes/styleClass";
    import EdgeList from "modules/core/graph/edgeList";
    import NodeList from "modules/core/graph/nodeList";
    export default class ClassesAPI {
        /**
         * @deprecated
         * @method Ogma.createClass
         * Alias for `ogma.styles.createClass`.
         * @param {string} className
         * @param {object} [options]
         * @param {NodeAttributesValue} [options.nodeAttributes]
         * @param {EdgeAttributesValue} [options.edgeAttributes]
         * @param {string} [options.after] If specified, the class index will be set so it's exactly one more than the specified class
         * @returns {StyleClass}
         */
        createClass(className: string, options?: {
            nodeAttributes?: NodeAttributesValue;
            edgeAttributes?: EdgeAttributesValue;
        }): StyleClass;
        /**
         * @deprecated
         * @method Ogma.updateClass
         * Update the attributes associated with the specified class.
         * Same effect as [`StyleClass.update`](#StyleClass-update).
         * @param {string} className
         * @param {object} [options]
         * @param {NodeAttributesValue} [options.nodeAttributes]
         * @param {EdgeAttributesValue} [options.edgeAttributes]
         */
        updateClass(className: string, options?: {
            nodeAttributes?: NodeAttributesValue;
            edgeAttributes?: EdgeAttributesValue;
        }): StyleClass;
        /**
         * @deprecated
         * @method Ogma.getNodesByClassName
         * Returns the nodes that have the specified class.
         * Same effect as [`StyleClass.update`](#StyleClass-getNodes).
         * @param {string} className
         * @returns {NodeList}
         */
        getNodesByClassName(className: string): NodeList;
        /**
         * @deprecated
         * @method Ogma.getEdgesByClassName
         * Returns the edges that have the specified class.
         * Same effect as [`StyleClass.update`](#StyleClass-getEdges).
         * @param {string} className
         * @returns {EdgeList}
         */
        getEdgesByClassName(className: string): EdgeList;
    }
}
declare module "api/debug" {
    import Ogma from "src/ogma";
    export default class DebugAPI {
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/dom" {
    export default class DomAPI {
        /**
         * @method Ogma.setContainer
         * Set the DOM element used by this Ogma instance. If a string is specified,
         * the element will be looked up with `document.getElementById()`.
         * If the argument is `null`, then Ogma is removed from the current container.
         * @param {HTMLElement|string|null} elt
         * @example
         * var container = document.createElement('div');
         * document.body.appendChild(container);
         *
         * ogma.setContainer(container);
         */
        setContainer(elt: HTMLElement | string | null): void;
        /**
         * @method Ogma.getContainer
         * Returns the DOM element used by this Ogma instance.
         * @returns {HTMLElement|null}
         */
        getContainer(): HTMLElement | null;
    }
}
declare module "api/events" {
    import Ogma from "src/ogma";
    import { TypedListener, EdgesEvent, NodesEvent, NodesDragEvent, MouseMoveEvent, MouseButtonEvent, HoverEvent, DomEvent, GestureProgressEvent, RenderStateChangeEvent, NodesConnectionEvent, LayoutStartEvent, LayoutCompleteEvent, LayoutComputedEvent, TooltipEvent, NodesDataChangeEvent, EdgesDataChangeEvent } from "types/events";
    const createEventsAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.events.removeListener
         * Remove a listener from all events it was bound to.
         * @param {function} listener
         * @example
         * var listener = function (evt) {
         *   console.log(evt.nodes.getId() + ' were selected.');
         * }
         *
         * ogma.events.onNodesSelected(listener);
         * ogma.events.removeListener(listener);
         */
        removeListener(listener: TypedListener<any>): void;
        /**
         * @method Ogma.events.onNodesAdded
         * Triggers the specified function when some nodes are added to the graph.
         * @param {function (evt: {nodes: NodeList})} listener
         */
        onNodesAdded(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onBeforeNodesRemoved
         * Triggers right before the nodes are removed, but they are still in the
         * graph and their data is accessible.
         * @param {function (evt: {nodes: NodeList})} listener
         */
        onBeforeNodesRemoved(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodesRemoved
         * Triggers the specified function when some nodes are removed from the graph.
         * @param {function (evt: {nodes: NodeList})} listener
         */
        onNodesRemoved(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesAdded
         * Triggers the specified function when some edges are added to the graph.
         * @param {function (evt: {edges: EdgeList})} listener
         */
        onEdgesAdded(listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onBeforeEdgesRemoved
         * Triggers right before the edges are removed, but they are still in the
         * graph and their data is accessible.
         * @param {function(evt: {edges: EdgeList})} listener
         */
        onBeforeEdgesRemoved(listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesRemoved
         * Triggers the specified function when some edges are removed from the graph.
         * @param {function (evt: {edges: EdgeList})} listener
         */
        onEdgesRemoved(listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodesClassAdded
         * Triggers the specified function when the specified class is added to some nodes.
         * @param {string} className
         * @param {function(evt: {nodes: NodeList})} listener
         * @example
         * ogma.createClass('myCustomClass', {nodeAttributes: {color: 'green'}});
         *
         * ogma.events.onNodesClassAdded('myCustomClass', function (evt) {
         *   console.log('Nodes ' + evt.nodes.getId() + ' now have the class "myCustomClass".');
         * });
         *
         * ogma.getNodes(['n0', 'n1']).addClass('myCustomClass');
         */
        onNodesClassAdded(className: string, listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodesClassRemoved
         * Triggers the specified function when the specified class is removed from some nodes.
         * @param {string} className
         * @param {function(evt: {nodes: NodeList})} listener
         */
        onNodesClassRemoved(className: string, listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesClassAdded
         * Triggers the specified function when the specified class is added to some edges.
         * @param {string} className
         * @param {function(evt: {edges: EdgeList})} listener
         */
        onEdgesClassAdded(className: string, listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesClassRemoved
         * Triggers the specified function when the specified class is removed from some edges.
         * @param {string} className
         * @param {function(evt: {edges: EdgeList})} listener
         */
        onEdgesClassRemoved(className: string, listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @extends Options
         * @property {object}       [interactions]
         * @property {object}       [interactions.drag]
         * @property {boolean}      [interactions.drag.enabled=true] Indicates if dragging nodes with the mouse should be enabled.
         * @property {CursorStyle}  [interactions.drag.cursor='move'] Cursor style to be applied while dragging the node
         */
        /**
         * @method Ogma.events.onNodeDragStart
         * Triggered when the user starts to drag some nodes.
         * @param {function(evt: {nodes: NodeList})} listener
         * @example
         * ogma.events.onNodeDragStart(function (evt) {
         *   console.log('User started to drag nodes ' + evt.nodes.getId());
         * });
         */
        onNodeDragStart(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodeDragProgress
         * Triggered when the user drags some nodes.
         * @param {function(evt: {nodes: NodeList})} listener
         * @example
         * ogma.events.onNodeDragStart(function (evt) {
         *   console.log('User dragged nodes ' + evt.nodes.getId());
         * });
         */
        onNodeDragProgress(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodeDragEnd
         * Triggered when the user stop dragging some nodes.
         * @param {function(evt: {nodes: NodeList, start: Array<{x: number, y: number}>, end: Array<{x: number, y: number}>})} listener
         * @example
         * ogma.events.onNodeDragStart(function (evt) {
         *   evt.nodes.forEach(function(node, index) {
         *     console.log('User dragged node from ' + evt.start[index] + ' to ' + evt.end[index]);
         *   });
         * });
         */
        onNodeDragEnd(listener: TypedListener<NodesDragEvent>): Ogma;
        /**
         * @method Ogma.events.onKeyPress
         * Triggers the specified function when the specified key is pressed.
         * @param {KeyName|KeyCode|Array<KeyName|KeyCode>|string} key Key to listen to. Multiple keys can be specified; in
         * that case the function is triggered when the last key of the list is pressed, only if all the other keys are pressed.
         * @param {function(evt: {domEvent: Event})} listener
         * @example
         * // By specifying the key as a string (key identifier)
         * ogma.events.onKeyPress('b', function () { console.log('B was pressed.'); });
         *
         * // By specifying the JavaScript key code
         * ogma.events.onKeyPress(66, function () { console.log('B was pressed.'); });
         *
         * // By specifying a space-separated list of key identifiers
         * ogma.events.onKeyPress('ctrl b', function () { console.log('CTRL + B pressed.'); });
         *
         * // By specifying an array of key identifiers
         * ogma.events.onKeyPress(['ctrl', 'b'], function () { console.log('CTRL + B pressed.'); });
         *
         * // By specifying an array of JavaScript codes
         * ogma.events.onKeyPress([17, 66], function () { console.log('CTRL + B pressed.'); });
         */
        onKeyPress(key: string | number | string[] | number[], listener: TypedListener<DomEvent>): Ogma;
        /**
         * @method Ogma.events.onNodesSelected
         * Triggers the specified function when some nodes are selected.
         * @param {function(evt: {nodes: NodeList})} listener
         * @example
         * ogma.events.onNodesSelected(function (evt) {
         *   console.log('Nodes ' + evt.nodes.getId() + ' have just been selected.');
         * });
         */
        onNodesSelected(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodesUnselected
         * Triggers the specified function when some nodes are removed from the selection.
         * @param {function(evt: {nodes: NodeList})} listener
         * @example
         * ogma.events.onNodesUnselected(function (evt) {
         *   console.log('Nodes ' + evt.nodes.getId() + ' have just been unselected.');
         * });
         */
        onNodesUnselected(listener: TypedListener<NodesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesSelected
         * Triggers the specified function when some edges are selected.
         * @param {function(evt: {edges: EdgeList})} listener
         * @example
         * ogma.events.onEdgesSelected(function (evt) {
         *   console.log('Edges ' + evt.edges.getId() + ' have just been selected.');
         * });
         */
        onEdgesSelected(listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgesUnselected
         * @param {function(evt: {edges: EdgeList})} listener
         * @example
         * ogma.events.onEdgesUnselected(function (evt) {
         *   console.log('Edges ' + evt.edges.getId() + ' have just been unselected.');
         * });
         */
        onEdgesUnselected(listener: TypedListener<EdgesEvent>): Ogma;
        /**
         * @method Ogma.events.onNodeDataChange
         * Trigger the specified function when the data of some nodes is updated.
         * @param {function(evt: {changes: Array<{property: PropertyPath, nodes: NodeList, previousValues: Array<any>, newValues: Array<any>}>})} listener
         * @example
         * ogma.events.onNodeDataChange(function (evt) {
         *   evt.changes.forEach(function (change) {
         *     console.log('Property ' + change.property.join('.') + ' changed for nodes ' + change.nodes.getId() + ':');
         *     change.nodes.forEach(function (node, index) {
         *       console.log('Previous value for node ' + node.getId() + ' was ' + change.previousValues[index]);
         *       console.log('New value for node ' + node.getId() + ' is ' + change.newValues[index]);
         *     });
         *   });
         * });
         */
        onNodeDataChange(listener: TypedListener<NodesDataChangeEvent>): Ogma;
        /**
         * @method Ogma.events.onEdgeDataChange
         * Trigger the specified function when the data of some nodes is updated.
         * @param {function(evt: {changes: Array<{property: PropertyPath, edges: EdgeList, previousValues: Array<any>, newValues: Array<any>}>})} listener
         */
        onEdgeDataChange(listener: TypedListener<EdgesDataChangeEvent>): Ogma;
        /**
         * @method Ogma.events.onMouseMove
         * Triggers the specified function when the user moves the mouse (or their finger in touch devices).
         * @param {function(evt: {x: number, y: number, dx: number, dy: number, source: InputSource, domEvent: Event})} listener
         */
        onMouseMove(listener: TypedListener<MouseMoveEvent>): Ogma;
        /**
         * @method Ogma.events.onMouseButtonDown
         * Triggers the specified function when the user presses a mouse button. Also triggers as a left button when the user
         * presses their finger (on touch devices).
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         */
        onMouseButtonDown(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onMouseButtonUp
         * Triggers the specified function when the user releases a mouse button. Also triggers as a left button when the user
         * releases their finger (on touch devices).
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         */
        onMouseButtonUp(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onClick
         * Triggers the specified function when the user presses and releases a mouse button without moving in between.
         * Also triggers as a left button when the user presses and releases their finger (on touch devices).
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         */
        onClick(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onDoubleClick
         * Triggers the specified function when the user presses and releases a mouse button two times without moving the mouse.
         * Also triggers as a left button when the user presses and releases their finger two times (on touch devices).
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         */
        onDoubleClick(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onMouseWheel
         * Triggers the specified function when the user uses the mouse wheel.
         * @param {function(evt: {x: number, y: number, delta: number, domEvent: Event})} listener `delta` is a number between -1 and 1.
         */
        onMouseWheel(listener: TypedListener<WheelEvent>): Ogma;
        /**
         * @method Ogma.events.onHover
         * Triggers the specified function when a node or edge is hovered.
         * @param {function(evt: {x: number, y: number, target: InputTarget, domEvent: Event})} listener
         */
        onHover(listener: TypedListener<HoverEvent>): Ogma;
        /**
         * @method Ogma.events.onUnhover
         * Triggers the specified function when a node or edge stops being hovered.
         * @param {function(evt: {x: number, y: number, target: InputTarget, domEvent: Event})} listener
         */
        onUnhover(listener: TypedListener<HoverEvent>): Ogma;
        /**
         * @method Ogma.events.onDragStart
         * Triggers the specified function when the user presses a mouse button and then moves the mouse (without
         * releasing the button).
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         */
        onDragStart(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onDragProgress
         * Triggers the specified function every time the user moves the mouse after a `onDragStart` event has been emitted,
         * as long as the user doesn't release the mouse.
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         * If a node or edge was under the cursor when the first `onDragStart` event was emitted, it is passed as the `target` property.
         */
        onDragProgress(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onDragEnd
         * Triggers the specified function when the user releases a mouse button, if a `onDragStart` has been emitted before.
         * @param {function(evt: {x: number, y: number, target: InputTarget, button: MouseButton, source: InputSource, domEvent: Event})} listener
         * If a node or edge was under the cursor when the first `onDragStart` event was emitted, it is passed as the `target` property.
         */
        onDragEnd(listener: TypedListener<MouseButtonEvent>): Ogma;
        /**
         * @method Ogma.events.onGestureStart
         * Triggers the specified function when the user touch the screen with two fingers.
         * @param {function(evt: {domEvent: Event})} listener
         */
        onGestureStart(listener: TypedListener<DomEvent>): Ogma;
        /**
         * @method Ogma.events.onGestureProgress
         * Triggers the specified function when the users moves two fingers.
         * @param {function(evt: {x: number, y: number, scale: number, angle: number, dx: number, dy: number, domEvent: Event})} listener
         */
        onGestureProgress(listener: TypedListener<GestureProgressEvent>): Ogma;
        /**
         * @method Ogma.events.onGestureEnd
         * Triggers the specified function when the user stop touching the screen with two fingers.
         * @param {function(evt: {domEvent: Event})} listener
         */
        onGestureEnd(listener: TypedListener<DomEvent>): Ogma;
        /**
         * @method Ogma.events.onRendererStateChange
         * Triggered when the renderer is requested, successfully initialized or encounters an error.
         * @param {function (evt: {type: RendererType, state: RendererState, code: RendererErrorCode, message: string})} listener
         */
        onRendererStateChange(listener: TypedListener<RenderStateChangeEvent>): Ogma;
        /**
         * @method Ogma.events.onZoomProgress
         * Triggers the specified function when zoom animation is in progress
         * @param {function()} listener
         */
        onZoomProgress(listener: () => void): Ogma;
        /**
         * @method Ogma.events.onViewChanged
         * Triggers the specified function when a camera movement (zoom, panning, rotation) is finished.
         * @param {function()} listener
         *
         * @example
         * ogma.events.onViewChanged(function() {
         *   console.log('zoomed and re-centered');
         * });
         *
         * ogma.view.setCenter({ x: 100, y: 100 });
         * ogma.view.setZoom(5);
         */
        onViewChanged(listener: () => void): Ogma;
        /**
         * @method Ogma.events.onNodesConnected
         * Trigger the specified function when two nodes are connected using the module.
         * @param {function(evt: {source: Node, target: Node, edge: Edge })} listener
         *
         * @example
         * ogma.events.onNodesConnected(function(evt) {
         *   evt.source.setAttributes({ text: 'Source'});
         *   evt.target.setAttributes({ text: 'Target'});
         *   evt.edge.setAttributes({ text: 'Connection'});
         * });
         */
        onNodesConnected(listener: TypedListener<NodesConnectionEvent>): Ogma;
        /**
         * @method Ogma.events.onGeoModeEnabled
         * Triggered when the geo mode is activated
         * @param {function()} listener
         *
         * @example
         * ogma.events.onGeoModeEnabled(function() {
         *   console.log('geo mode is on');
         * });
         * ogma.geo.enable();
         * // 'geo mode is on'
         */
        onGeoModeEnabled(listener: () => void): Ogma;
        /**
         * @method Ogma.events.onGeoModeDisabled
         * Triggered when the geo mode is switched off
         * @param {function()} listener
         *
         * @example
         * ogma.events.onGeoModeDisabled(function() {
         *   console.log('geo mode is off');
         * });
         * ogma.geo.disable();
         * // 'geo mode is off'
         */
        onGeoModeDisabled(listener: () => void): Ogma;
        /**
         * @method Ogma.events.onGeoModeLoaded
         * Triggered when the background map images are loaded
         * @param {function()} listener
         *
         * @example
         * ogma.events.onGeoModeLoaded(function() {
         *   console.log('the base map is loaded');
         * });
         * ogma.geo.enable();
         * // 'the base map is loaded'
         */
        onGeoModeLoaded(listener: () => void): Ogma;
        /**
         * @method Ogma.events.onLayoutStart
         * @param {function(evt: { name: string, ids: Array<NodeId>})} listener
         *
         * @example
         * ogma.events.onLayoutStart(function(evt) {
         *   console.log('Running layout ', evt.name, 'on nodes', evt.ids.join(','));
         * });
         * ogma.layouts.forceLink();
         */
        onLayoutStart(listener: TypedListener<LayoutStartEvent>): Ogma;
        /**
         * @method Ogma.events.onLayoutComplete
         * @param {function(evt: { name: string, ids: Array<NodeId>, positions: { before: Array<{x: number, y: number}>, after: Array<{x: number, y: number}>}})} listener
         *
         * @example
         * ogma.events.onLayoutComplete(function(evt) {
         *   console.log('Layout ', evt.name, 'worked on nodes', evt.ids.join(','));
         * });
         * ogma.layouts.forceLink();
         */
        onLayoutComplete(listener: TypedListener<LayoutCompleteEvent>): Ogma;
        /**
         * @method Ogma.events.onLayoutComputed
         *
         * This event is fired after the layout algorithm has finished the calculations,
         * but before the positions are applied. Use it for UI interactions, because if
         * you would add position manipulations into the listener, they can interfere
         * with the layout results.
         *
         * @param {function(payload: { name: string })} listener
         *
         * @example
         * ogma.events.onLayoutStart(function(evt) {
         *   showProgressBar(evt.ids);
         * });
         * // hide the progress bar before the position animation starts
         * ogma.events.onLayoutComplete(function() {
         *   hideProgressBar();
         * });
         */
        onLayoutComputed(listener: TypedListener<LayoutComputedEvent>): Ogma;
        /**
         * @method Ogma.events.onTooltipShown
         * Triggers the specified function when a tooltip is shown.
         * @param {function (evt: {tooltip: HTMLElement})} listener
         * @example
         * ogma.events.onTooltipShown(function (evt) {
         *   console.log('Tooltip shown:', evt.tooltip.innerHTML);
         * });
         */
        onTooltipShown(listener: TypedListener<TooltipEvent>): Ogma;
        /**
         * @method Ogma.events.onTooltipHidden
         * Triggers the specified function when a tooltip is hidden.
         * @param {function (evt: {tooltip: HTMLElement})} listener
         */
        onTooltipHidden(listener: (evt: TypedListener<TooltipEvent>) => void): Ogma;
    };
    export default class EventsAPI {
        events: ReturnType<typeof createEventsAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}

declare module "api/exports/options" {
    import { NodeCollection, EdgeCollection, Filter } from "types/utilities";
    export interface ExportOptions {
        download?: boolean;
        filename?: string;
    }
    export interface DataExportOptions extends ExportOptions {
        nodes?: NodeCollection;
        edges?: EdgeCollection;
        nodeData?: (data: any) => any;
        edgeData?: (data: any) => any;
        filter?: Filter;
        styles?: 'all' | 'none' | 'original';
    }
}
declare module "api/exports/csv" {
    import Ogma from "src/ogma";
    import { PropertyPath } from "api/data";
    import { DataExportOptions } from "api/exports/options";
    export interface CSVExportOptions extends DataExportOptions {
        what?: 'nodes' | 'edges';
        dataProperties?: PropertyPath[];
        separator?: string;
        textSeparator?: '"' | "'";
    }
    const _default_1: (ogma: Ogma) => {
        /**
         * @method Ogma.export.csv
         * @param {object|"nodes"|"edges"} parameters
         * @param {"nodes"|"edges"} parameters.what Indicates if nodes or edges should be exported.
         * @param {Array<PropertyPath>} [parameters.dataProperties] Data properties to export. If not specified, exports all data properties.
         * @param {string} [parameters.separator=","] Column separator
         * @param {'"'|"'"} [parameters.textSeparator='"'] String used to surround strings. Can only be `"` or `'`.
         * @param {NodeCollection} [parameters.nodes] Nodes to export. By default export all the nodes (if `what` is `"nodes"`).
         * @param {EdgeCollection} [parameters.edges] Edges to export. By default export all the edges (if `what` is `"edges"`).
         * @param {function (data: any): any} [parameters.nodeData] Given a node data in input, must return the object to export as data. By default export the whole node data untouched.
         * @param {function (data: any): any} [parameters.edgeData] Given an edge data in input, must return the object to export as data. By default export the whole edge data untouched.
         * @param {Filter} [parameters.filter="visible"] Indicates what elements to export.
         * @param {boolean} [parameters.download=true] If true, the user will be prompted a modal window so he can download the exported graph.
         * @param {string} [parameters.filename="graph.csv"] If `download` is true, the default name for the downloaded file.
         * @return {Promise<string>}
         *
         * @example
         * // export only nodes with higher degree
         * console.log(ogma.getNode('n2').getData());
         * // { properties: { foo: 1, bar: 2 } }
         * ogma.export.csv({
         *   nodes: ogma.getNodes(function(node) {
         *     return node.getDegree() > 2;
         *   }),
         *   dataProperties: ['customerProperties', ['a', 'single', 'nested', 'property'], 'another.nested.property', ['property.containing.dots']],
         *   download: false,
         *   what: 'nodes'
         * }).then(function(csv) {
         *   console.log(csv);
         *   // "id","foo","bar"
         *   // "0","1","2"
         * })
         */
        csv: (parameters: "nodes" | "edges" | CSVExportOptions) => Promise<string>;
    };
    export default _default_1;
}
declare module "utils/defaultColors" {
    import { Color } from "types/utilities";
    /**
     * @public
     * @typedef {null|string} Color CSS color name (e.g `"red"`), `"transparent"`, rgb(a) notation (e.g: `"rgb(128, 128, 128)"` or `"rgba(128, 128, 128, 0.2)"`), hexadecimal notation (e.g: `"#FFFFFF"`) or `null` (transparent).
     */
    export const CSS_COLORS: Color[];
}


declare module "api/exports/gexf" {
    import Ogma from "src/ogma";
    import { DataExportOptions } from "api/exports/options";
    export interface GexfExportOptions extends DataExportOptions {
        creator?: string;
        description?: string;
    }
    const _default_2: (ogma: Ogma) => {
        /**
         * @method Ogma.export.gexf
         * @param {object} [parameters]
         * @param {string} [parameters.creator] Name of the creator, that will be specified in the output file
         * @param {string} [parameters.description] Description of the graph, that will be specified in the output file
         * @param {NodeCollection} [parameters.nodes] Nodes to export. By default export all the nodes.
         * @param {EdgeCollection} [parameters.edges] Edges to export. By default export all the edges.
         * @param {function (data: any): any} [parameters.nodeData] Given a node data in input, must return the object to export as data. By default export the whole node data untouched.
         * @param {function (data: any): any} [parameters.edgeData] Given an edge data in input, must return the object to export as data. By default export the whole edge data untouched.
         * @param {Filter} [parameters.filter="visible"] Indicates what elements to export.
         * @param {"all"|"none"|"original"} [parameters.styles="all"] Indicates what styles (color, shape, size, text) should be exported: `'all'` for what is visually displayed, `'none'` for no style and `'original'` for the values provided at initialization.
         * @param {boolean} [parameters.download=true] If true, the user will be prompted a modal window so he can download the exported graph.
         * @param {string} [parameters.filename="graph.gexf"] If `download` is true, the default name for the downloaded file.
         * @return {Promise<string>}
         *
         * @example
         * ogma.export.gexf({
         *   creator: 'ogma'
         * }).then(function() {
         *   console.log('graph was saved in graph.gexf');
         * });
         */
        gexf: (parameters?: GexfExportOptions) => Promise<string>;
    };
    export default _default_2;
}
declare module "api/exports/graphml" {
    import Ogma from "src/ogma";
    import { DataExportOptions } from "api/exports/options";
    export interface GraphMLExportOptions extends DataExportOptions {
        graphId?: string;
        directedEdges?: boolean;
    }
    const _default_3: (ogma: Ogma) => {
        /**
         * @method Ogma.export.graphml
         * @param {object} [parameters]
         * @param {string} [parameters.graphId="G"] Id of the graph to write in the output file
         * @param {boolean} [parameters.directedEdges=true] Indicates in the output file if the edges are directed or not
         * @param {NodeCollection} [parameters.nodes] Nodes to export. By default export all the nodes.
         * @param {EdgeCollection} [parameters.edges] Edges to export. By default export all the edges.
         * @param {function (data: any): any} [parameters.nodeData] Given a node data in input, must return the object to export as data. By default export the whole node data untouched.
         * @param {function (data: any): any} [parameters.edgeData] Given an edge data in input, must return the object to export as data. By default export the whole edge data untouched.
         * @param {Filter} [parameters.filter="visible"] Indicates what elements to export.
         * @param {"all"|"none"|"original"} [parameters.styles="all"] Indicates what styles (color, shape, size, text) should be exported: `'all'` for what is visually displayed, `'none'` for no style and `'original'` for the values provided at initialization.
         * @param {boolean} [parameters.download=true] If true, the user will be prompted a modal window so he can download the exported graph.
         * @param {string} [parameters.filename="graph.graphml"] If `download` is true, the default name for the downloaded file.
         * @return {Promise<string>}
         *
         * @example
         * var filename = 'my-graph.graphml';
         * ogma.export.graphml({
         *   filename: filename
         * }).then(function() {
         *   console.log('graph was saved in', filename);
         * });
         */
        graphml: (parameters?: GraphMLExportOptions) => Promise<string>;
    };
    export default _default_3;
}
declare module "api/exports/utils/collections" {
    import { NodeId, EdgeId, NodeCollection, EdgeCollection } from "types/utilities";
    export function nodeCollectionToSelector(collection: NodeCollection): NodeId[];
    export function edgeCollectionToSelector(collection: EdgeCollection): EdgeId[];
}
declare module "api/exports/json" {
    import Ogma from "src/ogma";
    import { ExportOptions } from "api/exports/options";
    import { PropertyPath } from "api/data";
    import { Filter, NodeCollection, EdgeCollection } from "types/utilities";
    export interface JSONExportOptions extends ExportOptions {
        nodeAttributes?: PropertyPath[] | 'all';
        edgeAttributes?: PropertyPath[] | 'all';
        nodeData?: (data: any) => any;
        edgeData?: (data: any) => any;
        filter?: Filter | {
            nodes: NodeCollection;
            edges: EdgeCollection;
        };
        pretty?: boolean;
    }
    const _default_4: (ogma: Ogma) => {
        /**
         * @method Ogma.export.json
         * @param {object} [parameters]
         * @param {Array<PropertyPath>|"all"} [parameters.nodeAttributes] List of node attributes to export. By default, export position, color, shape, text and radius.
         * @param {Array<PropertyPath>|"all"} [parameters.edgeAttributes] List of edge attributes to export. By default, export color, text and width.
         * @param {function (data: any): any} [parameters.nodeData] Given a node data in input, must return the object to export as data. By default export the whole node data untouched.
         * @param {function (data: any): any} [parameters.edgeData] Given an edge data in input, must return the object to export as data. By default export the whole edge data untouched.
         * @param {Filter|{nodes: NodeCollection, edges: EdgeCollection}} [parameters.filter="visible"] Indicates what elements to export.
         * @param {boolean} [parameters.pretty=false] Indicates if the output should be properly indented.
         * @param {boolean} [parameters.download=true] If true, the user will be prompted a modal window so he can download the exported graph.
         * @param {string} [parameters.filename="graph.json"] If `download` is true, the default name for the downloaded file.
         * @return {Promise<string>}
         *
         * @example
         * // post graph to the HTTP API
         * ogma.export.json().then(function(json) {
         *   var xhr = new XMLHttpRequest();
         *   xhr.open("POST", '/your/storage/api/', true);
         *   xhr.setRequestHeader("Content-type", "application/json");
         *   xhr.onreadystatechange = function() {
         *     if (xhr.readyState === 4 && xhr.status === 200) {
         *       console.log('sent');
         *     }
         *   };
         *   xhr.send(graph);
         * });
         */
        json: (parameters?: JSONExportOptions) => Promise<string>;
    };
    export default _default_4;
}
declare module "api/exports/utils/images" {
    import Ogma from "src/ogma";
    import { ImageExportOptions } from "api/exports/png";
    import { Color } from "types/utilities";
    export interface ExportView {
        width: number;
        height: number;
        pixelRatio: number;
        backgroundColor: Color;
        zoom: number;
        x: number;
        y: number;
        hideImages: boolean;
    }
    export function computeViewForExport(ogma: Ogma, parameters: ImageExportOptions): ExportView;
    export function exportToImage(ogma: Ogma, parameters: any, view: any, renderer: any, hideImages?: boolean): any;
}
declare module "api/tools/legend" {
    import Ogma from "src/ogma";
    import { Color } from "types/utilities";
    /**
     * @public
     * @typedef {object}  LegendOptions
     * @property {"bottom"|"top"|"left"|"right"} [position="bottom"] Position of the legend on the canvas.
     * @property {number} [widgetWidth=130] Width of a widget, in pixels
     * @property {string} [fontFamily="Arial"] Font used to display the widgets
     * @property {number} [fontSize=10] Font size used to display the widgets' content
     * @property {Color} [fontColor="black"] Font color used to display the widgets' content
     * @property {number} [titleFontSize=12] Font size used to display the widgets' title
     * @property {Color} [titleFontColor="black"] Font color used to display the widgets' title
     * @property {number} [titleMaxLength=20] If a widget's title has more characters that this value, it will be truncated
     * @property {"left"|"center"} [titleTextAlign="left"] Alignment of the widgets' title
     * @property {Color} [shapeColor="grey"] Color used for displaying the widget indicating a node or edge shape
     * @property {Color} [backgroundColor="white"] Background color of the widgets.
     * @property {Color} [borderColor="black"] Border color of the widgets.
     * @property {number} [borderRadius=0] Border radius of the widgets.
     * @property {number} [borderWidth=1] Border width of the widgets, in pixels.
     * @property {number} [innerMargin=10] Blank space between a widget's border and its content, in pixels.
     * @property {number} [outerMargin=5] Blank space between two widgets, in pixels.
     * @property {number} [circleStrokeWidth=3] Stroke width of the circles used to indicate the size of the nodes.
     * @property {function(propertyPath: Array<string>): string} [titleFunction] Given a property path, must return
     * the title of the widget which displays information on that property. By default keep the last part of the
     * property path.
     */
    export interface LegendOptions {
        position?: 'bottom' | 'top' | 'left' | 'right';
        widgetWidth?: number;
        fontFamily?: string;
        fontSize?: number;
        fontColor?: Color;
        titleFontSize?: number;
        titleFontColor?: Color;
        titleMaxLength?: number;
        titleTextAlign?: 'left' | 'center';
        shapeColor?: Color;
        backgroundColor?: Color;
        borderColor?: Color;
        borderRadius?: number;
        borderWidth?: number;
        innerMargin?: number;
        outerMargin?: number;
        circleStrokeWidth?: number;
        titleFunction?: (propertyPath: string[]) => string;
    }
    const _default_5: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.legend.enable
         * Enable the legend. Provides indications on the meaning of the color, size, shape, image and icon of nodes
         * and edges.
         *
         * <bold>Important! In order to be generated for a specific attribute (color, size, etc), the following
         * requirements must be met:</bold>
         * <ul>
         *   <li>There must be exactly one rule for that attribute. If there are multiple rules for an attribute, only
         *   the first one is taken into account (which may lead to an incorrect legend)</li>
         *   <li>This rule must have been created with `ogma.rules.map()` or `ogma.rules.slice()`. If it's not the
         *   case, the widget for this attribute will not be shown.</li>
         * </ul>
         *
         * @param {LegendOptions} [options]
         * @returns {Promise<void>}
         * @example
         * var colorRule = ogma.rules.map({
         *   field: 'country',
         *   values: {
         *     France: 'blue',
         *     Italy: 'green',
         *     Spain: 'red'
         *   },
         *   fallback: 'black'
         * });
         *
         * ogma.styles.addNodeRule({
         *   color: colorRule
         * });
         *
         * ogma.tools.legend.enable({
         *   position: 'left',
         *   borderColor: 'grey',
         *   titleFunction: function (propertyPath) {
         *     // propertyPath is an array
         *     return propertyPath.join('.');
         *   }
         * });
         */
        enable(options: LegendOptions): Promise<void>;
        /**
         * @method Ogma.tools.legend.disable
         * Disable the legend.
         * @example
         * ogma.tools.legend.disable();
         */
        disable(): void;
        /**
         * @method Ogma.tools.legend.enabled
         * Indicates if the legend is enabled.
         * @return {boolean}
         * @example
         * console.log(ogma.tools.legend.enabled());
         */
        enabled(): boolean;
    };
    export default _default_5;
}
declare module "api/exports/png" {
    import Ogma from "src/ogma";
    import { ExportOptions } from "api/exports/options";
    import { Color, Filter, CrossOriginValue } from "types/utilities";
    import { LegendOptions } from "api/tools/legend";
    export type ImageFormat = 'jpg' | 'gif' | 'png' | 'tiff';
    /**
     * @public
     * @typedef  {object}           ImageExportOptions
     * @property {boolean}          [clip=false] If `true`, export the current view rather than the whole graph
     * @property {number}           [width] If not specified, the width of the canvas will be used.
     * @property {number}           [height] If not specified, the height of the canvas will be used.
     * @property {number}           [margin=10] Blank space around the graph (in pixels)
     * @property {Color}            [background] Color of the background on the output image
     * @property {boolean}          [texts=true]                    Whether or not to export texts
     * @property {boolean}          [images=true]                   Whether or not to export images
     * @property {boolean}          [badges=true]                   Whether or not to export badges
     * @property {"visible"|"all"}  [filter="visible"]              Indicates what elements to export.
     * @property {object}           [textWatermark]
     * @property {string}           [textWatermark.content]           Content of the text watermark
     * @property {string}           [textWatermark.fontFamily="Arial"]  Font used to display the text watermark
     * @property {number}           [textWatermark.fontSize=48]       Size of the text watermark
     * @property {"bold"|"italic"}  [textWatermark.fontStyle] Style to use to display the text watermark
     * @property {Color}            [textWatermark.fontColor="red"]    Color to use to display the text watermark
     * @property {boolean}          [textWatermark.repeat=false]     Indicates if the watermark should be repeated over the image
     * @property {number}           [textWatermark.angle=0]           Angle of the watermark (in degrees)
     * @property {number}           [textWatermark.alpha=0.65]        Transparency of the watermark, from 0 to 1 (0 = fully transparent)
     * @property {number}           [textWatermark.space=50]          If repeating the watermark, space in pixels between the repetitions
     * @property {number}           [textWatermark.x]                 X coordinate of the center of the watermark
     * @property {number}           [textWatermark.y]                 Y coordinate of the center of the watermark
     * @property {object}           [imageWatermark]
     * @property {string}           [imageWatermark.url]              Url of the image to use as watermark
     * @property {string}           [imageWatermark.width]            If not specified, the original width of the image will be used.
     * @property {string}           [imageWatermark.height]           If not specified, the original width of the image will be used.
     * @property {string}           [imageWatermark.repeat=false]     Indicates if the watermark should be repeated over the image
     * @property {string}           [imageWatermark.angle=0]          Angle of the watermark (in degrees)
     * @property {string}           [imageWatermark.alpha=0.65]       Transparency of the watermark, from 0 to 1 (0 = fully transparent)
     * @property {string}           [imageWatermark.space=50]         If repeating the watermark, space in pixels between the repetitions
     * @property {string}           [imageWatermark.x]                X coordinate of the center of the watermark
     * @property {string}           [imageWatermark.y]                Y coordinate of the center of the watermark
     * @property {boolean}          [download=true] If true, the user will be prompted a modal window so he can download the exported graph.
     * @property {string}           [filename="graph.png"] If `download` is true, the default name for the downloaded file.
     * @property {boolean|LegendOptions} [legend] If unspecified and the legend is enabled, it will be exported with the current options.
     * If unspecified and the legend is not enabled, it will not be exported. If `false`, the legend will not be exported no matter what.
     * If `true`, the legend will be exported with the default options, whether it's enabled or not. If an object is specified,
     * the legend will be exported with the specified options, whether it's enabled or not.
     * @property {string}           [imageCrossOrigin]                In case node or badge images are coming from a CDN, set this to
     *                                                              'anonymous' to avoid security errors on export.
     */
    export interface ImageExportOptions extends ExportOptions {
        texts?: boolean;
        images?: boolean;
        badges?: boolean;
        filter?: Filter;
        clip?: boolean;
        width?: number;
        height?: number;
        margin?: number;
        background?: Color;
        legend?: boolean | LegendOptions;
        imageCrossOrigin?: CrossOriginValue;
        imageWatermark?: {
            x?: number;
            y?: number;
            space?: number;
            angle?: number;
            alpha?: number;
            repeat?: boolean;
            width?: number;
            height?: number;
            url?: string;
        };
        textWatermark?: {
            x?: number;
            y?: number;
            angle?: number;
            space?: number;
            alpha?: number;
            repeat?: boolean;
            content: string;
            fontFamily?: string;
            fontSize?: number;
            fontStyle?: 'bold' | 'italic';
            fontColor?: Color;
        };
    }
    const _default_6: (ogma: Ogma) => {
        /**
         * @method Ogma.export.png
         * @param {ImageExportOptions} [options]
         * @return {Promise<string>} The argument of the Promise  is the data url of the output image
         *
         * @example
         * ogma.export.png({ download: false }).then(function(base64) {
         *   var img = new Image();
         *   img.src = base64;
         *   document.body.appendChild(img);
         * });
         *
         * @example
         * // Node.js - store the image on the disk
         * // make sure that 'canvas' package is available before you create an Ogma instance
         * var fs = require('fs');
         * ogma.exports.png({ download: false })
         *   .then(function(base64Str) {
         *     var base64 = base64Str.replace(/^data:image\/png;base64,/, '');
         *     fs.writeFileSync('graph.png', base64, 'base64');
         *   });
         */
        png: (options?: ImageExportOptions) => Promise<string>;
        /**
         * @method Ogma.export.jpg
         * @param {ImageExportOptions} [options]
         * @return {Promise<string>} The argument of the Promise  is the data url of the output image
         *
         * @example
         * ogma.exports.jpg({
         *   download: false,
         *   clip: true // would export the viewport as is
         * }).then(function(base64) {
         *   var img = new Image();
         *   img.src = base64;
         *   document.body.appendChild(img);
         * });
         */
        jpg: (options?: ImageExportOptions) => Promise<string>;
        /**
         * @method Ogma.export.tiff
         * @param {ImageExportOptions} [options]
         * @return {Promise<string>} The argument of the Promise is the data url of the output image
         *
         * @example
         * var filename = 'graph-1.tiff';
         * ogma.exports.tiff({ filename: filename }).then(function() {
         *   console.log('graph was exported as', filename);
         * });
         */
        tiff: (options?: ImageExportOptions) => Promise<string>;
        /**
         * @method Ogma.export.gif
         * @param {ImageExportOptions} [options]
         * @return {Promise<string>} The argument of the Promise  is the data url of the output image
         *
         * @example
         * // will export graph as a gif with text watermark over it
         * // and put it at the bottom of the page
         * ogma.exports.tiff({
         *   download: false,
         *   textWatermark: {
         *     content: 'classified'
         *   }
         * }).then(function(base64) {
         *   var img = new Image();
         *   img.src = base64;
         *   document.body.appendChild(img);
         * });
         */
        gif: (options?: ImageExportOptions) => Promise<string>;
    };
    export default _default_6;
}

declare module "api/exports/svg" {
    import Ogma from "src/ogma";
    import { ExportOptions } from "api/exports/options";
    import { Color } from "types/utilities";
    export interface SVGExportOptions extends ExportOptions {
        width?: number;
        height?: number;
        clip?: boolean;
        margin?: number;
        background?: Color;
        texts?: boolean;
        images?: boolean;
        embedFonts?: boolean;
        badges?: boolean;
        prefix?: string;
    }
    const _default_7: (ogma: Ogma) => {
        /**
         * @method Ogma.export.svg
         * @param {object}  [parameters]
         * @param {number}  [parameters.width]            If not specified, the width of the canvas will be used.
         * @param {number}  [parameters.height]           If not specified, the height of the canvas will be used.
         * @param {boolean} [parameters.clip=false]       Whether to clip the exported image to the current Ogma viewport.
         * @param {number}  [parameters.margin=10]        Additional margin.
         * @param {Color}   [parameters.background]       Color of the background
         * @param {boolean} [parameters.texts=true]       whether or not to export texts
         * @param {boolean} [parameters.images=true]      Indicates if images should be exported.
         * @param {boolean} [parameters.badges=true]      Whether or not to export badges
         * @param {boolean} [parameters.embedFonts=false] Whether or not to embed custom fonts as base64
         *                                                (works in viewers and browsers, but in order to edit
         *                                                you will have to install the fonts on your machine anyway).
         *                                                Otherwise the custom fonts will be just linked in the file.
         * @param {boolean} [parameters.download=true]    If true, the user will be prompted a modal window so he can
         *                                                download the exported graph.
         * @param {string} [parameters.filename="graph.svg"] If `download` is true, the default name for the downloaded file.
         * @param {string} [parameters.prefix='ogma']     Prefix for the entity class names. For example, elements belonging
         *                                                to a node are grouped into an SVG group with the class `ogma-node`
         *                                                and an attribute `data-node-id` with the (escaped) node id. The word
         *                                                `ogma` in these class names can be replaced by a custom string.
         * @return {Promise<string>} The argument is the SVG string
         *
         * @example
         * ogma.export.svg({
         *   download: false,
         *   width:    500,
         *   height:   500
         * }).then(function(svg) {
         *   document.getElementById('container').innerHTML = svg;
         * });
         */
        svg: (parameters?: SVGExportOptions) => Promise<string>;
    };
    export default _default_7;
}
declare module "api/exports/xlsx" {
    import Ogma from "src/ogma";
    import { ExportOptions } from "api/exports/options";
    import { PropertyPath } from "api/data";
    import { Filter, NodeCollection, EdgeCollection } from "types/utilities";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    export interface XLSXExportOptions extends ExportOptions {
        what?: 'nodes' | 'edges';
        dataProperties?: PropertyPath[];
        filter?: Filter;
        nodes?: NodeCollection;
        edges?: EdgeCollection;
        tab?: {
            nodes: (node: Node) => string | string[] | undefined;
            edges: (edge: Edge) => string | string[] | undefined;
        };
        nodeData?: (data: any, allTabs: string[]) => object | object[] | undefined;
        edgeData?: (data: any, allTabs: string[]) => object | object[] | undefined;
    }
    const _default_8: (ogma: Ogma) => {
        /**
         * @method Ogma.export.xlsx
         * Requires the xlsx library to be included (if browser) or to be available through 'require' (if Node.js)
         * @param {object|"nodes"|"edges"} [parameters]
         * @param {"nodes"|"edges"} [parameters.what] If a value is specified, only nodes or edges will be exported, not both.
         * @param {Array<PropertyPath>} [parameters.dataProperties] Data properties to export. If not specified, exports all data properties. Deprecated : use `nodeData` and `edgeData` instead.
         * @param {Filter} [parameters.filter="visible"] Indicates what elements to export.
         * @param {NodeCollection} [parameters.nodes] Nodes to export. By default export all the nodes. When set it overwrites "filter" configuration.
         * @param {EdgeCollection} [parameters.edges] Edges to export. By default export all the edges. When set it overwrites "filter" configuration.
         * @param {boolean} [parameters.download=true] If true, the user will be prompted a modal window so he can download the exported graph. Browser only.
         * @param {string} [parameters.filename="graph.xlsx"] If `download` is true, the default name for the downloaded file.
         * @param {object} [parameters.tab] Indicates how to name the tabs in the XSLX tabs. When not defined it will exports a "nodes" and a "edges" tab.
         *   **Note**: tab names cannot contain some characters in Excel, for more information please see: [naming conventions for worksheets](http://www.excelcodex.com/2012/06/worksheets-naming-conventions/) .
         * @param {function(node: Node): string|Array<string>|undefined} [parameters.tab.nodes = function(node: Node): "nodes"] The returned string indicates the name of the tab (or tabs) to use for the node. When `undefined` is returned it defaults to "nodes".
         * @param {function(edge: Edge): string|Array<string>|undefined} [parameters.tab.edges = function(edge: Edge): "edges"] The returned string indicates the name of the tab (or tabs) to use for the edge. When `undefined` is returned it defaults to "edges".
         * @param {function(data: any, allTabs: Array<string>): object|Array<object>|undefined} [parameters.nodeData] Indicates how to format the node data for the tab: each key of the returned `object` is used as `columnName` and its value as `columnValue`. In case of multiple tabs for the node, an array of objects will be expected.
         * The `allTabs` array is passed to give some context to the formatting. The default is use the data object "flatten" all his properties. When set it overwrites `dataProperties` configuration.
         * @param {function(data: any, allTabs: Array<string>): object|Array<object>|undefined} [parameters.edgeData] Indicates how to format the edge data for the tab: each key of the returned `object` is used as `columnName` and its value as `columnValue`. In case of multiple tabs for the edge, an array of objects will be expected.
         * The `allTabs` array is passed to give some context to the formatting. The default is use the data object "flatten" all his properties. When set it overwrites `dataProperties` configuration.
         * @return {Promise<Blob>}
         *
         * @example
         * var filename = "file.xlsx";
         * ogma.export.xlsx({ filename: filename, filter: "visible" }).then(function() {
         *   console.log('Visible graph exported into', filename)
         * });
         *
         * @example
         * // Advanced example where tabs are based on nodes and edges properties
         * var filename = "file.xlsx";
         * ogma.export.xlsx({
         *   filename: filename,
         *   tab: {
         *     nodes: function(node){ return node.getData("type"); },
         *     edges: function(edge){ return edge.getData("type"); },
         *   }
         * }).then(function() {
         *   console.log('Graph exported: 1 tab for each node and edge type into', filename)
         * });
         *
         *
         * @demo export-excel
         * @demo export-excel-advanced
         */
        xlsx: (parameters: XLSXExportOptions) => Promise<Blob>;
    };
    export default _default_8;
}
declare module "api/exports/index" {
    import Ogma from "src/ogma";
    const createExportAPI: (ogma: Ogma) => {
        xlsx: (parameters: import("api/exports/xlsx").XLSXExportOptions) => Promise<Blob>;
        svg: (parameters?: import("api/exports/svg").SVGExportOptions) => Promise<string>;
        png: (options?: import("api/exports/png").ImageExportOptions) => Promise<string>;
        jpg: (options?: import("api/exports/png").ImageExportOptions) => Promise<string>;
        tiff: (options?: import("api/exports/png").ImageExportOptions) => Promise<string>;
        gif: (options?: import("api/exports/png").ImageExportOptions) => Promise<string>;
        json: (parameters?: import("api/exports/json").JSONExportOptions) => Promise<string>;
        graphml: (parameters?: import("api/exports/graphml").GraphMLExportOptions) => Promise<string>;
        gexf: (parameters?: import("api/exports/gexf").GexfExportOptions) => Promise<string>;
        csv: (parameters: "nodes" | "edges" | import("api/exports/csv").CSVExportOptions) => Promise<string>;
    };
    export default class ExportsAPI {
        export: ReturnType<typeof createExportAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/generators" {
    import Ogma from "src/ogma";
    import { RawGraph } from "types/utilities";
    const createGeneratorsAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.generate.balancedTree
         * Generates a simple balanced tree.
         * Source: https://github.com/gka/randomgraph.js (license: public domain)
         * @param {object} [options]
         * @param {number} [options.children=2] The number of children each node has.
         * @param {number} [options.height=3] The height of the tree.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.balancedTree({
         *   children: 2,
         *   height: 3
         * }).then(function(rawGraph) {
         *   ogma.setGraph(rawGraph);
         *   console.log(ogma.getNodes().size);  // 15
         *   console.log(ogma.getEdges().size);  // 14
         * });
         */
        balancedTree: (options: {
            children?: number;
            height?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.barabasiAlbert
         * Generates a scale-free graph using preferntial-attachment mechanism.
         * See <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model (Wikipedia)</a>
         *
         * @param {object} [options]
         * @param {number} [options.nodes=40]   Number of nodes in the graph.
         * @param {number} [options.m0=5]       m0 > 0 && m0 <  nodes
         * @param {number} [options.m=1]        m  > 0 && m <= m0
         * @param {number} [options.scale=100]  scale > 0 Scale of the space used by graph.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.barabasiAlbert({
         *   nodes: 2,
         *   scale: 3
         * }).then(function(rawGraph) {
         *   ogma.setGraph(rawGraph);
         *   console.log(ogma.getNodes().size);  // 15
         *   console.log(ogma.getEdges().size);  // 14
         * });
         */
        barabasiAlbert: (options: {
            nodes?: number;
            m0?: number;
            m?: number;
            scale?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.erdosRenyi
         * Generates an Erdős–Rényi graph. Call it with options (n,p) or (n,m).
         * Source: https://github.com/gka/randomgraph.js (license: public domain)
         * See <a href="https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model">Erdős–Rényi model (Wikipedia)</a>
         *
         * @param {object} [options]
         * @param {number} [options.nodes=20] The number of nodes.
         * @param {number} [options.p=0.1] The probability [0..1] of a edge between any two nodes. If specified, `edges` must not be specified.
         * @param {number} [options.edges] The number of edges. If specified, `p` must not be specified.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.erdosRenyi({
         *   nodes: 15,
         *   p:       0.5
         * }).then(function(rawGraph) {
         *   console.log(rawGraph.nodes.length); // 15
         *   console.log(rawGraph.edges.length); // ~50-60
         *   ogma.setGraph(rawGraph);
         *   ogma.view.locateGraph();
         * });
         */
        erdosRenyi: (options: {
            nodes?: number;
            p?: number;
            edges?: number;
        }) => Promise<RawGraph>;
        /**
         * Generates a tree, with each node positioned at the center of its children,
         * @param {object} options
         * @param {number} [options.depth=3]    Depth of the tree
         * @param {number} [options.breadth=3]  Number of children for each node
         * @param {number} [options.nbNodes]    If specified, the breadth is set to 5 and the depth is computed in
         * order to have the right amount of nodes.
         * @return {RawGraph}
         */
        flower: (options: {
            depth?: number;
            breadth?: number;
            nbNodes?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.grid
         * Generates a grid.
         * @param {object} [options]
         * @param {number} [options.rows=4] The number of rows in the graph.
         * @param {number} [options.columns=4] The number of columns in the graph.
         * @param {number} [options.columnDistance=20] Distance between two columns of nodes
         * @param {number} [options.rowDistance=20] Distance between two rows of nodes
         * @param {number} [options.xmin=0] Start X coordinate for the grid
         * @param {number} [options.ymin=0] Start Y coordinate for the grid.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.grid({
         *   rows:    3
         *   columns: 5
         * }).then(function(rawGraph) {
         *   console.log(rawGraph.nodes.length); // 15
         *   console.log(rawGraph.edges.length); // 22
         *   ogma.setGraph(rawGraph);
         *   ogma.view.locateGraph();
         * });
         */
        grid: (options: {
            rows?: number;
            columns?: number;
            columnDistance?: number;
            rowDistance?: number;
            xmin?: number;
            ymin?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.path
         * Generates a path.
         * @param {object} [options]
         * @param {number} [options.length=5] Number of nodes.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.path({ length: 5 }).then(function(rawGraph) {
         *   console.log(rawGraph.nodes.length, 'nodes, connected by', rawgraph.edges.length, 'edges');
         *   // 5 nodes, connected by 4 edges
         * });
         */
        path: (options: {
            length?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.random
         * Generates a random graph.
         * @param {object} [options]
         * @param {number} [options.nodes=10] Number of nodes.
         * @param {number} [options.edges=10] Number of edges.
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.random().then(function(rawGraph) {
         *   ogma.setGraph(rawGraph);
         *   // center on graph with 300ms transition
         *   ogma.view.locateGraph({ duration: 300 });
         * });
         */
        random: (options: {
            nodes?: number;
            edges?: number;
        }) => Promise<RawGraph>;
        /**
         * @method Ogma.generate.randomTree
         * Generates a random tree graph.
         * @param {object} [options]
         * @param {number} [options.nodes=50]   Number of nodes.
         * @param {number} [options.x=0]        X of the center
         * @param {number} [options.y=0]        Y of the center
         * @param {number} [options.width=100]  Width of the space to generate graph in
         * @param {number} [options.height=100] Height of the space to generate graph in
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.generate.tree({ nodes: 200 }).then(function(rawGraph) {
         *   ogma.setGraph(rawGraph);
         *   // center on graph with 300ms transition
         *   ogma.view.locateGraph({ duration: 300 });
         * });
         */
        randomTree: (options: {
            nodes?: number;
            x?: number;
            y?: number;
            width?: number;
            height?: number;
        }) => Promise<RawGraph>;
    };
    export default class GeneratorsAPI {
        generate: ReturnType<typeof createGeneratorsAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/graph" {
    import { RawNode, RawEdge, Filter, RawGraph, NodeId, EdgeId } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    import { LocateOptions } from "api/view";
    /**
     * @extends OgmaParameters
     * @property {RawGraph} [graph] Graph to initialize Ogma with
     */
    export default class GraphAPI {
        /**
         * @method Ogma.addNodes
         * Add the specified nodes to the graph. Ignores nodes that have the same id as a node in the graph.
         * @param {Array<RawNode>} nodes
         * @param {object} [options]
         * @param {number} [options.batchSize]     If specified, the graph will be imported progressively (`batchSize` nodes/edges at a time).
         *                                         It will effectively increase the total loading time, but the construction of the graph
         *                                         will be shown and the thread will not be frozen.
         * @return {Promise<NodeList>} Nodes added to the graph.
         * @example
         * // Simple usage
         * ogma.addNodes([{id: 0}, {id: 1}]).then(function (nodes) {
         *   console.log('Nodes ' + nodes.getId() + ' have been added to the graph.');
         * });
         *
         * // Adding nodes 1000 by 1000
         * ogma.addNodes(veryLargeArray, {batchSize: 1000}).then(function (nodes) {
         *   console.log('Nodes ' + nodes.getId() + ' have been added to the graph.');
         * });
         */
        addNodes(nodes: RawNode[], options?: {
            batchSize?: number;
        }): Promise<NodeList>;
        /**
         * @method Ogma.addEdges
         * Add the specified edges to the graph
         * @param {Array<RawEdge>} edges
         * @param {object} [options]
         * @param {number} [options.batchSize]     If specified, the graph will be imported progressively (`batchSize` nodes/edges at a time).
         *                                         It will effectively increase the total loading time, but the construction of the graph
         *                                         will be shown and the thread will not be frozen.
         * @return {Promise<EdgeList>} Edges added to the graph.
         */
        addEdges(edges: RawEdge[], options?: {
            batchSize?: number;
        }): Promise<EdgeList>;
        /**
         * @method Ogma.addNode
         * Add the specified node to the graph
         * @param {RawNode} node Node to add.
         * @param {object} [options] Unused for now.
         * @return {Node} Node that has just been added.
         * @example
         * ogma.addNode({id: 'n0', attributes: {color: 'green'}});
         */
        addNode(node: RawNode, options?: any): Node;
        /**
         * @method Ogma.addEdge
         * Add the specified edge to the graph
         * @param {RawEdge} edge Edge to add.
         * @param {object} [options] Unused for now.
         * @return {Edge} Edge that has just been added.
         */
        addEdge(edge: RawEdge, options?: any): Edge;
        /**
         * @method Ogma.removeNodes
         * Remove the specified nodes from the graph
         * @param {NodeList|Array<Node|NodeId>} nodes
         * @param {object} [options] Unused for now.
         * @returns {Promise<void>}
         */
        removeNodes(nodes: NodeList | Node[] | NodeId[], options?: any): Promise<void>;
        /**
         * @method Ogma.removeEdges
         * Remove the specified edges from the graph
         * @param {EdgeList|Array<Edge|EdgeId>} edges
         * @param {object} [options] Unused for now.
         * @returns {Promise<void>}
         */
        removeEdges(edges: EdgeList | Edge[] | EdgeId[], options?: any): Promise<void>;
        /**
         * @method Ogma.removeNode
         * Remove the specified node from the graph.
         * @param {Node|NodeId} node
         * @param {object} [options] Unused for now.
         */
        removeNode(node: Node | NodeId, options?: any): Promise<void>;
        /**
         * @method Ogma.removeEdge
         * Remove the specified edge from the graph.
         * @param {Edge|EdgeId} edge
         * @param {object} [options] Unused for now.
         */
        removeEdge(edge: Edge | EdgeId, options?: any): Promise<void>;
        /**
         * @method Ogma.getNodes
         * Return the specified nodes.
         * @param {Array<NodeId>|Filter|Array<Node>} [selector="visible"] If it's an array of ids, returns the nodes that match the specified ids.
         * If it's "visible", return all the visible nodes. If it's "raw", returns all nodes except the ones that are the result of a transformation (e.g. grouping).
         * If it's "all", returns all the nodes.
         * @return {NodeList}
         * @example
         * // Returns all visible nodes
         * ogma.getNodes();
         * @example
         * // Returns a specific set of nodes
         * ogma.getNodes(['n0', 'n1', 'n3']);
         * @example
         * // If you happen to need an empty NodeList you can do
         * ogma.getNodes([]);
         */
        getNodes(selector?: NodeId[] | Filter | Node[]): NodeList;
        /**
         * @method Ogma.getEdges
         * Return the specified edges.
         * @param {Array<EdgeId>|Filter|Array<Edge>} [selector="visible"] If it's an array of ids, returns the edges that match the specified ids.
         * If it's "visible", return all the visible edges. If it's "raw", returns all edges except the ones that are the result of a transformation (e.g. grouping).
         * If it's "all", returns all the edges.
         * @return {EdgeList}
         */
        getEdges(selector?: EdgeId[] | Filter | Edge[]): EdgeList;
        /**
         * @method Ogma.getNode
         * Return the specified node, or `undefined` if it doesn't exist.
         * @param {NodeId} nodeId
         * @return {Node|undefined}
         */
        getNode(nodeId: NodeId): Node | undefined;
        /**
         * @method Ogma.getEdge
         * Return the specified edge, or `undefined` if it doesn't exist.
         * @param {EdgeId} edgeId
         * @return {Edge|undefined}
         */
        getEdge(edgeId: EdgeId): Edge | undefined;
        /**
         * @method Ogma.clearGraph
         * Removes all the nodes and edges from the graph.
         */
        clearGraph(): void;
        /**
         * @method Ogma.setGraph
         * Clear the graph, then add the specified nodes and edges to the graph.
         * @param {RawGraph} graph
         * @param {object}  [options]
         * @param {number} [options.batchSize]     If specified, the graph will be imported progressively (`batchSize` nodes/edges at a time).
         *                                         It will effectively increase the total loading time, but the construction of the graph
         *                                         will be shown and the thread will not be frozen.
         * @return {Promise<{nodes: NodeList, edges: EdgeList}>}
         */
        setGraph(graph: RawGraph, options?: {
            batchSize?: number;
        }): Promise<{
            nodes: NodeList;
            edges: EdgeList;
        }>;
        /**
         * @method Ogma.addGraph
         * Add the specified nodes and edges to the graph.
         * @param {RawGraph} graph
         * @param {object}  [options]
         * @param {LocateOptions} [options.locate] Indicates the options for the camera movement.
         * @param {number} [options.batchSize]     If specified, the graph will be imported progressively (`batchSize` nodes/edges at a time).
         *                                         It will effectively increase the total loading time, but the construction of the graph
         *                                         will be shown and the thread will not be frozen.
         * @return {Promise<{nodes: NodeList, edges: EdgeList}>}
         */
        addGraph(graph: RawGraph, options?: {
            batchSize?: number;
            locate?: LocateOptions;
        }): Promise<{
            nodes: NodeList;
            edges: EdgeList;
        }>;
        /**
         * @method Ogma.createNodeList
         * Returns a new empty NodeList.
         * @returns {NodeList}
         */
        createNodeList(): NodeList;
        /**
         * @method Ogma.createEdgeList
         * Returns a new empty EdgeList.
         * @returns {EdgeList}
         */
        createEdgeList(): EdgeList;
        /**
         * @method Ogma.getConnectedComponents
         * Returns weakly connected components of the graph.
         * @param {object} [options]
         * @param {object} [options.filter='visible']
         * @param {boolean} [options.returnIds=false] Return node ids instead of Nodes
         * @return {Array<NodeList>}
         */
        getConnectedComponents(options?: {
            filter?: Filter;
            returnIds?: boolean;
        }): NodeList[];
        /**
         * Returns weakly connected component to which the node belongs
         * @method  Ogma.getConnectedComponentByNode
         * @param  {Node|NodeId} node
         * @param {object} [options]
         * @param {object} [options.filter='visible']
         * @param {boolean} [options.returnIds=false] Return node ids instead of Nodes
         * @return {NodeList}
         */
        getConnectedComponentByNode(node: Node | NodeId, options?: {
            filter?: Filter;
            returnIds?: boolean;
        }): NodeList;
    }
}
declare module "api/graphics" {
    /**
     * @extends Options
     * @property {object}       [cursor]
     * @property {CursorStyle}  [cursor.default="default"] A CSS value for the cursor.
     * @property {Color}        [backgroundColor="white"] Background color of the canvas.
     * @property {RendererType} [renderer="webgl"]      Rendering type. If WebGL is selected and not available, Ogma will fallback on Canvas.
     * If no renderer is available (e.g in Node.js), Ogma will fallback on headless mode (`null`).
     * @property {CrossOriginValue} [imgCrossOrigin="anonymous"] Indicates the value of the `crossOrigin` field for DOM images.
     */
    /**
     * @extends OgmaParameters
     * @property {"webgl"|"canvas"|"svg"|null} [renderer="webgl"] Rendering type. If WebGL is selected and not available, Ogma
     * fallback on Canvas. If no renderer is available (e.g in Node.js), Ogma will fallback on headless mode (`null`).
     * This field is an alias for `ogma.setOptions({renderer: value})`
     * @property {CrossOriginValue} [imgCrossOrigin="anonymous"] Indicates the value of the `crossOrigin` field for DOM images.
     * This is an alias for `ogma.setOptions({imgCrossOrigin: value})`
     */
    /**
     * @public
     * @typedef {object} NodeAttributesValue Object following the same structure as [`NodeAttributes`](#NodeAttributes),
     * with the addition that each property can be replaced by a function that return a value for this property (or an object
     * if the property has multiple nested sub-properties). `undefined` can be explicitly specified in any field to indicate that
     * the attribute should not be modified (useful when updating a class/rule).
     * When working with a large number of nodes/edges, avoid as much as possible the usage of functions.
     * @example
     * ogma.styles.addRule({
     *   nodeAttributes: {
     *     text: {
     *       // Specifying the same values for the attribute for all nodes
     *       font: 'Times'
     *     },
     *     // Function for "leaf" property
     *     color: function(node) {
     *       if (node.getData('type') === 'company') {
     *         return 'red';
     *       } else {
     *         return 'blue';
     *       }
     *     },
     *     innerStroke: function(node) {
     *       // Function for property with nested properties
     *       if (node.getData('country') === 'Germany') {
     *         return { width: 2, color: 'green' };
     *       } else {
     *         return { width: 1, color: 'white' };
     *       }
     *     },
     *     badges: {
     *       topRight: function(node) {
     *         return node.getDegree();
     *       }
     *     }
     *   }
     * });
     * @example
     * ogma.styles.addRule({
     *   // It's also possible to provide a function that will return the whole attributes object
     *   nodeAttributes: function(node) {
     *     if (node.getData('foo') === 'bar') {
     *       return { color: 'blue', radius: 4 };
     *     } else {
     *       return { color: 'red', radius: 2 };
     *     }
     *   }
     * });
     * @typedef {object} EdgeAttributesValue Object following the same structure as
     * [`EdgeAttributes`](#EdgeAttributes), with the addition that each property can
     * be replaced by a function that return a value for this property (or an object
     * if the property has multiple nested sub-properties).
     * When working with a large number of nodes/edges, avoid as much as possible the usage of functions.
     *
     * @typedef {"linear"|"quadraticIn"|"quadraticOut"|"quadraticInOut"|"cubicIn"|"cubicOut"|"cubicInOut"} Easing
     * @typedef {"webgl"|"canvas"|"svg"|null} RendererType
     * @typedef {"requested"|"ok"|"error"} RendererState
     * Indicates a renderer state. <br>
     * <code>"requested"</code> is fired right after Ogma is initialized or the `renderer` option has been changed, and means that the
     * renderer has not been initialized yet. <br>
     * <code>"ok"</code> indicates that the renderer has been initialized and runs properly. <br>
     * <code>"error"</code> indicates that an error has occurred that prevents the renderer from running.
     * @typedef {"NO_WEBGL"|"NO_ANGLE_INSTANCED_ARRAYS"|"OTHER"|null} RendererErrorCode
     * A non-null value indicates that an error has occurred and provides information on that error. <br>
     * <code>"NO_WEBGL"</code> indicates that WebGL is not available, most likely a browser or GPU issue. <br>
     * <code>"NO_ANGLE_INSTANCED_ARRAYS</code>" indicates that the
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays">ANGLE_instanced_arrays</a>
     * WebGL extension is not available. Also most likely a browser or GPU issue. <br>
     * <code>"OTHER"</code> indicates an unexpected error, most likely due to a specific combination of browser/GPU/OS that was not
     * handled correctly by Ogma. If you happen to encounter this error code , please contact support@linkurio.us and
     * provide the error message along with the browser, operating system and graphics card used.
     * @typedef {"anonymous"|"use-credentials"|null} CrossOriginValue
     */
    export default class GraphicsAPI {
        /**
         * @method Ogma.reloadFonts
         * Indicates that the DOM has finished loading fonts. If you use an external font (like FontAwesome) and the font
         * is not displayed correctly on your nodes and edges (e.g squares instead of the actual characters), call this
         * method once you know the font has been loaded.
         * @example
         * ogma.reloadFonts();
         */
        reloadFonts(): void;
    }
}

declare module "api/imports" {
    import Ogma from "src/ogma";
    import { RawGraph } from "types/utilities";
    const createImportsAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.parse.gexf
         * Parse a GEXF string and return the raw graph.
         * @param {string} content
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.fetch(url).then(function(gexfString) {
         *   ogma.parse.gexf(gexfString).then(function(graph) {
         *     ogma.setGraph(graph);
         *   });
         * });
         */
        gexf: (content: string) => Promise<RawGraph>;
        /**
         * @method Ogma.parse.gexfFromUrl
         * Fetch and parse a GEXF file and return the raw graph.
         * @param {string} url
         * @return {Promise<RawGraph>}
         *
         * @example
         * // same as the example above, but shorter
         * ogma.parse.gexfFromUrl(url).then(function(graph) {
         *   ogma.setGraph(graph);
         * });
         */
        gexfFromUrl: (url: string) => Promise<RawGraph>;
        /**
         * @method Ogma.parse.janus
         * Parse the result of a JanusGraph query into an Ogma graph.
         * @param {object} content Response of the gremlin-client library ("gremlin-client")
         * @return {Promise<RawGraph>}
         *
         * @example
         * // Use the gremlin-client library to create a session
         * var client = Gremlin.createClient(8182, 'localhost', {});
         *
         * // Use the client to send a query
         * var q = 'g.V().limit(10).store("v").bothE().store("e").cap("v, "e")';
         * client.runQuery(, {}, function(error, res) => {
         *   if (error) {
         *     console.log('Gremlin query error: ' + error.message);
         *   }
         *
         *   var rawGraph = ogma.parse.janus(res);
         *   return ogma.setGraph(rawGraph);
         * });
         */
        janus: (content: string) => Promise<RawGraph>;
        /**
         * @method Ogma.parse.json
         * Parse a JSON string and return the raw graph.
         * @param {string} content
         * @return {Promise<RawGraph>}
         *
         * @example
         * ogma.exports.json({download: false)}).then(function (jsonString) {
         *   var MY_JSON = saveSomewhere(jsonString);
         * });
         *
         * // later
         *
         * var MY_JSON = loadFromSomewhere();
         * ogma.parse.json(MY_JSON).then(function (graph) {
         *   ogma.setGraph(graph);
         *   ogma.view.locateGraph();
         * });
         */
        json: (content: string) => Promise<RawGraph>;
        /**
         * @method Ogma.parse.jsonFromUrl
         * Fetch and parse a JSON file and return the raw graph.
         * @param {string} url
         * @return {Promise<RawGraph>}
         *
         * @example
         * // same as the example above, but shorter
         * ogma.parse.jsonFromUrl(url).then(function(graph) {
         *   ogma.setGraph(graph);
         * });
         */
        jsonFromUrl: (url: string) => Promise<RawGraph>;
        /**
         * @method Ogma.parse.neo4j
         * Parse the result of a Neo4J query into an Ogma graph.
         * @param {object} content Response of the neo4j Bolt driver ("neo4j-javascript-driver")
         * @return {Promise<RawGraph>}
         *
         * @example
         * // Use the neo4j-javascript-driver to create a session
         * // Refer to the neo4j-javascript-driver documentation for more information
         * var driver = neo4j.v1.driver('bolt://localhost', neo4j.v1.auth.basic('username', 'password'));
         * var session = driver.session();
         *
         * // Use the session to send a query
         * session
         *   .run('MATCH (n) OPTIONAL MATCH (n)-[r]-() RETURN n,r LIMIT 100')
         *   .then(function (response) {
         *     // Parse the response into an Ogma graph
         *     return ogma.parse.neo4j(response)
         *   }).then(function(graph) {
         *     // Load this graph
         *     return ogma.setGraph(graph);
         *   }).then(function() {
         *     console.log('Import done!');
         *     session.close();
         *   });
         */
        neo4j: (content: object) => Promise<RawGraph>;
    };
    export default class ImportsAPI {
        parse: ReturnType<typeof createImportsAPI>;
        static initNamespace(ogma: Ogma): void;
        fetch(url: string): void;
    }
}
declare module "api/layouts/layoutOptions" {
    import { NodeId } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    import { LocateOptions } from "api/view";
    /**
     * @public
     * Generic layout options.
     * @typedef {object} LayoutOptions
     * @param {Array<NodeId>|NodeList} [nodes]  List of affected nodes. If nothing provided, the whole graph will be used
     * @param {number}           [duration]     Duration of the animation when the graph is updated
     * @param {boolean}          [skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
     * @param {function(): void} [onSync]       Function called every time the graph is updated
     * @param {function(): void} [onEnd]        Function called after the last graph update
     * @param {boolean}          [useWebWorker=true] Indicates if the layout should be computed inside a web worker.
     * @param {boolean|LocateOptions} [locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
     */
    export interface LayoutOptions {
        nodes?: NodeId[] | NodeList;
        duration?: number;
        skipTextDrawing?: boolean;
        onSync?: () => void;
        onEnd?: () => void;
        useWebWorker?: boolean;
        locate?: boolean | LocateOptions;
    }
    interface IncrementalOptions {
        referenceNodes?: NodeId[] | NodeList;
        margin?: number;
    }
    export interface IncrementalLayoutOptions {
        incremental?: boolean | IncrementalOptions;
    }
}
declare module "api/layouts/concentric" {
    import Ogma from "src/ogma";
    import { LayoutOptions } from "api/layouts/layoutOptions";
    import { NodeId } from "types/utilities";
    import Node from "modules/core/graph/node";
    import { PropertyPath } from "api/data";
    export interface ConcentricLayoutOptions extends LayoutOptions {
        centralNode: NodeId | Node;
        centerX?: number;
        centerY?: number;
        sortBy?: PropertyPath;
        clockwise?: boolean;
        allowOverlap?: boolean;
        circleHopRatio?: number;
    }
    const _default_9: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.concentric
         * Concentric layout. This layout takes a base node as parameter and organizes the graph so the nodes close to the
         * selected node are close to it spatially.
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean}          [params.useWebWorker=true] Indicates if the layout should be computed inside a web worker.
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         *
         * @param {NodeId|Node} params.centralNode         Id of the central node
         * @param {number}  [params.centerX]               X coordinate where the central node must be moved, if different from the central node X
         * @param {number}  [params.centerY]               Y coordinate where the central node must be moved, if different from the central node Y
         * @param {string}  [params.sortBy]                Indicates the property from which the nodes must be sorted, or
         *                                                 `'random'`. You can use `'radius'`, `'degree'` or custom data
         *                                                 attributes.
         * @param {boolean} [params.clockwise=true]        Specifies if the nodes must be ordered clockwise.
         * @param {boolean} [params.allowOverlap=false]    Specifies if nodes are allowed to overlap.
         * @param {number}  [params.circleHopRatio=5]      If `allowOverlap` is false, specified the space between each ring, relative to the highest node size.
         *
         * @return {Promise<void>}
         *
         * @example
         * ogma.layouts.concentric({ centralNode: 'n0', sortBy: 'degree' });
         */
        concentric: (params: ConcentricLayoutOptions) => Promise<void>;
    };
    export default _default_9;
}
declare module "api/layouts/radial" {
    import { LayoutOptions } from "api/layouts/layoutOptions";
    import Node from "modules/core/graph/node";
    import { NodeId } from "types/utilities";
    import Ogma from "src/ogma";
    export interface RadialLayoutOptions extends LayoutOptions {
        centralNode: Node | NodeId;
        centerX?: number;
        centerY?: number;
        allowOverlap?: boolean;
        repulsion?: number;
        radiusDelta?: number;
        radiusRatio?: number;
        nodeGap?: number;
        maxIterations?: number;
        iterationsPerRender?: number;
        renderSteps?: boolean;
        epsilon?: number;
    }
    const _default_10: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.radial
         * Radial (concentric) layout positions nodes around the selected one based on
         * their graph-theoretical distance (shortest path in the graph, connecting them).
         * If there are subgraphs or nodes not reachable from the central node,
         * they will be pushed outwards, but still placed around the layout
         * in a readable way.
         *
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used.
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean}          [params.useWebWorker=true] Indicates if the layout should be computed inside a web worker.
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         *
         * @param {Node|NodeId} params.centralNode           Id of the central node
         * @param {number} [params.centerX]             X coordinate where the central node must be moved,
         *                                              if different from the central node X
         * @param {number} [params.centerY]             Y coordinate where the central node must be moved,
         *                                              if different from the central node Y
         * @param {boolean} [params.allowOverlap=false] Specifies if nodes are allowed to overlap.
         * @param {number} [params.repulsion=1]         Increase or decrease the repulsion force between the nodes on
         *                                              the same levels. Values smaller than 1 will result in more compact
         *                                               placement along the layers.
         * @param {number} [params.radiusDelta=0]       You can specify a constant distance
         *                                              between the layout layers, in this case
         *                                              `radiusRatio` will be ignored
         * @param {number} [params.radiusRatio=Math.SQRT2] Ratio between the radii
         *                                              of adjacent concentric layers:
         *                                              R[n+1] = R[n] × ratio
         * @param {number} [params.nodeGap=10]          Additional gap between the nodes
         *                                              that belong to one layer
         * @param {number} [params.maxIterations=100]   Maximum number of layout sweeps
         * @param {number} [params.iterationsPerRender=20] Layout iterations per update.
         * @param {boolean} [params.renderSteps=false]  Render intermediate results, before the
         *                                              algorithm converges. That means sending the
         *                                              calculated positions every `iterationsPerRender`
         *                                              iterations.
         * @param {number} [params.epsilon=0.001]       Layout precision. Smaller number means
         *                                              better precision but longer computation time
         *
         * @return {Promise<void>}
         *
         * @example
         * ogma.layouts.radial({ centralNode: 'n0', radiusDelta: 200 });
         */
        radial: (params: RadialLayoutOptions) => any;
    };
    export default _default_10;
}
declare module "api/layouts/force" {
    import { LayoutOptions, IncrementalLayoutOptions } from "api/layouts/layoutOptions";
    import Ogma from "src/ogma";
    export interface ForceLayoutOptions extends LayoutOptions, IncrementalLayoutOptions {
        charge?: number;
        gravity?: number;
        edgeStrength?: number;
        steps?: number;
        theta?: number;
        radiusRatio?: number;
        edgeLength?: number;
        cx?: number;
        cy?: number;
        easticity?: number;
        alignSiblings?: boolean;
        siblingsOffset?: number;
    }
    const _default_11: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.force
         *
         * Force-directed layout.
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will
         *                                                 be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean}          [params.useWebWorker=true] Indicates if the layout should be computed inside a web worker
         * @param {boolean|LocateOptions} [params.locate=false] Center on the graph bounding box when the layout is
         *                                                      complete. You can also provide padding.
         * @param {boolean | object}  [params.incremental=false] Enable the incremental layout using Force layout. When true is uses the default options.
         * @param {number}  [params.incremental.margin = 5]      Will apply Force layout to the group and place the resulting configuration in the closest available position, maintaining a `margin`.
         * @param {Array<NodeId>|NodeList} [params.incremental.referenceNodes]
         * @param {number}  [params.charge=10]          Distance factor between nodes. A greater value increases the distance.
         * @param {number}  [params.gravity=0.05]      Force that attracts nodes to the center of the graph. Center is either
         *                                             the mass center of the graph or the value defined by `cx` and `cy`.
         *                                             Greater value makes the layout more compact.
         * @param {number}  [params.edgeStrength=0.5]  Attraction strength. Valid values are between `0` and `1`
         * @param {number}  [params.steps=300]         Iteration steps limit and cooling ratio.
         * @param {number}  [params.theta=0.62]        Theta parameter of the Barnes-Hut optimization. Plays the role of
         *                                             the precision in repulsive forces approximation.
         * @param {number}  [params.radiusRatio=1.25]  Radius ratio is used to allow for small gaps between the nodes while
         *                                             avoiding the ovelapping.
         * @param {number}  [params.edgeLength=30]     Desired length of an edge connecting 2 nodes.
         * @param {number}  [params.cx]                X coordinate of the layout mass center.
         * @param {number}  [params.cy]                Y coordinate of the layout mass center.
         * @param {number}  [params.elasticity=0.9]    Node collision elasticity. Smaller values may result in incomplete node
         *                                             overlap removal. Passing `0` will skip that algorithm pass altogether.
         * @param {boolean} [params.alignSiblings=false] Align nodes that are linked to the same two nodes only. It enhances
         *                                               readability. This operation is performed once the main layout is
         *                                               finished.
         * @param {number} [params.siblingsOffset=0.0] Additional offset between the node siblings, so that the distance
         *                                             to the next node in the row would be r * (1 + siblingsOffset), where r
         *                                             is the previous node's radius.
         *
         * @return {Promise<void>}
         *
         * @example
         *
         * ogma.layouts.force()
         *   .then(() => {
         *     console.log('layout complete');
         *   });
         */
        force: (params?: ForceLayoutOptions) => Promise<void>;
    };
    export default _default_11;
}
declare module "api/layouts/forceLink" {
    import { LayoutOptions, IncrementalLayoutOptions } from "api/layouts/layoutOptions";
    import Edge from "modules/core/graph/edge";
    import Node from "modules/core/graph/node";
    import Ogma from "src/ogma";
    export interface ForceLinkOptions extends LayoutOptions, IncrementalLayoutOptions {
        scalingRatio?: number;
        gravity?: number;
        edgeWightInfluence?: number;
        linLogMode?: boolean;
        outboundAttractionDistribution?: boolean;
        strongGravityMode?: boolean;
        slowDown?: number;
        alignNodeSiblings?: boolean;
        nodeSiblingsScale?: number;
        nodeSiblingsAngleMin?: number;
        autoStop?: boolean;
        maxIterations?: number;
        avgDistanceThreshold?: number;
        startingIterations?: number;
        iterationsPerRender?: number;
        barnesHutOptimize?: boolean;
        barnesHutTheta?: number;
        randomize?: 'locally' | 'globally';
        randomizeFactor?: number;
        nodeMass?: (node: Node) => number;
        edgeWeight?: (edge: Edge) => number;
    }
    const _default_12: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.forceLink
         *
         * Force link layout.
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean}          [params.useWebWorker=true] Indicates if the layout should be computed inside a web worker.
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         * @param {boolean | object}  [params.incremental=false] Enable the incremental layout using Force layout. When true is uses the default options.
         * @param {number}  [params.incremental.margin = 5]      Will apply Force layout to the group and place the resulting configuration in the closest available position, maintaining a `margin`.
         * @param {Array<NodeId>|NodeList} [params.incremental.referenceNodes]
         * @param {number}  [params.scalingRatio=100]         Distance factor between nodes. A greater value increases the distance.
         * @param {number}  [params.gravity=1]                Force which attracts nodes to the center of the graph. A greater value makes the graph more compact.
         * @param {number}  [params.edgeWeightInfluence=0]           Increase attraction force between nodes connected with edges of positive weights. Disabled by default.
         * @param {boolean} [params.linLogMode=false]                Alternative energy model with linear repulsion force and logarithmic attraction force.
         * @param {boolean} [params.outboundAttractionDistribution=false] Attract super-nodes (with many edges) to the outside.
         * @param {boolean} [params.strongGravityMode=true]          Enable a gravity formula to have a strong effect.
         * @param {number}  [params.slowDown=1]                      Reduces the speed of node displacements as the number of iterations increases.
         * @param {boolean} [params.alignNodeSiblings=true]          Align nodes that are linked to the same two nodes only. It enhances readability. This operation is performed once the main layout is finished.
         * @param {number}  [params.nodeSiblingsScale=5]             Distance multiplier between the aligned nodes.
         * @param {number}  [params.nodeSiblingsAngleMin=0]          Force a minimal angle between aligned nodes (from 0 to PI / 2). Node labels may indeed overlap on horizontally aligned nodes.
         * @param {boolean} [params.autoStop=true]                   The layout stops automatically if true.
         * @param {number}  [params.maxIterations=1000]              Set a limit to the number of iterations if autoStop: true.
         * @param {number}  [params.avgDistanceThreshold=0.01]       This is the normal stopping condition of autoStop: true. When the average displacements of nodes is below this threshold, the layout stops.
         * @param {number}  [params.startingIterations=10]           Number of iterations to be run before the first update of the graph visualization.
         * @param {number}  [params.iterationsPerRender=10]          Number of iterations to be run before each update of the graph visualization.
         * @param {boolean} [params.barnesHutOptimize=false]         Should we use the algorithm's Barnes-Hut to improve repulsion's scalability (`O(n²)` to `O(nlog(n))`)? This is useful for large graphs (5000+ nodes) but harmful to small ones.
         * @param {number}  [params.barnesHutTheta=0.5]              Theta parameter of the Barnes-Hut optimization.
         * @param {string}  [randomize]                              Whether to randomize the node positions before running the layout. Possible values are `locally` and `globally`. `Locally` means that the node coordinate will be shuffled around its current position, whereas with `globally` it will be assigned a new random value.
         * @param {number}  [randomizeFactor=1]                      [1] Randomization scaling factor.
         * @param {function(node:Node, degree:number):number} [params.nodeMass] Use this getter to assign node masses. Node degree is passed in for convenience.
         * @param {function(edge:Edge):number} [params.edgeWeight]              Use this getter to modify edge weight. 0 means that the edge will be ignored
         *
         * @return {Promise<void>}
         *
         * @example
         *
         * ogma.layouts.forceLink({
         *   barnesHutOptimize: false,
         *   duration: 500
         * });
         */
        forceLink: (params?: ForceLinkOptions) => Promise<void>;
    };
    export default _default_12;
}
declare module "api/layouts/hierarchical" {
    import { LayoutOptions } from "api/layouts/layoutOptions";
    import { PropertyPath } from "api/data";
    import { NodeId } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    import Ogma from "src/ogma";
    export interface HierarchicalLayoutOptions extends LayoutOptions {
        direction?: 'TB' | 'BT' | 'LR' | 'RL';
        nodeDistance?: number;
        levelDistance?: number;
        layer?: PropertyPath;
        arrangeComponents?: 'fit' | 'grid' | 'singleLine';
        gridDistance?: number;
        roots?: NodeId[] | NodeList;
        sinks?: NodeId[] | NodeList;
    }
    const _default_13: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.hierarchical
         *
         * The hierarchical layout positions nodes starting from a root nodes downwards
         * generating a visual hierarchy based on connectivity.<br>
         *
         * When the user provides the root nodes then the algorithm positions the cascading nodes
         * based on their graph-theoretical distance. When root nodes are not provided then the algorithm
         * works out the best top node in order to reduce the number of layers (depth) of the hierarchy.
         * It is possibile to impose constraints to the layout in order to set specific layers (depth) for each
         * node using a numeric `layer` data attribute.<br>
         * If you want to force a node to be at the top or the bottom of the layering, look at the `roots` and `sinks` parameters.<br>
         *
         * If there are subgraphs or nodes not reachable from the central node,
         * they will be layouted separately. It is possibile to control how these subgraphs are positioned.
         *
         * @example
         * ogma.layouts.hierarchical({
         *   direction: 'TB',  // Direction of the layout. Can be TB, BT, LR, or RL,
         *                   // where T = top, B = bottom, L = left, and R = right.
         *   duration: 300,  // Duration of the animation
         *   nodeDistance: 30,    // Number of pixels that separate nodes horizontally in the layout.
         *   levelDistance: 40     // Number of pixels between each layer in the layout.
         * }).then(function() {
         *   console.log('done');
         * });
         *
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         *
         * @param {"TB"|"BT"|"LR"|"RL"}  [params.direction='TB'] Layout direction: Top-bottom/bottom-top/left-right/right-left. The "rankdir" parameter has been deprecated, but still supported for this version: make sure to migrate to "direction" in your code from now on.
         * @param {number}  [params.nodeDistance=50]  Desired distance between the nodes on one layer
         * @param {number}  [params.levelDistance=50] Desired distance between the layers of layout
         * @param {string} [params.layer] Data field defining the layer of the node in the hierarchy
         * @param {"fit"|"grid"|"singleLine"}  [params.arrangeComponents='fit'] Desired fit for multiple disconnected components: "fit" attempt to optimize the screen space; "grid" adds a special behaviour for isolated nodes, arranging them together in a grid, then fit on the screen; "singleLine" arrange all disconnected components alongside.
         * @param {number}  [params.gridDistance=50] Desidered distance between isolated nodes when arranged in grid. Used only when "grid" arrangeComponent is enabled.
         * @param {Array<NodeId>|NodeList} [params.roots=[]] List of nodes to put at the top of the hierarchy
         * @param {Array<NodeId>|NodeList} [params.sinks=[]] List of nodes to put at the bottom of the hierarchy
         *
         * @return {Promise<void>}
         *
         * @demo layout-hierarchical
         */
        hierarchical: (params?: HierarchicalLayoutOptions) => Promise<void>;
    };
    export default _default_13;
}
declare module "api/layouts/sequential" {
    import { HierarchicalLayoutOptions } from "api/layouts/hierarchical";
    import Ogma from "src/ogma";
    export type SequentialLayoutOptions = HierarchicalLayoutOptions;
    const _default_14: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.sequential
         *
         * The sequential layout positions nodes starting from a root nodes downwards
         * generating a visual hierarchy based on connectivity with a costant width.<br>
         *
         * When the user provides the root nodes then the algorithm positions the cascading nodes
         * based on their graph-theoretical distance. When root nodes are not provided then the algorithm
         * works out the best top node in order to reduce the number of layers (depth) of the hierarchy.
         * It is possibile to impose constraints to the layout in order to set specific layers (depth) for each
         * node using a numeric `layer` data attribute.<br>
         * If you want to force a node to be at the top or the bottom of the layering, look at the `roots` and `sinks` parameters.<br>
         *
         * If there are subgraphs or nodes not reachable from the central node,
         * they will be layouted separately. It is possibile to control how these subgraphs are positioned.
         *
         *
         * @example
         * ogma.layouts.sequential({
         *   direction: 'TB',  // Direction of the layout. Can be TB, BT, LR, or RL,
         *                   // where T = top, B = bottom, L = left, and R = right.
         *   duration: 300,  // Duration of the animation
         *   nodeDistance: 30,    // Number of pixels that separate nodes horizontally in the layout.
         *   levelDistance: 40     // Number of pixels between each layer in the layout.
         * }).then(function() {
         *   console.log('done');
         * });
         *
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         *
         * @param {"TB"|"BT"|"LR"|"RL"}  [params.direction='TB'] Layout direction: Top-bottom/bottom-top/left-right/right-left.
         * @param {number}  [params.nodeDistance=50]  Desired distance between the nodes on one layer
         * @param {number}  [params.levelDistance=50] Desired distance between the layers of layout
         * @param {"fit"|"grid"|"singleLine"}  [params.arrangeComponents='fit'] Desired fit for multiple disconnected components: "fit" attempt to optimize the screen space; "grid" adds a special behaviour for isolated nodes, arranging them together in a grid, then fit on the screen; "singleLine" arrange all disconnected components alongside.
         * @param {number}  [params.gridDistance=50] Desidered distance between isolated nodes when arranged in grid. Used only when "grid" arrangeComponent is enabled.
         * @param {Array<NodeId>|NodeList} [params.roots=[]] List of nodes to put at the top of the hierarchy
         * @param {Array<NodeId>|NodeList} [params.sinks=[]] List of nodes to put at the bottom of the hierarchy
         *
         * @return {Promise<void>}
         *
         * @demo layout-sequential
         */
        sequential: (params?: HierarchicalLayoutOptions) => Promise<void>;
    };
    export default _default_14;
}
declare module "api/layouts/grid" {
    import { LayoutOptions } from "api/layouts/layoutOptions";
    import { PropertyPath } from "api/data";
    import Ogma from "src/ogma";
    export interface GridLayoutOptions extends LayoutOptions {
        rows?: number;
        cols?: number;
        sortBy?: PropertyPath;
        sortFallbackValue?: any;
        revers?: boolean;
    }
    const _default_15: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.grid
         * Arrange the nodes in a grid.
         * @param {object} params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         *
         * @param {Array<NodeId>|NodeList} [params.nodes]  List of affected nodes. If nothing provided, the whole graph will be used
         * @param {number}           [params.duration]     Duration of the animation when the graph is updated
         * @param {boolean}          [params.skipTextDrawing=true] Skip drawing labels during the layout. Improves performance and user experience.
         * @param {function(): void} [params.onSync]       Function called every time the graph is updated
         * @param {function(): void} [params.onEnd]        Function called after the last graph update
         * @param {boolean}          [params.useWebWorker=true] Indicates if the layout should be computed inside a web worker.
         * @param {boolean|LocateOptions} [params.locate=false]    Center on the graph bounding box when the layout is complete. You can also provide padding.
         *
         * @param {number} [params.rows]             Indicates the desired number of rows. If neither `rows` or `cols` are specified, the layout will attempt to make a square.
         * @param {number} [params.cols]             Indicates the desired number of cols. If neither `rows` or `cols` are specified, the layout will attempt to make a square.
         * @param {string} [params.sortBy]           Indicates the property from which the nodes must be sorted. Can also be `'random'`, in which case the node order is randomized.
         * @param {any} [params.sortFallbackValue]   Use this value for the nodes, for which the sorting attribute is undefined.
         * @param {boolean} [params.reverse] [false] If `true`, the nodes will be sorted in reverse order.
         *
         * @return {Promise<void>}
         *
         * @example Arrange the nodes in 3 rows, sorting them from the largest to the smallest.
         * ogma.layouts.grid({ sortBy: 'radius', reverse: true, rows: 3 });
         */
        grid: (params?: GridLayoutOptions) => Promise<void>;
    };
    export default _default_15;
}
declare module "api/layouts/incremental" {
    import Ogma from "src/ogma";
    import { ForceLinkOptions } from "api/layouts/forceLink";
    import Node from "modules/core/graph/node";
    import { NodeId } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    export interface IncrementalLayoutOptions extends ForceLinkOptions {
        nodes: NodeList | NodeId[];
        centralNode?: Node;
        margin?: number;
    }
    const _default_16: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.incremental
         * @deprecated
         *
         * This layout is designed for incremental expansion of the node groups
         * taking into account the surroundings. It works in two modes, based on
         * provided information:<br><br>
         *
         * 1. If only a node group is provided for expansion, the algorithm will
         * apply ForceLink layout to the group and place the resulting configuration
         * in the closest available position, maintaining a `margin`. Depending on
         * the options available, subgraph can be placed between other nodes and
         * components, if the space would allow, or outside of the graph convex hull
         * otherwise<br><br>
         *
         * 2. If a `centralNode` is provided and its position is fixed, the layout
         * has two  options: if no additional information is provided, the algorithm
         * will attempt to position graphs node so that the overlapping would be
         * minimal and the subgraph would still be visibly separated. Otherwise, if
         * `focusOnGroupShape` is set to `true`, the layout will try and maintain
         * the given subgraph readability by layouting itself first around the fixed
         * focal point and then pushing the nodes around it away. Keep in mind that
         * not every spatial configuration of restraints (most notably, large amount
         * of fixed nodes around the subgraph of interest) would allow the algorithm
         * to produce a non-overlapping set of node positions.<br><br>
         *
         * See the list of special parameters below, the rest of the options is the
         * same as for the `ForceLink` and will be passed on to the particular stage
         * of the algorithm where it is used.
         *
         * Deprecated, use ogma.layouts.force() or ogma.layouts.forceLink() instead.
         *
         * @param {object}    params See <a href="#LayoutOptions" class="typeref">LayoutOptions</a> for common layout options.
         * @param  {NodeList} params.nodes
         * @param  {Node}     [params.centralNode]
         * @param  {number}   [params.margin=5]
         * @param  {boolean}  [params.focusOnGroupShape=false]
         * @param  {boolean|LocateOptions} [params.locate=false]
         * @param {number}    [params.duration]     Duration of the animation when the graph is updated
         *
         * @param {number}  [params.scalingRatio=100]         Distance factor between nodes. A greater value increases the distance.
         * @param {number}  [params.gravity=1]                Force which attracts nodes to the center of the graph. A greater value makes the graph more compact.
         * @param {number}  [params.edgeWeightInfluence=0]           Increase attraction force between nodes connected with edges of positive weights. Disabled by default.
         * @param {boolean} [params.linLogMode=false]                Alternative energy model with linear repulsion force and logarithmic attraction force.
         * @param {boolean} [params.outboundAttractionDistribution=false] Attract super-nodes (with many edges) to the outside.
         * @param {boolean} [params.strongGravityMode=true]          Enable a gravity formula to have a strong effect.
         * @param {number}  [params.slowDown=1]                      Reduces the speed of node displacements as the number of iterations increases.
         * @param {boolean} [params.alignNodeSiblings=true]          Align nodes that are linked to the same two nodes only. It enhances readability. This operation is performed once the main layout is finished.
         * @param {number}  [params.nodeSiblingsScale=5]             Distance multiplier between the aligned nodes.
         * @param {number}  [params.nodeSiblingsAngleMin=0]          Force a minimal angle between aligned nodes (from 0 to PI / 2). Node labels may indeed overlap on horizontally aligned nodes.
         * @param {boolean} [params.autoStop=true]                   The layout stops automatically if true.
         * @param {number}  [params.maxIterations=1000]              Set a limit to the number of iterations if autoStop: true.
         * @param {number}  [params.avgDistanceThreshold=0.01]       This is the normal stopping condition of autoStop: true. When the average displacements of nodes is below this threshold, the layout stops.
         * @param {number}  [params.startingIterations=10]           Number of iterations to be run before the first update of the graph visualization.
         * @param {number}  [params.iterationsPerRender=10]          Number of iterations to be run before each update of the graph visualization.
         * @param {boolean} [params.barnesHutOptimize=false]         Should we use the algorithm's Barnes-Hut to improve repulsion's scalability (`O(n²)` to `O(nlog(n))`)? This is useful for large graphs (5000+ nodes) but harmful to small ones.
         * @param {number}  [params.barnesHutTheta=0.5]              Theta parameter of the Barnes-Hut optimization.
         * @param {function(node:Node, degree:number):number} [params.nodeMass] Use this getter to assign node masses. Node degree is passed in for convenience.
         * @param {function(edge:Edge):number} [params.edgeWeight]              Use this getter to modify edge weight. 0 means that the edge will be ignored
         *
         * @return {Promise<void>}
         */
        incremental: (params: IncrementalLayoutOptions) => Promise<void>;
    };
    export default _default_16;
}
declare module "api/layouts/index" {
    import Ogma from "src/ogma";
    const createLayoutsAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.layouts.stop
         * Stops currently running layout
         *
         * @example
         * // force stop a layout
         * ogma.layouts.forceLink();
         * setTimeout(function() {
         *   ogma.layouts.stop();
         * }, 200);
         */
        stop: () => any;
        incremental: (params: import("api/layouts/incremental").IncrementalLayoutOptions) => Promise<void>;
        grid: (params?: import("api/layouts/grid").GridLayoutOptions) => Promise<void>;
        sequential: (params?: import("api/layouts/hierarchical").HierarchicalLayoutOptions) => Promise<void>;
        hierarchical: (params?: import("api/layouts/hierarchical").HierarchicalLayoutOptions) => Promise<void>;
        forceLink: (params?: import("api/layouts/forceLink").ForceLinkOptions) => Promise<void>;
        force: (params?: import("api/layouts/force").ForceLayoutOptions) => Promise<void>;
        radial: (params: import("api/layouts/radial").RadialLayoutOptions) => any;
        concentric: (params: import("api/layouts/concentric").ConcentricLayoutOptions) => Promise<void>;
    };
    export default class LayoutsAPI {
        layouts: ReturnType<typeof createLayoutsAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/mouse" {
    import Ogma from "src/ogma";
    import { Point } from "types/utilities";
    export function createMouseAPI(ogma: Ogma): {
        move(coords: Point): Promise<void>;
        down(coords: Point): Promise<void>;
        up(coords: Point): Promise<void>;
        click(coords: Point): Promise<void>;
        rightClick(coords: Point): Promise<void>;
        doubleClick(coords: Point): Promise<void>;
        drag(start: Point, end: Point): Promise<void>;
        wheel(coords: {
            x: number;
            y: number;
            delta: number;
        }): Promise<void>;
    };
    export default class MouseAPI {
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/pathfinding" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import { Filter } from "types/utilities";
    import NodeList from "modules/core/graph/nodeList";
    const createPathFindingAPI: (ogma: Ogma) => {
        /**
         * @deprecated
         * @method Ogma.pathfinding.astar
         * <em>This method has been deprecated in favor of [`ogma.algorithms.shortestPath()`](#Ogma-algorithms-shortestPath).</em> <br> <br>
         * Compute the shortest path between two nodes using the A* algorithm.
         * @param {Node|NodeId} source Source node.
         * @param {Node|NodeId} target Target node.
         * @param {object} [options]
         * @param {Filter} [options.filter="visible"]
         * @param {function(node1: Node, node2: Node): number} [options.pathLengthFunction] Takes two connected nodes as parameters, and returns the distance
         *                                                between them. Default: returns the euclidian distance between the two nodes.
         * @param {function(node1: Node, node2: Node): number} [options.heuristicLengthFunction] Takes two nodes as parameters, and returns the heuristic distance between them,
         *                                                     Default: returns the euclidian distance between the two nodes.
         * @param {boolean} [options.directed=false] Indicates if the graph should be considered directed
         * @return {NodeList} Ordered list of nodes indicating the shortest path, including the source and target nodes.
         * @example
         * var source = ogma.getNode('n0'),
         *     target = ogma.getNode('n1'),
         *     path = ogma.pathfinding.astar(source, target);
         *
         * console.log('Shortest path between n0 and n1: ' + path.getId());
         */
        astar(source: string | number | Node, target: string | number | Node, options?: {
            filter?: Filter;
            pathLengthFunction?: (node1: Node, node2: Node) => number;
            heuristicLengthFunction?: (node1: Node, node2: Node) => number;
            directed?: boolean;
        }): NodeList;
        /**
         * @deprecated
         * @method Ogma.pathfinding.dijkstra
         * <em>This method has been deprecated in favor of [`ogma.algorithms.shortestPath()`](#Ogma-algorithms-shortestPath).</em> <br> <br>
         * Compute the shortest path between two nodes using the Dijkstra algorithm.
         * @param {Node|NodeId} source Source node.
         * @param {Node|NodeId} target Target node.
         * @param {object} [options]
         * @param {Filter} [options.filter="visible"]
         * @param {function(node1: Node, node2: Node): number} [options.pathLengthFunction] Takes two connected nodes as parameter, and returns the distance between them. Default: always returns 1.
         * @param {boolean} [options.directed=false] Indicates if the graph should be considered directed
         * @return {NodeList} Ordered list of nodes indicating the shortest path, including the source and target nodes.
         * @example
         * var source = ogma.getNode('n0'),
         *     target = ogma.getNode('n1'),
         *     path = ogma.pathfinding.dijkstra(source, target);
         *
         * console.log('Shortest path between n0 and n1: ' + path.getId());
         */
        dijkstra(source: string | number | Node, target: string | number | Node, options?: {
            filter?: Filter;
            pathLengthFunction?: (node1: Node, node2: Node) => number;
            directed?: boolean;
        }): NodeList;
        /**
         * @deprecated
         * @method Ogma.pathfinding.dijkstraBig
         * <em>This method has been deprecated in favor of [`ogma.algorithms.shortestPath()`](#Ogma-algorithms-shortestPath).</em> <br> <br>
         * Compute the shortest path between two nodes using the Dijkstra algorithm. Optimized for larger graphs
         * @param {Node|NodeId} source Source node.
         * @param {Node|NodeId} target Target node.
         * @param {object} [options]
         * @param {Filter} [options.filter="visible"]
         * @param {function(node1: Node, node2: Node): number} [options.pathLengthFunction] Takes two connected nodes as parameter, and returns the distance between them. Default: always returns 1.
         * @param {boolean} [options.directed=false] Indicates if the graph should be considered directed
         * @return {NodeList} Ordered list of nodes indicating the shortest path, including the source and target nodes.
         * @example
         * var source = ogma.getNode('n0'),
         *     target = ogma.getNode('n1'),
         *     path = ogma.pathfinding.dijkstra(source, target);
         *
         * console.log('Shortest path between n0 and n1: ' + path.getId());
         */
        dijkstraBig(source: string | number | Node, target: string | number | Node, options?: {
            filter?: Filter;
            pathLengthFunction?: (node1: Node, node2: Node) => number;
            directed?: boolean;
        }): NodeList;
    };
    export default class PathFindingAPI {
        pathfinding: ReturnType<typeof createPathFindingAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/rules" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    const createRulesAPI: (ogma: Ogma) => {
        /**
         * @method Ogma.rules.map
         * Create a function that, given a node or edge, returns a value based on a mapping "any data -> any value".
         * @param {object} options
         * @param {PropertyPath} options.field Data property path on which to retrieve the value to be mapped
         * @param {{[key: string]: any}} [options.values] Mapping that associate data value to output value.
         * @param {any|Array<any>} [options.fallback] Value(s) to assign when the data value is not specified in the mapping.
         * @return {function(elt: Node|Edge): any}
         * @example
         * var colorMapping = ogma.rules.map({
         *   field: 'country', // The mapping will use the "country" data property of the node/edge
         *   values: {
         *     'France': 'blue',
         *     'Italy': 'green',
         *     'Spain': 'red'
         *   },
         *   fallback: ['white', 'black'] // Other countries will alternatively be colored in black or white
         * });
         *
         * // Add this function as a style rule
         * ogma.style.addRule({
         *   nodeAttributes: {
         *     color: colorMapping
         *   }
         * });
         */
        map(options: {
            field: string | string[];
            values?: {
                [key: string]: any;
            };
            fallback?: any;
        }): (elt: Node | Edge) => any;
        /**
         * @method Ogma.rules.slices
         * Create a function that, given a node or edge, returns a value based on a mapping "numerical data -> any value"
         * @param {object} options
         * @param {PropertyPath} options.field Data property path to "slice"
         * @param {{nbSlices: number, min: number, max: number}|Array<any>} options.values
         * Indicates the possible output values for the slices. If an object is specified, there will
         * be `nbSlices` possible output values, with values from `min` to `max` (at regular intervals).
         * If an array is specified, it indicates the different possible values.
         * @param {{min: number, max: number}|Array<number>} [options.stops]
         * Indicates the boundaries of the slices. If an object is specified, it must indicates the minimum and maximum values the
         * data property can have. If it's an array, two consecutive elements indicate the boundaries for a slice. By default, the
         * slices will be determined using the current minimum and maximum value of the data property.
         * @param {any} [options.fallback] Value to assign when the property is not a number.
         * @param {boolean} [options.reverse=false] By default low values for data properties are given low output values. Setting this to `true` reverse this behavior.
         * @return {function(elt: Node|Edge): any}
         * @example
         * // Assigning the size based on a numerical property
         * var radiusRule = ogma.rules.slices({
         *   field: 'nbEmployees',
         *   // Nodes will be assigned one among 5 different radiuses, between 2
         *   // and 10, depending on their "nbEmployees" data property
         *   values: { nbSlices: 5, min: 2, max: 10 },
         *   // For values 1-200, the size will be 2, for values 201-400
         *   // the size will be 4, etc until 801-1000 -> 10
         *   stops: { min: 1, max: 1000 },
         *   // // Nodes for which the `nbEmployees` property is not a number will be assigned the size 1
         *   fallback: 1
         * });
         *
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     radius: radiusRule
         *   }
         * });
         * @example
         * // Assigning the color based on a numerical property
         *
         * // If `height` is less than 0, the node will be in blue.
         * // If it's between 0 and 100, it will be colored in green.
         * // If it's more than 100, it will be colored in brown
         * var colorRule = ogma.rules.slices({
         *   field: 'height',
         *   values: ['blue', 'green', 'brown'],
         *   stops: [0, 100],
         *   fallback: 'white'
         * });
         *
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     color: colorRule
         *   }
         * });
         */
        slices(options: {
            field: string | string[];
            values: any[] | {
                nbSlices: number;
                min: number;
                max: number;
            };
            fallback?: any;
            reverse?: boolean;
        }): (elt: Node | Edge) => any;
        /**
         * @method Ogma.rules.template
         * Returns a function that, given a node or edge, returns a string by replacing a pattern in the string by the
         * according data property.
         * @param {string} template String in which "{{foo}}}" will be replaced by the data property "foo".
         * @return {function(elt: Node|Edge): any}
         * @example
         * var textRule = ogma.rules.template('Age: {{age}}\nName: {{name}}');
         *
         * ogma.styles.addRule({
         *   nodeAttributes: {
         *     text: textRule
         *   }
         * });
         */
        template(template: string): (elt: Node | Edge) => any;
    };
    export default class RulesAPI {
        rules: ReturnType<typeof createRulesAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/selection" {
    import NodeList from "modules/core/graph/nodeList";
    import EdgeList from "modules/core/graph/edgeList";
    /**
     * @extends Options.interactions
     * @property {object}   [selection]
     * @property {boolean}  [selection.enabled=true]               Indicates if selection with the mouse should be enabled
     * @property {KeyName|null} [selection.multiSelectionKey="ctrl"]  Indicates the key that must be pressed to select multiple nodes/edges at a time.
     */
    export default class SelectionAPI {
        /**
         * @method Ogma.clearSelection
         * Clear the selection.
         * @example
         * ogma.clearSelection();
         */
        clearSelection(): void;
        /**
         * @method Ogma.getSelectedNodes
         * Returns all nodes that are selected.
         * @return {NodeList}
         * @example
         * console.log('Nodes selected: ' + ogma.getSelectedNodes().getId());
         */
        getSelectedNodes(): NodeList;
        /**
         * @method Ogma.getNonSelectedNodes
         * Returns all nodes that are not selected.
         * @return {NodeList}
         */
        getNonSelectedNodes(): NodeList;
        /**
         * @method Ogma.getSelectedEdges
         * Returns all edges that are selected.
         * @return {EdgeList}
         */
        getSelectedEdges(): EdgeList;
        /**
         * @method Ogma.getNonSelectedEdges
         * Returns all edges that are not selected.
         * @return {EdgeList}
         */
        getNonSelectedEdges(): EdgeList;
    }
}
declare module "api/settings" {
    import { Options } from "modules/core/settings";
    /**
     * @public
     * @typedef {object} Options
     * @property {object} [interactions]
     */
    /**
     * @public
     * @extends OgmaParameters
     * @property {Options} [options] Settings for all the modules.
     */
    export default class SettingsAPI {
        /**
         * @method Ogma.setOptions
         * Update the options of Ogma.
         * @param {Options} options
         */
        setOptions(options: Options): Options;
        getOptions(): Options;
    }
}
declare module "modules/watcher/propertyInfo" {
    /**
     * @public
     * @class PropertyInformation
     * Retrieved from `watcher.getPropertyInfo()`.
     */
    export default class PropertyInformation {
        /**
         * @method PropertyInformation.isNode
         * Indicates if it is a node or edge property.
         * @return {boolean}
         */
        isNode(): boolean;
        /**
         * @method PropertyInformation
         * Indicates the path of the data property
         * @return {Array<string>}
         */
        getPath(): string[];
        /**
         * @method PropertyInformation.getBoundaries
         * If there is at least one numerical value for this property, returns the
         * minimum and maximum value for this property across the graph. Returns
         * `null` if there is no numerical value for that property.
         * @return {null|{min: number, max: number}}
         */
        getBoundaries(): null | {
            min: number;
            max: number;
        };
        /**
         * @method PropertyInformation.getValues
         * Returns the different values for this property.
         * @return {Array<any>}
         */
        getValues(): any[];
        /**
         * @method PropertyInformation.getValueCount
         * Returns the number of nodes/edges for which the property has the specified value.
         * @param {any} value
         * @return {number}
         */
        getValueCount(value: any): number;
        /**
         * @method PropertyInformation.getCount
         * Returns the number of nodes/edges for which the property is different from `undefined`
         * @return {number}
         */
        getCount(): number;
        /**
         * @method PropertyInformation.getType
         * Returns the type of the property.
         * @return {"any"|"number"|"undefined"} If there is at least one non-number (excluding `undefined`) value, returns `'any'`.
         * If there are only numerical values for that property, returns `'number'`. If no node/edge has a value for that property,
         * returns `'undefined'`.
         */
        getType(): 'any' | 'number' | 'undefined';
    }
}
declare module "modules/watcher/nonObjectWatcher" {
    import PropertyInformation from "modules/watcher/propertyInfo";
    /**
     * @public
     * @class NonObjectPropertyWatcher
     * Retrieved from `ogma.schema.watchNodeNonObjectProperty()` or `ogma.schema.watchEdgeNonObjectProperty()`.
     */
    export default class NonObjectPropertyWatcher {
        /**
         * @method NonObjectPropertyWatcher.onUpdate
         * Triggers the specified function when the property is updated,
         * @param {function (info: PropertyInformation)} handler
         */
        onUpdate(handler: (info: PropertyInformation) => void): void;
        /**
         * @method NonObjectPropertyWatcher.getPropertyInfo
         * Retrieve some information on the property being watched.
         * @return {PropertyInformation}
         */
        getPropertyInfo(): PropertyInformation;
        /**
         * @method NonObjectPropertyWatcher.getPath
         * Returns the path of the data property being watched
         * @return {Array<string>}
         */
        getPath(): string[];
        /**
         * @method NonObjectPropertyWatcher.destroy
         * Stops the watcher from being updated
         */
        destroy(): void;
        /**
         * @deprecated
         * @method NonObjectPropertyWatcher.kill
         * Alias for [`destroy()`](#NonObjectPropertyWatcher-destroy).
         */
        kill(): void;
    }
}
declare module "modules/watcher/objectWatcher" {
    import PropertyInformation from "modules/watcher/propertyInfo";
    /**
     * @public
     * @class ObjectPropertyWatcher
     * Retrieved from `ogma.schema.watchNodeProperties()` or `ogma.schema.watchEdgeProperties()`.
     */
    export default class ObjectPropertyWatcher {
        /**
         * @method ObjectPropertyWatcher.onPropertyAdded
         * Triggers the specified function when a new sub-property is added (at least one node has a value for it).
         * @param {function (property: string, info: PropertyInformation)} handler
         * @return {ObjectPropertyWatcher}
         */
        onPropertyAdded(handler: any): this;
        /**
         * @method ObjectPropertyWatcher.onPropertyRemoved
         * Triggers the specified function when a new sub-property is removed (no node has a value for it).
         * @param {function (property: string, info: PropertyInformation)} handler
         * @return {ObjectPropertyWatcher}
         */
        onPropertyRemoved(handler: any): this;
        /**
         * @method ObjectPropertyWatcher.onPropertyUpdated
         * Triggers when a sub-property of the watched property is updated.
         * @param {function (property: string, info: PropertyInformation)} handler
         * @return {ObjectPropertyWatcher}
         */
        onPropertyUpdated(handler: any): this;
        /**
         * @method ObjectPropertyWatcher.getPath
         * Returns the path of the data property being watched
         * @return {Array<string>}
         */
        getPath(): string[];
        /**
         * @method ObjectPropertyWatcher.getProperties
         * Returns the names of the sub-property of the watched property.
         * @return {Array<string>}
         */
        getProperties(): string[];
        /**
         * @method ObjectPropertyWatcher.getPropertyInfo
         * Retrieve some information on the specified sub-property.
         * @param {string} name
         * @return {PropertyInformation|null}
         */
        getPropertyInfo(name: any): PropertyInformation | null;
        /**
         * @method ObjectPropertyWatcher.destroy
         * Stops the watcher from being updated.
         */
        destroy(): void;
        /**
         * @deprecated
         * @method ObjectPropertyWatcher.kill
         * Alias for [`destroy()`](#ObjectPropertyWatcher-destroy).
         */
        kill(): void;
    }
}
declare module "api/schema" {
    import Ogma from "src/ogma";
    import { PropertyPath } from "api/data";
    import { Filter } from "types/utilities";
    import NonObjectPropertyWatcher from "modules/watcher/nonObjectWatcher";
    import ObjectPropertyWatcher from "modules/watcher/objectWatcher";
    /**
     * @public
     * @typedef {object|PropertyPath} WatcherOptions
     * If a string or array is specified, it indicates the `path` property.
     * @property {PropertyPath} [path] Path of the data property to watch. If not specified, watch the root property.
     * @property {"visible"|"all"} [filter="visible"] Indicates which elements the watcher takes into account. If "visible" (default),
     * only the non-filtered elements will be taken into account. If "all", all elements will be taken into account regardless of
     * whether they are filtered or not.
     * @property {boolean} [unwindArrays=false] If `true`, array values will be treated as multiple individual values instead of one
     */
    export interface WatcherOptions {
        path?: PropertyPath;
        filter?: Filter;
        unwindArrays?: boolean;
    }
    export function createSchemaAPI(ogma: Ogma): {
        /**
         * @method Ogma.schema.watchNodeObjectProperty
         * Watch for addition, removal, and updates of the sub-properties of the specified node data property.
         * @param {WatcherOptions} [options] Options to use by the watcher
         * @return {ObjectPropertyWatcher}
         * @example
         * var ogma = new Ogma();
         * ogma.addNodes([{id: 0, data: {foo: 'bar', a: 'value'}}, {id: 1, data: {a: 'value2'}}]);
         *
         * var watcher = ogma.schema.watchNodeObjectProperty();
         *
         * console.log(JSON.stringify(watcher.getProperties())); // ['bar', 'a']
         * console.log(JSON.stringify(watcher.getPropertyInfo('a').getValues())); // ['value1', 'value2']
         *
         * watcher.onPropertyAdded(function (propertyName) {
         *   console.log('at least one node now has a value for the ' + propertyName + ' data property.');
         * });
         *
         * ogma.getNode(1).setData('quality', 'good'); // Outputs: 'at least one node now has a value for the quality data property.'
         */
        watchNodeObjectProperty(options: WatcherOptions): any;
        /**
         * @method Ogma.schema.watchEdgeObjectProperty
         * Watch for addition, removal, and updates of the sub-properties of the specified edge data property.
         * @param {WatcherOptions} [options] Options to use by the watcher
         * @return {ObjectPropertyWatcher}
         */
        watchEdgeObjectProperty(options: WatcherOptions): ObjectPropertyWatcher;
        /**
         * @method Ogma.schema.watchNodeNonObjectProperty
         * Provide information on the specified node data property, and notifies when the property is modified.
         * @param {WatcherOptions} [options] Options to use by the watcher
         * @return {NonObjectPropertyWatcher}
         * @example
         * var ogma = new Ogma();
         * ogma.addNodes([{id: 0, data: {properties: {foo: 'bar', a: 'value'}}}, {id: 1, data: {properties: {a: 'value2'}}}]);
         *
         * var watcher = ogma.schema.watchNodeObjectProperty(['properties', 'a');
         *
         * console.log(JSON.stringify(watcher.getPropertyInfo().getValues())); // ['value1', 'value2']
         *
         * watcher.onUpdate(function () {
         *   console.log(JSON.stringify(watcher.getPropertyInfo().getValues()));
         * });
         *
         * ogma.getNode(1).setData(['properties', 'a'], 'value3'); // Outputs: ['value1', 'value3']
         */
        watchNodeNonObjectProperty(options: WatcherOptions): NonObjectPropertyWatcher;
        /**
         * @method Ogma.schema.watchEdgeNonObjectProperty
         * Provide information on the specified edge data property, and notifies when the property is modified.
         * @param {WatcherOptions} [options] Options to use by the watcher
         * @return {NonObjectPropertyWatcher}
         */
        watchEdgeNonObjectProperty(options: WatcherOptions): NonObjectPropertyWatcher;
    };
    export default class SchemaAPI {
        schema: ReturnType<typeof createSchemaAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "api/tools/lasso" {
    import Ogma from "src/ogma";
    import { LassoOptions } from "modules/lasso";
    const _default_17: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.lasso.enable
         * Enables the lasso selection tool
         * @param {object}                [options]
         * @param {Color}                 [options.strokeColor="#00C3FF"]           Lasso stroke color
         * @param {number}                [options.strokeWidth=1]                   Lasso stroke width
         * @param {Color}                 [options.fillColor="rgba(0,195,255,0.1)"] Lasso fill color
         * @param {CursorStyle}           [options.cursorStyle="cell"]              Cursor style when the lasso is active (CSS property)
         * @param {function(payload: {nodes: NodeList, edges: EdgeList})} [options.callback]
         * Called with the nodes and edges surrounded by the lasso.
         * By default, add the nodes to the selection (edges are ignored).
         * @param {boolean}               [options.bothExtremities=false] If set to `true`, edge will
         * be passed to `callback` only if both of its ends are inside the selected area.
         * By default, just one endpoint inside the selection is enough to be included.
         */
        enable(options: LassoOptions): any;
        /**
         * @method Ogma.tools.lasso.disable
         * Disables lasso tool.
         */
        disable(): any;
        /**
         * @method Ogma.tools.lasso.enabled
         * Check whether the lasso tool is enabled.
         * @return {boolean}
         */
        enabled(): boolean;
    };
    export default _default_17;
}
declare module "api/tools/connectNodes" {
    import Ogma from "src/ogma";
    import { CursorStyle } from "modules/core/dom";
    import { Color } from "types/utilities";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    export interface ConnectNodesOptions {
        continueDrawing?: boolean;
        cursorStyle?: CursorStyle;
        strokeColor?: Color;
        strokeWidth?: number;
        dashLength?: number;
        condition?: (source: Node, target: Node) => boolean;
        onNodeCreated?: (node: Node) => void;
        onEdgeCreated?: (edge: Edge) => void;
        onComplete?: (source: Node, target: Node, edge: Edge) => void;
    }
    export interface NodesConnectedEvent {
        source: Node;
        target: Node;
        edge: Edge;
    }
    const _default_18: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.connectNodes.enable
         * Enable the "connectNodes" mode, allowing the user to draw edges with the mouse.
         * @param {object} [options]
         // * @param {boolean} [options.continueDrawing=false] If `true`, the mode will not be disabled after the first connection is created.
          * @param {boolean} [options.createNodes=true] Indicates if a node should be created when pointing on an empty space.
          * @param {CursorStyle} [options.cursorStyle="cell"]
          * @param {Color} [options.strokeColor="black"]
          * @param {number} [options.strokeWidth=2]
          * @param {number} [options.dashLength=8]
          * @param {function(source: Node, target: Node): boolean} [options.condition] If specified, will only connect nodes that satisfy this condition.
          * @param {function(node: Node):void} [options.onNodeCreated] If `createNodes` is set to true, a new node will be created and here you can add properties or styles to it.
          * @param {function(edge: Edge):void} [options.onEdgeCreated] In this callback you can add properties or styles to the created edge.
          * @param {function(source:Node, target: Node, edge: Edge):void} [options.onComplete] Called when a new connection is created.
          *
          * @example
          * ogma.connectNodes.enable({
          *   onNodeCreated: function(node) {
          *     node.setAttributes({ color: 'red' });
          *   },
          *   onEdgeCreated: function(edge) {
          *     edge.setAttributes({ width: 5 });
          *   }
          * });
          */
        enable(options: ConnectNodesOptions): any;
        /**
         * @method Ogma.tools.connectNodes.disable
         * Disable the "connectNodes" mode.
         *
         * @example
         * if (ogma.connectNodes.enabled()) {
         *   ogma.connectNodes.disable();
         * }
         */
        disable(): any;
        /**
         * @method Ogma.tools.connectNodes.enabled
         * Indicates if the "connectNodes" mode is enabled.
         *
         * @example
         * if (ogma.connectNodes.enabled()) {
         *   ogma.connectNodes.disable();
         * }
         */
        enabled(): boolean;
    };
    export default _default_18;
}
declare module "api/tools/rectangleSelect" {
    import Ogma from "src/ogma";
    const _default_19: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.rectangleSelect.enable
         * Enable the selection by rectangle tool, allowing the user to select some nodes by drawing a rectangle on the screen.
         * @param {object}                [options]
         * @param {Color}                 [options.strokeColor="#00C3FF"]           Rectangle stroke color
         * @param {number}                [options.strokeWidth=1]                   Rectangle stroke width
         * @param {Color|null}            [options.fillColor="rgba(0,195,255,0.1)"] Rectangle fill color
         * @param {CursorStyle}           [options.cursorStyle="cell"]              Cursor style when the rectangle is active (CSS property)
         * @param {function(evt: {nodes: NodeList, edges: EdgeList})} [options.callback] Called with the nodes/edges surrounded
         * by the rectangle. By default, add the surrounded nodes to the selection. If there is no surrounded node, add
         * the surrounded edges instead.
         * @param {boolean}               [options.bothExtremities=false] If set to `true`, edge will
         * be passed to `callback` only if both of its ends are inside the selected area.
         * By default, just one endpoint inside the selection is enough to be included.
         *
         * @example
         * ogma.tools.rectangleSelect.enable({
         *   strokeColor: 'blue',
         *   callback: function (payload) {
         *     // Override the default behavior and replaces the selection
         *     // instead of just adding the elements to the selection
         *     ogma.clearSelection();
         *     payload.nodes.setSelected(true);
         *     payload.edges.setSelected(true);
         *   })
         * });
         */
        enable: (options: import("modules/lasso").LassoOptions) => void;
        /**
         * @method Ogma.tools.rectangleSelect.disable
         * Disable the rectangle selection.
         * @example
         * ogma.tools.rectangleSelect.disable();
         */
        disable: () => void;
        /**
         * @method Ogma.tools.rectangleSelect.enabled
         * Indicates if the rectangle selection is enabled.
         * @return {boolean}
         * @example
         * console.log(ogma.tools.rectangleSelect.enabled());
         */
        enabled: () => boolean;
    };
    export default _default_19;
}
declare module "api/tools/resizing" {
    import Ogma from "src/ogma";
    import { CursorStyle } from "modules/core/dom";
    import { Color } from "types/utilities";
    export interface ResizingOptions {
        cursor?: CursorStyle;
        color?: Color;
        lineWidth?: number;
        handleSize?: number;
        detectionMargin?: number;
        snappingRatio?: number;
        nbNodesToSnapTo?: number;
        previewColor?: Color;
        sizeIndicatorColor?: Color;
        sizeIndicatorOffset?: number;
        sizeIndicatorWidth?: number;
        sizeIndicatorThickness?: number;
    }
    const _default_20: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.resize.enable
         * Enable the "resize" mode, allowing the user to manually change the size of the selected nodes.
         * @param {object} [options]
         * @param {CursorStyle} [options.cursor="nesw-resize"] CSS cursor to use when the mouse is over a resizing handle
         * @param {Color} [options.color="#00C3FF"] Color used to display the nodes bounding box
         * @param {number} [options.lineWidth=1] Width (in pixels) of the stroke of the square representing the nodes bounding box
         * @param {number} [options.handleSize=6] Width (in pixels) of the square indicator to drag in order to resize the node
         * @param {number} [options.detectionMargin=5] Maximum distance (in pixels) the mouse can be to the resize handler and still be detected
         * @param {number} [options.snappingRatio=1.25] Ratio used to determine the size to snap to, when the node does not snap to another node size. Must be strictly greater than 1.
         * @param {number} [options.nbNodesToSnapTo=5] Number of close nodes to use for snapping.
         * @param {Color} [options.previewColor='rgba(0, 0, 0, 0.2)'] Color of the preview of the node being resized
         * @param {Color} [options.sizeIndicatorColor="black"] Color of the size indicator (shown when the node snaps to the size of another node)
         * @param {number} [options.sizeIndicatorOffset=5] Offset (in pixels) to the left on which the size indicator must be displayed
         * @param {number} [options.sizeIndicatorWidth=3] Total width (in pixels) of the indicator size
         * @param {number} [options.sizeIndicatorThickness=1] Thickness (in pixels) of the line used to draw the size indicator
         */
        enable(options: ResizingOptions): any;
        /**
         * @method Ogma.tools.resize.disable
         * Disable the "resize" mode.
         */
        disable(): any;
        /**
         * @method Ogma.tools.resize.enabled
         * Indicates if the "resize" mode is enabled.
         * @return {boolean}
         */
        enabled(): boolean;
    };
    export default _default_20;
}
declare module "api/tools/rewiring" {
    import Ogma from "src/ogma";
    import { Color } from "types/utilities";
    import { CursorStyle } from "modules/core/dom";
    export interface RewiringOptions {
        color?: Color;
        radius?: number;
        cursorOnHover?: CursorStyle;
        cursorOnDrag?: CursorStyle;
    }
    const _default_21: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.rewire.enable
         * Enable the "rewire" tool, enabling the user to manually change the extremities of the selected edges.
         * @param {object} [options]
         * @param {Color} [options.color="#00C3FF"] Color of the handle in the center of the nodes
         * @param {number} [options.radius=7] Radius, in pixels, of the handle in the center of the nodes
         * @param {CursorStyle} [options.cursorOnHover='grab'] CSS cursor style when hovering a node handle
         * @param {CursorStyle} [options.cursorOnDrag='grabbing'] CSS cursor style when dragging an edge
         * @example
         * ogma.tools.rewiring.enable();
         */
        enable(options: RewiringOptions): any;
        /**
         * @method Ogma.tools.rewire.disable
         * Disable the "rewire" tool'.
         * @example
         * ogma.tools.rewiring.disable();
         */
        disable(): any;
        /**
         * @method Ogma.tools.rewire.enabled
         * @return {boolean} Indicates if the "rewire" tool is enabled
         * @example
         * // Toggle the tool
         * ogma.tools.rewiring[ogma.tools.rewiring.enabled() ? 'enable' : 'disable']();
         */
        enabled(): boolean;
    };
    export default _default_21;
}
declare module "api/tools/snapping" {
    import Ogma from "src/ogma";
    import { Color } from "types/utilities";
    export interface SnappingOptions {
        enabled?: boolean;
        tolerance?: number;
        centerSnapDistance?: number;
        sideSnapDistanceFactor?: number;
        guidelineWidth?: number;
        guidelineColor?: Color;
        preferredDistance?: {
            enabled?: boolean;
            ratio?: number;
            tolerance?: number;
            lineWidth?: number;
            lineColor?: Color;
        };
        neighbours: {
            enabled?: boolean;
            lineWidth?: number;
            lineColor?: Color;
            tolerance?: number;
            offset?: number;
        };
    }
    const _default_22: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.snapping.enable
         * Enables the snapping mode while dragging the nodes.
         * @param {object}  [options]
         * @param {Boolean} [options.enabled=false]                       Indicates whether the snapping is on when the node is being dragged
         * @param {Number}  [options.tolerance=5]                         Pixel tolerance distance within which node is snapped towards the guideline
         * @param {Number}  [options.centerSnapDistance=240]              Maximum distance between 2 nodes that allowes their centers to be aligned
         * @param {Number}  [options.sideSnapDistanceFactor=3]            Maximum distance between 2 nodes that allowes their sides to be aligned. The value is the factor of dragged node diameter.
         * @param {Number}  [options.guidelineWidth=1]                    Width of the alignment guideline
         * @param {Color}   [options.guidelineColor='red']                Color of the axis-ligned guidelines
         * @param {object}  [options.preferredDistance]                   Options for preferred ditance snapping: pairwise snapping of the nodes based on their distance
         * @param {Boolean} [options.preferredDistance.enabled=true]      Enables the mode.
         * @param {Number}  [options.preferredDistance.ratio=1.13]        Preferred distance ratio between nodes `a` and `b`, according to the formula `d = (Ra + Rb) * ratio`
         * @param {Number}  [options.preferredDistance.tolerance=10]      Snapping distance
         * @param {Number}  [options.preferredDistance.lineWidth=1]       Guideline width
         * @param {Color}   [options.preferredDistance.lineColor=#00C3FF] Guideline color
         * @param {object}  [options.neighbours]                          Equal nodes distribution: snaps a node to the middle of the distance between two other nodes or to the same distance as two of its neighbours
         * @param {Boolean} [options.neighbours.enabled=true]             Enables the mode.
         * @param {Number}  [options.neighbours.lineWidth=1]              Guideline width
         * @param {Color}   [options.neighbours.lineColor=#00C3FF]        Guideline color
         * @param {Number}  [options.neighbours.tolerance=3]              Snapping distance
         * @param {Number}  [options.neighbours.offset=5]                 Distance between the guideline and common bounding box of aligned nodes
         */
        enable(options: SnappingOptions): any;
        /**
         * @method Ogma.tools.snapping.disable
         * Disables snapping mode in nodes dragging.
         */
        disable(): any;
        enabled(): boolean;
    };
    export default _default_22;
}
declare module "api/tools/tooltip" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    export type TooltipPosition = 'top' | 'bottom' | 'left' | 'right' | 'cssDefined';
    /**
     * @public
     * @typedef {object} TooltipOptions
     * @property {"top"|"bottom"|"left"|"right"|"cssDefined"} [options.position="top"] Position of the tooltip relative to
     * the mouse. If "cssDefined" is specified, the tooltip will only be added to the graph container without
     * positioning it.
     * @property {boolean} [options.autoAdjust=true] When the mouse is at the edge of the screen, indicates if the
     * tooltip position should be corrected so it fits in the canvas.
     * @property {number} [options.delay=0] Delay in milliseconds before the tooltip is shown when the node is hovered.
     * @property {string} [options.className] If specified, this class name will be added to tooltip.
     */
    export interface TooltipOptions {
        position?: TooltipPosition;
        autoAdjust?: boolean;
        delay?: number;
        className?: string;
    }
    const _default_23: (ogma: Ogma) => {
        /**
         * @method Ogma.tools.tooltip.onNodeHover
         * Indicates the tooltip to display when a node is hovered.
         * @param {function (node: Node): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         * @example
         * ogma.tools.tooltip.onNodeHover(function (node) {
         *   return '&lt;p&gt;' + node.getId() + '&lt;/p&gt;';
         * });
         */
        onNodeHover(handler: (node: Node) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onNodeClick
         * Indicates the tooltip to display when a node is left clicked.
         * @param {function (node: Node): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onNodeClick(handler: (node: Node) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onNodeRightClick
         * Indicates the tooltip to display when a node is right clicked.
         * @param {function (node: Node): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onNodeRightClick(handler: (node: Node) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onNodeDoubleClick
         * Indicates the tooltip to display when a node is double clicked.
         * @param {function (node: Node): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onNodeDoubleClick(handler: (node: Node) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onEdgeHover
         * Indicates the tooltip to display when a edge is hovered.
         * @param {function (edge: Edge): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onEdgeHover(handler: (edge: Edge) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onEdgeClick
         * Indicates the tooltip to display when a edge is left clicked.
         * @param {function (edge: Edge): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onEdgeClick(handler: (edge: Edge) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onEdgeRightClick
         * Indicates the tooltip to display when a edge is right clicked.
         * @param {function (edge: Edge): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onEdgeRightClick(handler: (edge: Edge) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onEdgeDoubleClick
         * Indicates the tooltip to display when a edge is double clicked.
         * @param {function (edge: Edge): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onEdgeDoubleClick(handler: (edge: Edge) => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onBackgroundClick
         * Indicates the tooltip to display when the background is left clicked.
         * @param {function (): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onBackgroundClick(handler: () => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onBackgroundRightClick
         * Indicates the tooltip to display when the background is right clicked.
         * @param {function (): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onBackgroundRightClick(handler: () => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.onBackgroundDoubleClick
         * Indicates the tooltip to display when the background is double clicked.
         * @param {function (): (string|Promise<string>)} handler The function that will be called to generate the tooltip. Must return a HTML string.
         * @param {TooltipOptions} [options]
         */
        onBackgroundDoubleClick(handler: () => string | Promise<string>, options?: TooltipOptions): void;
        /**
         * @method Ogma.tools.tooltip.refresh
         * Refresh the current tooltip.
         */
        refresh(): void;
        /**
         * @method Ogma.tools.tooltip.isShown
         * Indicates if a tooltip is currently displayed.
         * @return {boolean}
         */
        isShown(): boolean;
        /**
         * @method Ogma.tools.tooltip.hide
         * Hide the tooltip that is currently being displayed.
         */
        hide(): void;
        /**
         * @method Ogma.tools.tooltip.show
         * @param {string|HTMLElement} html
         * @param {object} options
         * @param {number} options.x
         * @param {number} options.y
         * @param {"top"|"bottom"|"left"|"right"|"cssDefined"} [options.position="top"]
         * @param {boolean} [options.autoAdjust=true]
         * @param {string} [options.className]
         * @internal
         */
        show(html: any, options: {
            x: number;
            y: number;
            position?: TooltipPosition;
            autoAdjust?: boolean;
            className?: string;
        }): any;
    };
    export default _default_23;
}
declare module "api/tools/index" {
    import Ogma from "src/ogma";
    const createToolsAPI: (ogma: Ogma) => {
        lasso: {
            enable(options: import("modules/lasso").LassoOptions): any;
            disable(): any;
            enabled(): boolean;
        };
        connectNodes: {
            enable(options: import("api/tools/connectNodes").ConnectNodesOptions): any;
            disable(): any;
            enabled(): boolean;
        };
        legend: {
            enable(options: import("api/tools/legend").LegendOptions): Promise<void>;
            disable(): void;
            enabled(): boolean;
        };
        rectangleSelect: {
            enable: (options: import("modules/lasso").LassoOptions) => void;
            disable: () => void;
            enabled: () => boolean;
        };
        resize: {
            enable(options: import("api/tools/resizing").ResizingOptions): any;
            disable(): any;
            enabled(): boolean;
        };
        rewire: {
            enable(options: import("api/tools/rewiring").RewiringOptions): any;
            disable(): any;
            enabled(): boolean;
        };
        snapping: {
            enable(options: import("api/tools/snapping").SnappingOptions): any;
            disable(): any;
            enabled(): boolean;
        };
        tooltip: {
            onNodeHover(handler: (node: import('ogma').Node) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onNodeClick(handler: (node: import('ogma').Node) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onNodeRightClick(handler: (node: import('ogma').Node) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onNodeDoubleClick(handler: (node: import('ogma').Node) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onEdgeHover(handler: (edge: import('ogma').Edge) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onEdgeClick(handler: (edge: import('ogma').Edge) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onEdgeRightClick(handler: (edge: import('ogma').Edge) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onEdgeDoubleClick(handler: (edge: import('ogma').Edge) => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onBackgroundClick(handler: () => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onBackgroundRightClick(handler: () => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            onBackgroundDoubleClick(handler: () => string | Promise<string>, options?: import("api/tools/tooltip").TooltipOptions): void;
            refresh(): void;
            isShown(): boolean;
            hide(): void;
            show(html: any, options: {
                x: number;
                y: number;
                position?: import("api/tools/tooltip").TooltipPosition;
                autoAdjust?: boolean;
                className?: string;
            }): any;
        };
        brand: {
            set(html: string, options: import("api/tools/brand").BrandOptions): HTMLDivElement;
            remove(): void;
        };
    };
    export default class ToolsAPI {
        tools: ReturnType<typeof createToolsAPI>;
        static initNamespace(ogma: Ogma): void;
    }
}
declare module "modules/grouping/genericGrouping" {
    import { Transformation } from "modules/transformations/transformation";
    import { Item } from "modules/core/graph/item";
    import { ItemList } from "modules/core/graph/itemList";
    export const defaultItemSelector: (item: Item) => boolean;
    export const defaultGroupId: (item: Item) => string;
    export const defaultGeneratorFn: (item: ItemList, groupId: string, transformation: Transformation) => {};
}


declare module "api/transformations/grouping" {
    import Ogma from "src/ogma";
    import { Transformation } from "modules/transformations/transformation";
    import NodeList from "modules/core/graph/nodeList";
    import { NodeId, EdgeId } from "types/utilities";
    import { NodeAttributes } from "types/nodeAttributes";
    import { EdgeAttributes } from "types/edgeAttributes";
    import Edge from "modules/core/graph/edge";
    import Node from "modules/core/graph/node";
    import EdgeList from "modules/core/graph/edgeList";
    /**
     * @public
     *
     * @typedef {object} NodeDataAndAttributes
     * @property {NodeId} [id]
     * @property {any} [data]
     * @property {NodeAttributes} [attributes]
     */
    export interface NodeDataAndAttributes {
        id?: NodeId;
        data?: any;
        attributes?: NodeAttributes;
    }
    /**
     * @public
     * @typedef {object} EdgeDataAndAttributes
     * @property {EdgeId} [id]
     * @property {any} [data]
     * @property {EdgeAttributes} [attributes]
     */
    export interface EdgeDataAndAttributes {
        id?: EdgeId;
        data?: any;
        attributes?: EdgeAttributes;
    }
    export interface NodeGroupingOptions {
        selector?: (node: Node) => boolean;
        groupIdFunction?: (node: Node) => string;
        nodeGenerator?: (nodes?: NodeList, groupId?: string, transformation?: Transformation) => NodeDataAndAttributes;
        edgeGenerator?: (edges?: EdgeList, groupId?: string, transformation?: Transformation) => EdgeDataAndAttributes;
        groupEdges?: boolean;
        separateEdgesByDirection?: boolean;
        groupSelfLoopEdges?: boolean;
        restorePositions?: boolean;
        duration?: number;
        enabled?: boolean;
    }
    export interface EdgeGroupingOptions {
        selector?: (edge: Edge) => boolean;
        groupIdFunction?: (edge: Edge) => string;
        generator?: (edges: EdgeList, groupId: string, transformation: Transformation) => EdgeDataAndAttributes;
        separateEdgesByDirection?: boolean;
        duration?: number;
        enabled?: boolean;
    }
    const _default_24: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.addNodeGrouping
         * Group the nodes that match the same group id together. The groups are automatically updated when original nodes
         * are added, removed or when their data is updated.
         * @param {object} [options]
         * @param {function(node: Node): boolean} [options.selector] Only nodes that match this criteria will be grouped with
         * other nodes. By default, all the nodes will be assigned a group.
         * @param {function(node: Node): string} [options.groupIdFunction] Given a node, must return a string identifying a
         * group. All nodes for which the function returns the same value will be grouped together. By default group all the
         * nodes that were selected together.
         * @param {function(nodes: NodeList, groupId: string, transformation: Transformation): NodeDataAndAttributes} [options.nodeGenerator]
         * Given a list of nodes that should be grouped together, must return the new node (meta-node) to be added.
         * If `attributes.x` and `attributes.y` are not specified, the meta-node will be put at the center of the nodes.
         * @param {boolean} [options.groupEdges=true] Indicates if parallel edges that end up having at least one meta-node
         * extremity should be grouped together (to reduce cluttering).
         * @param {function(edges: EdgeList, groupId: string, transformation: Transformation): EdgeDataAndAttributes} [options.edgeGenerator]
         * If `groupEdges` is `true`, indicates the function used to generate the new edges from the sub-edges. Ignored if
         * `groupEdges` is `false`.
         * @param {boolean} [options.separateEdgesByDirection=false] By default, edges that have opposite source and target
         * are grouped together (resulting source and target not deterministic). If this option is `true`, they will not be grouped together.
         * @param {boolean} [options.groupSelfLoopEdges=false] If true, edges for which the two extremities end up being grouped
         * into the same node will be displayed as a self-loop edge, instead of not being displayed at all.
         * @param {boolean} [options.restorePositions=true] When the grouping is disabled/destroyed, indicates if the nodes should be positioned back around the meta-node position
         * @param {boolean} [options.enabled=true] Indicates if the grouping must be enabled.
         * @param {number}  [options.duration=0] Animation time in milliseconds. The animation will be played once after the creation of the group. Ignored if `enabled` is false.
         * @returns {Transformation} The added transformation
         * @example
         * // Imagine that each node represents a company.
         * // In this example we group all companies by country, only if the country is a member of the UE.
         *
         * var groupTransformation = ogma.transformations.addNodeGrouping({
         *   selector: function (node) {
         *     return node.getData('isCountryMemberOfUE') === true;
         *   },
         *
         *   groupIdFunction: function (node) {
         *     return node.getData('country');
         *   },
         *
         *   nodeGenerator: function (nodes) {
         *     return {
         *       // meta-nodes will appear in green with a size of 20
         *       attributes: {
         *         color: 'green',
         *         size: 20
         *       },
         *       data: {
         *         country: nodes.get(0).getData('country'),
         *         isCountryMemberOfUE: true
         *       }
         *     };
         *   }
         * });
         *
         * groupTransformation.whenApplied().then(function () {
         *   console.log('Grouping done!');
         * });
         */
        addNodeGrouping: (options?: NodeGroupingOptions) => Transformation;
        /**
         * @method Ogma.transformations.addEdgeGrouping
         * Group the edges that are parallel and match the same group id together. The groups are automatically updated when the original edges
         * are added, removed or when their data is updated.
         * @param {object} [options]
         * @param {function(edge: Edge): boolean} [options.selector] Only edges that match this criteria will be grouped with
         * other edges. By default, all the edges will be assigned a group.
         * @param {function(edge: Edge): string} [options.groupIdFunction] Given an edge, must return a string identifying a
         * group. All edges that are parallel and for which the function returns the same value will be grouped together. By
         * default matches all the edges that are parallel together. The returned string will be used as prefix of the final id.
         * @param {function(edges: EdgeList, groupId: string, transformation: Transformation): EdgeDataAndAttributes} [options.generator]
         * Given a list of edges that should be grouped together, must return the new edge (meta-edge) to be added.
         * @param {boolean} [options.separateEdgesByDirection=false] By default, edges that have opposite source and target
         * are grouped together (resulting source and target not deterministic). If this option is `true`, they will not be grouped together.
         * @param {boolean} [options.enabled=true] Indicates if the edge grouping must be enabled.
         * @returns {Transformation} The added transformation
         * @example
         * // Most simple case, groups all parallel edges with the same direction together
         * ogma.transformations.addEdgeGrouping();
         */
        addEdgeGrouping: (options?: EdgeGroupingOptions) => Transformation;
    };
    export default _default_24;
}
declare module "api/transformations/filters" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import { Transformation } from "modules/transformations/transformation";
    import Edge from "modules/core/graph/edge";
    export type NodeFilterCriterion = (node: Node) => boolean;
    export interface NodeFilterOptions {
        criteria: NodeFilterCriterion;
        enabled?: boolean;
        diration?: number;
    }
    export type EdgeFilterCriterion = (node: Edge) => boolean;
    export interface EdgeFilterOptions {
        criteria: EdgeFilterCriterion;
        enabled?: boolean;
        diration?: number;
    }
    const _default_25: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.addNodeFilter
         * Hide all nodes for which the specified function evaluate to false. The filter is applied as long as it's
         * not removed and is updated when nodes are added/removed/their data is updated. Also hides the edges adjacent
         * to the hidden nodes.
         * @param {object|function(node: Node): boolean} options
         * @param {function(node: Node): boolean} options.criteria
         * @param {boolean} [options.enabled=true] Indicates if the filter must be enabled.
         * @param {number} [options.duration=0] Duration of the filtering animation. When filtering is animated,
         * nodes are gradually faded, before disappearing completely. Ignored if `enabled` is false.
         * @returns {Transformation}
         * @example
         * // Hides all the nodes for which the `country` data property is not "USA", and remove the filter 1 second after
         * var filter = ogma.addNodeFilter(function (node) {
         *   return node.getData('country') === 'USA';
         * });
         *
         * filter.whenApplied().then(function () {
         *   console.log('filter applied');
         *   return filter.destroy();
         * }).then(function() {
         *   console.log('filter removed');
         * });
         */
        addNodeFilter: (options: NodeFilterOptions | NodeFilterCriterion) => Transformation;
        /**
         * @method Ogma.transformations.addEdgeFilter
         * Hide all edges for which the specified function evaluate to false. The filter is applied as long as it's
         * not removed and is updated when edges are added/removed/their data is updated. Also hides the edges adjacent
         * to the hidden edges.
         * @param {object|function(edge: Edge): boolean} options
         * @param {function(edge: Edge): boolean} options.criteria
         * @param {boolean} [options.enabled=true] Indicates if the filter must be enabled.
         * @param {number} [options.duration=0] Duration of the filtering animation. When filtering is animated,
         * edges are gradually faded, before disappearing completely. Ignored if `enabled` is false.
         * @returns {Transformation}
         */
        addEdgeFilter: (options: EdgeFilterOptions | EdgeFilterCriterion) => Transformation;
    };
    export default _default_25;
}
declare module "api/transformations/neighbors" {
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import { Transformation } from "modules/transformations/transformation";
    import { RawNode, RawEdge } from "types/utilities";
    const _default_26: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.addNeighborGeneration
         * For each node that match the selector, create one or more neighbor nodes, each identified by a string.
         * If multiple nodes give the same string identifier, they will all share the same neighbor.
         * @param {object} options
         * @param {function(node: Node): boolean} [options.selector] If unspecified, defaults to a function that
         * always returns true.
         * @param {function(node: Node): string|Array<string>|null} options.neighborIdFunction
         * String identifying the neighbor that will be created. An array of string can be passed; in this case multiple
         * neighbors are created. If `null` is returned, no neighbor is created.
         * @param {function(identifier: string, nodes: NodeList): RawNode} [options.nodeGenerator]
         * Given the nodes that spawned it and its identifier (which is not its final id, but is part of it),
         * returns the node that must be created. If unspecified, a node with no data and with default attributes
         * is created.
         * @param {function(originalNode: Node, generatedNode: Node): RawEdge} [options.edgeGenerator]
         * Given the original node and the generated neighbor, returns the edge that must be created between them.
         * Source and target may be specified; otherwise the original node is the source and the generated node is the
         * target. If this parameter is unspecified, an edge with no data and with default attributes is created.
         * @param {number} [options.duration=0]
         * @param {boolean} [options.enabled=true]
         * @returns {Transformation}
         * @example
         * var transformation = ogma.transformations.addNeighborsGeneration({
         *   selector: function(node){ return node.getData('type') === 'person'; },
         *   neighborIdFunction: function(node){ return node.getData('country'); },
         *   nodeGenerator: function(nodes, countryName) {
         *     return {
         *       data: {
         *         type: 'country',
         *         name: countryName,
         *         population: nodes.size
         *       }
         *     };
         *   }
         * });
         */
        addNeighborGeneration: (options: {
            selector?: (node: Node) => boolean;
            neighborIdFunction: (node: Node) => string | string[];
            nodeGenerator?: (originalNode: Node, generatedNode: Node) => RawNode;
            edgeGenerator?: (originalNode: Node, generatedNode: Node) => RawEdge;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
        /**
         * @method Ogma.transformations.addNeighborMerging
         * Hide the nodes that match the selector, and add the data properties
         * specified by `dataFunction` to their neighbors. When the transformation is
         * destroyed or disabled, the data of the affected nodes is restored.
         * @param {object} options
         * @param {function(node: Node): boolean} options.selector
         * @param {function(node: Node): object|undefined} [options.dataFunction] If unspecified or if it returns
         * `undefined`, no data is added to the neighbors.
         * @param {number} [duration=0]
         * @param {boolean} [enabled=true]
         * @returns {Transformation}
         * @example
         * // Hides all the countries, and add a "country" property to their neighbors
         * var transformation = ogma.transformations.addNeighborsMerging({
         *   selector: function(node) {
         *     return node.getData('type') === 'country';
         *   }
         *   dataFunction: function(node) {
         *     return { country: node.getData('name') };
         *   }
         * });
         */
        addNeighborMerging: (options: {
            selector: (node: Node) => boolean;
            dataFunction: (node: Node) => object;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
    };
    export default _default_26;
}
declare module "api/transformations/nodeCollapsing" {
    import Ogma from "src/ogma";
    import EdgeList from "modules/core/graph/edgeList";
    import Node from "modules/core/graph/node";
    import { RawEdge } from "types/utilities";
    import { Transformation } from "modules/transformations/transformation";
    const _default_27: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.addNodeCollapsing
         * Hide the nodes that match the specified selector. For each of the hidden nodes, create an edge between each
         * pair of adjacent nodes of this node. In essence, it's transforming the graph such as (A -> B -> C) becomes
         * (A -> C), with B being a node that matches the selector.
         * @param {object} options
         * @param {function(node: Node): boolean} options.selector Function indicating which nodes will be hidden.
         * @param {function(hiddenNode: Node, node1: Node, node2: Node, edges1: EdgeList, edges2: EdgeList): RawEdge|null} [options.edgeGenerator]
         * Function returning the RawEdge to create for each pair of adjacent nodes.
         * `hiddenNode` is the node that is hidden (matches `selector`).
         * `node1` is the first neighbor of the pair.
         * `node2` is the second neighbor of the pair.
         * `edges1` is the list of edges between the hidden node and the first neighbor of the pair.
         * `edges2` is the list of edges between the hidden node and the second neighbor of the pair.
         * The source and target of the edge may be specified; if it's the case they must be either `node1` or `node2`.
         * If it's not the case, an exception will be thrown. If source/target are not specified and the edges follow a
         * consistent direction (e.g A <- B <- C), the source and target are assigned according to that direction
         * (here A <- B). Otherwise (e.g A -> B <- C), `node1` is used as the source and `node2` is used as the target.
         * If `null` is returned, no edge is created between the two nodes.
         * If no edge generator is specified, a default edge is created.
         * @param {number} [options.duration=0]
         * @param {boolean} [options.enabled=true]
         * @returns {Transformation}
         * @example
         * var nodeCollapsing = ogma.transformations.addNodeCollapsing({
         *   selector: function(node) {
         *     return node.getData('foo') === 'bar'
         *   }
         * });
         */
        addNodeCollapsing: (options?: {
            selector?: (node: Node) => boolean;
            edgeGenerator?: (hiddenNode: Node, node1: Node, node2: Node, edges1: EdgeList, edges2: EdgeList) => RawEdge;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
    };
    export default _default_27;
}
declare module "api/transformations/virtualProperties" {
    import Ogma from "src/ogma";
    import { Transformation } from "modules/transformations/transformation";
    import Node from "modules/core/graph/node";
    import Edge from "modules/core/graph/edge";
    const _default_28: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.addVirtualProperties
         * Add (or overwrite) some data properties to the specified nodes and edges. When the transformation
         * is disabled/destroyed, the old data is restored.
         * @param {object} options
         * @param {function(node: Node): boolean} [options.nodeSelector] Indicates if the transformation should be applied
         * to a given node. If unspecified, it is applied to all nodes.
         * @param {function(node: Node): object} [options.nodeDataFunction] Indicates which data properties to add to a node.
         * If unspecified, no data property will be added to any node.
         * @param {function(edge: Edge): boolean} [options.edgeSelector] Indicates if the transformation should be applied
         * to a given edge. If unspecified, it is applied to all edges.
         * @param {function(edge: Edge): object} [options.edgeDataFunction] Indicates which data properties to add to a edge.
         * If unspecified, no data property will be added to any edge.
         * @param {boolean} [options.enabled=true]
         * @returns {Transformation}
         * @example
         * // Very simple example that adds a data property indicating the id of all nodes which match a criteria
         * var virtualProperties = ogma.transformations.addVirtualProperties({
         *   nodeSelector: function(node) {
         *     return node.getData('foo') === 'bar'
         *   },
         *   nodeDataFunction: function(node) {
         *     return {
         *       id: node.getId()
         *     };
         *   }
         * });
         */
        addVirtualProperties: (options: {
            nodeSelector?: (node: Node) => boolean;
            nodeDataFunction?: (node: Node) => object;
            edgeSelector?: (edge: Edge) => boolean;
            edgeDataFunction?: (edge: Edge) => object;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
    };
    export default _default_28;
}
declare module "api/transformations/transformations" {
    import { Transformation } from "modules/transformations/transformation";
    import Ogma from "src/ogma";
    const _default_29: (ogma: Ogma) => {
        /**
         * @method Ogma.transformations.getList
         * Returns the list of transformations applied to the graph.
         * @returns {Array<Transformation>}
         */
        getList: () => Transformation[];
        /**
         * @method Ogma.transformations.clear
         * Clear all transformations.
         * @returns {Promise<void>}
         */
        clear: () => Promise<void>;
        /**
         * @method Ogma.transformations.afterNextUpdate
         * Returns a Promise that resolves after the next time the transformations are updated
         * @returns {Promise<void>}
         * @example
         * // Add a filter
         * ogma.addNodeFilter(node => node.getData('country') === 'USA');
         *
         * // Adding a node will trigger the refresh of transformations
         * ogma.addNode({id: 'foo', data: {country: 'Brazil'}});
         *
         * ogma.transformations.afterNextUpdate().then(() => {
         *   // The transformations have been re-applied, the added node is now hidden
         * });
         */
        afterNextUpdate: () => Promise<void>;
    };
    /**
     * @extends Options.interactions
     * @property {object}   [transformations]
     * @property {boolean}  [transformations.updateOnDataChange=true] Indicates if the transformations should be re-computed when the data of a node or edge changes.
     */
    export default _default_29;
}
declare module "api/transformations/index" {
    import { EdgeFilterCriterion, EdgeFilterOptions, NodeFilterCriterion, NodeFilterOptions } from "api/transformations/filters";
    import Ogma from "src/ogma";
    import { Transformation } from "modules/transformations/transformation";
    /**
     * @namespace Ogma.transformations
     *
     * Transformations allow to change the structure of the graph based on rules. For example, a grouping
     * transformation can group together nodes that share the same `country` data property: nodes that compose the groups
     * are virtually removed from the graph (they can still be manipulated via the API but are not visible anymore) and new
     * nodes, which represent the groups, are added to the graph. These new nodes can be manipulated like regular nodes
     * but cannot be removed. Nodes and edges that are created this way are called "virtual".
     *
     * There are currently two types of transformations: groups and filters. Filters hide nodes/edges based on a criteria.
     *
     * Multiple transformations can be applied at once, in which case they are applied one after another. For example you
     * can filter, group and then filter again based on the result of the grouping.
     *
     * Transformations are automatically updated in the following cases:
     *
     * - a transformation is added/removed/enabled/disabled
     * - a node/edge is added/removed
     * - the data of a node/edge changes (only if the option `transformation.updateOnDataChange` is `true`)
     *
     * When transformations are updated, all transformations are undone and then run again. Transformation updates are
     * batched, making sure multiple events that trigger an update will only result in one single update.
     */
    const createTransformationsAPI: (ogma: Ogma) => {
        addVirtualProperties: (options: {
            nodeSelector?: (node: import('ogma').Node) => boolean;
            nodeDataFunction?: (node: import('ogma').Node) => object;
            edgeSelector?: (edge: import('ogma').Edge) => boolean;
            edgeDataFunction?: (edge: import('ogma').Edge) => object;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
        addNodeCollapsing: (options?: {
            selector?: (node: import('ogma').Node) => boolean;
            edgeGenerator?: (hiddenNode: import('ogma').Node, node1: import('ogma').Node, node2: import('ogma').Node, edges1: import('ogma').EdgeList, edges2: import('ogma').EdgeList) => import('ogma').RawEdge;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
        addNeighborGeneration: (options: {
            selector?: (node: import('ogma').Node) => boolean;
            neighborIdFunction: (node: import('ogma').Node) => string | string[];
            nodeGenerator?: (originalNode: import('ogma').Node, generatedNode: import('ogma').Node) => import('ogma').RawNode;
            edgeGenerator?: (originalNode: import('ogma').Node, generatedNode: import('ogma').Node) => import('ogma').RawEdge;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
        addNeighborMerging: (options: {
            selector: (node: import('ogma').Node) => boolean;
            dataFunction: (node: import('ogma').Node) => object;
            duration?: number;
            enabled?: boolean;
        }) => Transformation;
        addNodeFilter: (options: NodeFilterOptions | NodeFilterCriterion) => Transformation;
        addEdgeFilter: (options: EdgeFilterOptions | EdgeFilterCriterion) => Transformation;
        addNodeGrouping: (options?: import("api/transformations/grouping").NodeGroupingOptions) => Transformation;
        addEdgeGrouping: (options?: import("api/transformations/grouping").EdgeGroupingOptions) => Transformation;
        getList: () => Transformation[];
        clear: () => Promise<void>;
        afterNextUpdate: () => Promise<void>;
    };
    export default class TransformationsAPI {
        transformations: ReturnType<typeof createTransformationsAPI>;
        static initNamespace(ogma: Ogma): void;
        /**
         * @method Ogma.addNodeFilter
         * Alias for `ogma.transformations.addNodeFilter()`
         * @param {object|function(node: Node): boolean} options
         * @param {function(node: Node): boolean} options.criteria
         * @param {number} [options.duration=0]
         * @returns {Transformation}
         * @deprecated
         */
        addNodeFilter(options: NodeFilterCriterion | NodeFilterOptions): Transformation;
        /**
         * @method Ogma.addEdgeFilter
         * Alias for `ogma.transformations.addEdgeFilter()`
         * @param {object|function(edge: Edge): boolean} options
         * @param {function(edge: Edge): boolean} options.criteria
         * @param {number} [options.duration=0]
         * @returns {Transformation}
         * @deprecated
         */
        addEdgeFilter(options: EdgeFilterCriterion | EdgeFilterOptions): Transformation;
        /**
         * @method Ogma.getNodeFilters
         * Retrieve all node filters.
         * @returns {Array<Transformation>}
         * @deprecated
         * @example Same as
         * var nodeFilters = ogma.transformations.getList().filter(function(transformation) {
         *   return transformation.getName() === 'node-filter';
         * });
         */
        getNodeFilters(): Transformation[];
        /**
         * @method Ogma.getEdgeFilters
         * Retrieve all edge filters.
         * @returns {Array<Transformation>}
         * @deprecated
         * @example
         * //Same as
         * var edgeFilters = ogma.transformations.getList().filter(function(transformation) {
         *   return transformation.getName() === 'edge-filter';
         * });
         */
        getEdgeFilters(): Transformation[];
        /**
         * @method Ogma.clearNodeFilters
         * Remove all node filters.
         * @returns {Promise<void>}
         * @deprecated
         * @example Same as
         * var promise = Promise.all(ogma.transformations.getList().filter(function(transformation) {
         *   return transformation.getName() === 'node-filter';
         * }).map(function(transformation) {
         *   return transformation.destroy();
         * }));
         */
        clearNodeFilters(): Promise<void>;
        /**
         * @method Ogma.clearEdgeFilters
         * Remove all edge filters.
         * @returns {Promise<void>}
         * @deprecated
         * @example Same as
         * var promise = Promise.all(ogma.transformations.getList().filter(function(transformation) {
         *   return transformation.getName() === 'edge-filter';
         * }).map(function(transformation) {
         *   return transformation.destroy();
         * }));
         */
        clearEdgeFilters(): Promise<void>;
    }
}
declare module "geometry/index" {
    export * from "geometry/circle";
    export * from "geometry/lines";
    export * from "geometry/basics";
    export * from "geometry/polygons";
    export * from "geometry/curves";
    export * from "geometry/bounds";
}
declare module "src/ogma" {
    import AlgorithmsAPI from "api/algorithms";
    import ClassesAPI from "api/classes";
    import CaptorAPI from "api/captor";
    import DebugAPI from "api/debug";
    import DomAPI from "api/dom";
    import EventsAPI from "api/events";
    import ExportsAPI from "api/exports/index";
    import GeneratorsAPI from "api/generators";
    import GeoAPI from "api/geo";
    import GraphAPI from "api/graph";
    import GraphicsAPI from "api/graphics";
    import ImportsAPI from "api/imports";
    import KeyboardAPI from "api/keyboard";
    import LayoutsAPI from "api/layouts/index";
    import MouseAPI from "api/mouse";
    import PathfindingAPI from "api/pathfinding";
    import RulesAPI from "api/rules";
    import SelectionAPI from "api/selection";
    import SettingsAPI from "api/settings";
    import StylesAPI from "api/styles";
    import SchemaAPI from "api/schema";
    import ToolsAPI from "api/tools/index";
    import TransformationsAPI from "api/transformations/index";
    import ViewAPI from "api/view";
    import { Options } from "modules/core/settings";
    import { RawGraph, CrossOriginValue, RendererType } from "types/utilities";
    export interface OgmaParameters {
        dimensions?: {
            width?: number;
            height?: number;
        };
        renderer?: RendererType;
        options?: Options;
        container?: HTMLElement | string;
        graph?: RawGraph;
        imgCrossOrigin?: CrossOriginValue;
    }
    class Ogma {
        static libraries: {
            [key: string]: any;
        };
        constructor(parameters?: OgmaParameters);
        /**
         * @method Ogma.destroy
         * Release the memory used and removes all connections between Ogma and the
         * DOM. After this method is called, Ogma's container will not contain any DOM
         * element  created by Ogma. Global DOM elements such as `window` and
         * `document`'s event listeners added by Ogma will be removed. All
         * `setTimeout` created by Ogma will be cleared.
         *
         * @example
         * var ogma = new Ogma({
         *   container: 'graph-container'
         * );
         *
         * ogma.setGraph({
         *   nodes: [{id: 0}, {id: 1}],
         *   edges: [{id: 0, source: 0, target: 1}]
         * });
         *
         * ogma.destroy();
         */
        destroy(): void;
        /**
         * @method Ogma.reset
         * Reset Ogma to its initial state. Doing `ogma.reset();` has the same effect as
         * `ogma.destroy(); ogma = new Ogma(params);`, with `params` being the parameters used the
         * first time Ogma was instantiated.
         */
        reset(): void;
        static build: {
            version: string;
            commit: string;
            date: string;
        };
    }
    interface Ogma extends AlgorithmsAPI, ClassesAPI, CaptorAPI, DomAPI, DebugAPI, EventsAPI, ExportsAPI, GeneratorsAPI, GeoAPI, GraphAPI, GraphicsAPI, ImportsAPI, KeyboardAPI, LayoutsAPI, PathfindingAPI, SelectionAPI, SettingsAPI, StylesAPI, ToolsAPI, TransformationsAPI, ViewAPI, MouseAPI, SchemaAPI, RulesAPI {
    }
    export default Ogma;
}
declare module "ogma" {
    /**
     * This file is to generate `d.ts` only. It makes use of the fact that TS
     * supports simultaneous named and default exports and makes the new `d.ts`
     * compliant
     */
    import Ogma from "src/ogma";
    import Node from "modules/core/graph/node";
    import NodeList from "modules/core/graph/nodeList";
    import Edge from "modules/core/graph/edge";
    import EdgeList from "modules/core/graph/edgeList";
    import { Item, ItemId } from "modules/core/graph/item";
    import { ItemList } from "modules/core/graph/itemList";
    import { RawNode, RawEdge, RawItem, RawGraph, NodeId, EdgeId, Color, AdjacencyOptions, AttributeAnimationOptions, CrossOriginValue, Dependency, Easing, EasingFunction, NodeCollection, EdgeCollection, NodeSelector, EdgeSelector, NodeDependencies, EdgeDependencies, NodeOutput, EdgeOutput, EdgeDirection, PixelSize, ScalingMethod, TextContent, TextAlign, FontStyle, LayerValue, OpacityValue, RendererErrorCode, RendererState, RendererType } from "types/utilities";
    import StyleRule, { NodeStyleRuleDefinition } from "modules/styleRules/styleRule";
    import { Transformation } from "modules/transformations/transformation";
    import NonObjectPropertyWatcher from "modules/watcher/nonObjectWatcher";
    import ObjectPropertyWatcher from "modules/watcher/objectWatcher";
    import { GeoModeOptions, MapPosition, GeoCoordinate } from "api/geo";
    import { PropertyPath } from "api/data";
    import BoundingBox from "utils/boundingBox";
    import { BrandOptions } from "api/tools/brand";
    import { LegendOptions } from "api/tools/legend";
    import { CameraAnimationOptions, LocateOptions, View, ZoomBoundaryFunction } from "api/view";
    import { CursorStyle } from "modules/core/dom";
    import { NodeAttributes, NodeShape } from "types/nodeAttributes";
    import { EdgeAttributes, EdgeExtremity, EdgeStyle, EdgeType, PredefinedEdgeShape } from "types/edgeAttributes";
    import { NodeAttributesValue, EdgeAttributesValue } from "types/utilities";
    import { NodeTextStyleValue, EdgeTextStyleValue } from "types/textStyles";
    import { Badge, BadgeImage } from "types/badge";
    import { NodeDataAndAttributes, EdgeDataAndAttributes } from "api/transformations/grouping";
    import { Options } from "modules/core/settings";
    import { ImageExportOptions } from "api/exports/png";
    import { LayoutOptions } from "api/layouts/layoutOptions";
    import { MouseButton, InputTarget, InputSource } from "api/captor";
    import { WatcherOptions } from "api/schema";
    import { KeyCode, KeyName } from "api/keyboard";
    import StyleClass, { StyleClassDefinition } from "modules/classes/styleClass";
    export default Ogma;
    export { Node, NodeList, Edge, EdgeList, Item, ItemList, ItemId, RawNode, RawEdge, RawItem, RawGraph, NodeId, EdgeId, Color, AdjacencyOptions, Easing, EasingFunction, RendererErrorCode, RendererState, RendererType, PropertyPath, BoundingBox, CrossOriginValue, Dependency, AttributeAnimationOptions, CursorStyle, PixelSize, ScalingMethod, TextContent, TextAlign, FontStyle, LayerValue, OpacityValue, NodeTextStyleValue, EdgeTextStyleValue, Badge, BadgeImage, NonObjectPropertyWatcher, ObjectPropertyWatcher, StyleRule, Transformation, BrandOptions, GeoModeOptions, GeoCoordinate, MapPosition, CameraAnimationOptions, ImageExportOptions, LayoutOptions, LegendOptions, LocateOptions, View, ZoomBoundaryFunction, MouseButton, InputSource, InputTarget, WatcherOptions, KeyCode, KeyName, StyleClassDefinition, StyleClass, NodeAttributes, EdgeAttributes, NodeAttributesValue, EdgeAttributesValue, NodeCollection, EdgeCollection, NodeDataAndAttributes, EdgeDataAndAttributes, NodeSelector, EdgeSelector, NodeDependencies, EdgeDependencies, NodeOutput, EdgeOutput, NodeShape, NodeStyleRuleDefinition, EdgeExtremity, EdgeStyle, EdgeDirection, EdgeType, PredefinedEdgeShape, Options };
}

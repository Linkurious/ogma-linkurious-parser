export declare type Type = 'null' | 'undefined' | 'array' | 'object' | 'number' | 'NaN' | 'boolean' | 'string' | 'function';
export declare type TypeArticle = {
    [key in Type]: string;
};
export declare type FieldPolicy = 'strict' | 'strictExist' | 'inclusive';
/**
 * @typedef {object} FieldDefinition
 * @property {boolean|undefined} required Whether the property is required.
 * @property {string|undefined} requiredUnless The property will be required unless another property called `requiredUnless` exists at the same level.
 * @property {string|undefined} requiredIf The property will be required if another property called `requiredIf` exists at the same level.
 * @property {string|undefined} deprecated Whether the property is deprecated (if defined), and for which reason.
 * @property {Array<*>|undefined} values List of allowed values for the property.
 * @property {string|string[]|undefined} type The allowed type(s) of the property.
 * @property {function|string|Array<*>|undefined} check Called with `value` and `key` for specific property validation.
 * @property {FieldDefinition|undefined} arrayItem Validate array items (forces `type` to "array").
 * @property {number|undefined} arraySize Validate array size (forces `type` to "array").
 * @property {FieldDefinition|undefined} anyProperty Validate any nested properties (forces `type` to "object").
 * @property {object.<string, FieldDefinition>|undefined} properties Validate listed nested properties (forces `type` to "object").
 * @property {string|undefined} policy When using `properties`, whether the properties are:
 *                                                - "strict" (default): Only described properties are allowed.
 *                                                - "strictExist": Only described properties are allowed, at least one must be present.
 *                                                - "inclusive": Non-described properties are allowed.
 */
export interface FieldDefinition<E> {
    required?: boolean;
    requiredUnless?: string;
    requiredIf?: string;
    deprecated?: string;
    values?: Array<unknown>;
    type?: Type | Type[];
    check?: ((key: string, value: unknown) => (E | void)) | [keyof Valcheck<E>, ...Array<unknown>] | keyof Valcheck<E>;
    arrayItem?: FieldDefinition<E>;
    arraySize?: number;
    anyProperty?: FieldDefinition<E>;
    properties?: {
        [key: string]: FieldDefinition<E>;
    };
    policy?: FieldPolicy;
}
/**
 * @class Valcheck
 */
export declare class Valcheck<E> {
    bugHandler: (error: string) => E;
    errorHandler: (error: string) => E;
    /**
     * A validator.
     *
     * The error and bug handlers MUST return a truthy value or throw.
     * Examples of *non-truthy* values:
     * - 0
     * - "" (an empty string)
     * - NaN
     * - null
     * - undefined
     *
     * @param {function(string):*} errorHandler a function that must handle check-error message
     * @param {function(string):*} bugHandler a function that  must handle code-bug message
     */
    constructor(errorHandler?: (error: string) => E, bugHandler?: (error: string) => E);
    private DEFAULT_ERROR_HANDLER;
    /**
     * Handle a check failure
     *
     * @param {string} key
     * @param {string} message
     * @return {*} a truthy value in case of error.
     * @private
     */
    protected _error(key: string, message: string): E;
    /**
     * Handle library usage bugs.
     *
     * @param {string} message
     * @returns {*} a truthy value in case of bug.
     * @private
     */
    protected _bug(message: string): E;
    /**
     * Checks if 'value' is a non-empty string
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @returns {*} error, if any
     */
    nonEmpty(key: string, value: unknown): E | void;
    /**
     * Checks if 'value' is a string
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @param {boolean} [nonEmpty=false] whether to fail id the string is empty
     * @param {boolean} [noSpace=false] whether to fail if the string contains spaces
     * @param {number} [minSize]
     * @param {number} [maxSize]
     * @returns {*} error, if any
     */
    string(key: string, value: unknown, nonEmpty?: boolean, noSpace?: boolean, minSize?: number, maxSize?: number): E | void;
    /**
     * Checks if `value` starts with `prefix`.
     *
     * @param {string} key value name
     * @param {*} value tested value
     * @param {string} prefix
     * @param {boolean} [needSuffix=true] Whether the value must be longer than the given prefix.
     * @returns {*} error, if any
     */
    startsWith(key: string, value: unknown, prefix: string, needSuffix?: boolean): E | void;
    /**
     * Checks if `value` is a hexadecimal color string.
     *
     * @param {string} key name of the value
     * @param {*} value tested value
     * @param {boolean} [allowShort=true] Whether to allow short hex colors (#ABC)
     * @returns {*} error, if any
     */
    hexColor(key: string, value: unknown, allowShort?: boolean): E | void;
    /**
     * Checks if `value` is a rgb/rgba color expression.
     *
     * @param {string} key
     * @param {*} value
     * @returns {*} error, if any
     */
    rgbColor(key: string, value: unknown): E | void;
    /**
     * Checks if `value` is a CSS color expression (hexadecimal, rgb, rgba or colorname)
     *
     * @param {string} key
     * @param {*} value
     * @returns {*} error, if any
     */
    cssColor(key: string, value: unknown): E | void;
    /**
     * Check if 'value' is neither null nor undefined
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @returns {*} error, if any
     */
    exist(key: string, value: unknown): E | void;
    /**
     * Check that value is null.
     *
     * @param {string} key
     * @param {*} value
     * @returns {*} error, if any
     */
    'null'(key: string, value: unknown): E | void;
    /**
     * Check if 'value' is a defined object
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @returns {*} error, if any
     */
    object(key: string, value: unknown): E | void;
    /**
     * Check if `value` is an array (with length between `minLength` and `maxLength`)
     *
     * @param {string} key
     * @param {*} value
     * @param {number} [minLength]
     * @param {number} [maxLength]
     * @returns {*} error, if any
     */
    array(key: string, value: unknown, minLength?: number, maxLength?: number): E | void;
    /**
     * Check if  number is in an interval.
     *
     * @param {string} key Main value key.
     * @param {number} value Number to validate interval for.
     * @param {string} errorPrefix Error prefix string.
     * @param {number} [min] Minimum value.
     * @param {number} [max] Maximum value.
     * @returns {*} error, if any
     * @private
     */
    protected _checkInterval(key: string, value: number, errorPrefix: string, min?: number, max?: number): E | void;
    /**
     * Check if 'value' is a positive integer (excluding: NaN, Infinity).
     *
     * @param {string} key value key
     * @param {*} value tested value
     */
    posInt(key: string, value: unknown): E | void;
    /**
     * Check if `value` is an array of integers.
     *
     * @param {string} key
     * @param {*}      value
     * @param {number} [minSize]
     * @param {number} [maxSize]
     * @returns {*} error, if any
     */
    intArray(key: string, value: unknown, minSize?: number, maxSize?: number): E | void;
    /**
     * Check if `value` is an array of strings.
     *
     * @param {String} key
     * @param {*} value
     * @param {number} [minSize]
     * @param {number} [maxSize]
     * @param {boolean} [nonEmpty=false] check that no string in the array is empty
     * @returns {*} error, if any
     */
    stringArray(key: string, value: unknown, minSize?: number, maxSize?: number, nonEmpty?: boolean): E | void;
    /**
     * Check if 'value' is an integer (excluding: NaN, Infinity).
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @param {number} [min=-Infinity] the minimum accepted value
     * @param {number} [max=+Infinity] the maximum accepted value
     * @returns {*} error, if any
     */
    integer(key: string, value: unknown, min?: number, max?: number): E | void;
    /**
     * Check if 'value' is a finite number (excluding: NaN, Infinity).
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @param {number} [min=-Infinity] Minimum accepted value
     * @param {number} [max=+Infinity] Maximum accepted value
     * @returns {*} error, if any
     */
    number(key: string, value: unknown, min?: number, max?: number): E | void;
    /**
     * Check if 'value' exists in 'legalValues'
     *
     * @param {string} key value key
     * @param {*} value tested value
     * @param {Array<*>} allowed accepted values
     * @param {boolean} [showInvalidValue=false] whether to display the invalid value in case of error
     * @returns {*} error, if any
     */
    values(key: string, value: unknown, allowed: Array<unknown>, showInvalidValue?: boolean): E | void;
    /**
     * @param {Array<*>} list
     * @returns {string}
     * @private
     */
    private static _array2string;
    /**
     * Check if all keys in `object` are in `acceptedKeys`
     *
     * @param {string} key object key.
     * @param {object} object object to check.
     * @param {string[]} [acceptedKeys] array of properties keys that are authorized on `object`.
     * @param {string[]|boolean} [mandatoryKeys] Array of property keys that are mandatory on `object` (or `true` if all accepted keys are mandatory).
     * @param {string[]} [forbiddenKeys] Array of property keys that are forbidden on `object`.
     * @returns {*} error, if any
     */
    objectKeys(key: string, object: object, acceptedKeys?: string[], mandatoryKeys?: string[] | boolean, forbiddenKeys?: string[]): E | void;
    /**
     * Check if the properties of `value` match their description.
     *
     * @param {string} key Object key.
     * @param {*} value Object to check.
     * @param {object.<string, FieldDefinition>} properties Description of allowed properties.
     * @param {string} [policy="strict"] "strict", "strictExist" or "inclusive".
     * @returns {*} error, if any
     */
    properties(key: string, value: object, properties: {
        [key: string]: FieldDefinition<E>;
    }, policy?: FieldPolicy): E | void;
    /**
     * @param {string} key
     * @param {*} value
     * @param {FieldDefinition} definition
     * @param {object|array} [parent] Reference of parent object for `requiredUnless` and `requiredIf`.
     * @returns {*} error, if any
     */
    property(key: string, value: unknown, definition: FieldDefinition<E>, parent?: object): E | void;
    /**
     * Check if `value` matches the given regular expression.
     *
     * @param {string} key
     * @param {*} value
     * @param {RegExp} regexp
     * @returns {*} error, if any
     */
    regexp(key: string, value: unknown, regexp: RegExp): E | void;
    /**
     * Check if value is a valid URL
     *
     * @param {string} key
     * @param {*} value
     * @param {string} [scheme]
     * @return {*} error, if any
     */
    url(key: string, value: unknown, scheme?: string): E | void;
    /**
     * Check if value is an http(s) URL.
     *
     * @param {string} key
     * @param {*} value
     * @return {*} error, if any
     */
    httpUrl(key: string, value: unknown): E | void;
    /**
     * Check if the value is a valid port number
     *
     * @param {string} key
     * @param {*} value
     * @returns {*} error, if any
     */
    port(key: string, value: unknown): E | void;
    /**
     * Check if the type of `value` matches allowed `type`.
     *
     * @param {string} key Object key.
     * @param {*} value Object to check.
     * @param {string|string[]} allowed Allowed type(s) (use "null" type for null values).
     * @returns {*} error, if any
     */
    type(key: string, value: unknown, allowed: Type | Type[]): E | void;
    /**
     * Extract the type of `value`.
     * Returns "null" for null, "array" for Arrays and 'NaN' for NaN.
     *
     * @param {*} value
     * @returns {string} "null", "undefined", "array", "object", "number", "NaN", "boolean", "string", "function".
     */
    getType(value: unknown): Type;
    /**
     * Convert an (item or list of items) into a (list of items).
     *
     * @param {*|Array<*>|null|undefined} item
     * @param {Array<*>} defaultValue Alternative return value if item is null or undefined.
     * @returns {Array<*>|null|undefined}
     * @private
     */
    protected _itemOrList<T>(item: T | T[] | null | undefined, defaultValue: T[]): T[];
    /**
     * @param {*} v
     * @returns {boolean} true if v is null or undefined
     * @private
     */
    private static _notSet;
    /**
     * Fail if `value` is not a boolean.
     *
     * @param {string} key
     * @param {*} value
     * @param {boolean} [optional=false] Whether to tolerate undefined values
     * @param {boolean} [wantedValue] exact required value for `value`.
     * @returns {*} error, if any
     */
    boolean(key: string, value: unknown, optional?: boolean, wantedValue?: boolean): E | void;
    /**
     * Fail if more than of property listed in `exclusiveKeys` exists in `object`.
     *
     * @param {string} key object key
     * @param {object} object object to check
     * @param {string[]} exclusiveKeys array of properties that are mutually exclusive
     * @param {boolean} [required=false] whether at least one of the properties must be set
     * @returns {*} error, if any
     */
    exclusive(key: string, object: object, exclusiveKeys: string[], required?: boolean): E | void;
    /**
     * Check if the object is a function
     *
     * @param {string} key object key
     * @param {*} value object to check
     * @returns {*} error, if any
     */
    'function'(key: string, value: unknown): E | void;
    /**
     * If value is a Date, check if valid.
     *
     * @param {string} key
     * @param {*} value
     * @param {boolean} [acceptIsoString=false] whether to fail if the value is a date in the ISO-8601 format.
     *
     * @returns {*} error, if any
     */
    date(key: string, value: unknown, acceptIsoString: boolean): E | void;
    /**
     * Escapes a string for sage usage in a regular expression
     *
     * @param {string} str
     * @return {string}
     * @private
     */
    private static _escapeRegExp;
    private static _isNaN;
    private static _isInt;
}

'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var Valcheck_1 = require("./Valcheck");
var ValcheckNode = /** @class */ (function (_super) {
    __extends(ValcheckNode, _super);
    function ValcheckNode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Check if the given file path points to a readable file.
     *
     * @param {string} key
     * @param {*} value A file path
     * @param {string} [rootPath] Will resolve `value` in `rootPath` instead of current working directory.
     * @returns {*} error, if any
     */
    ValcheckNode.prototype.file = function (key, value, rootPath) {
        var error;
        if ((error = this.string(key, value, true))) {
            return error;
        }
        var stat;
        try {
            if (rootPath) {
                value = path.resolve(rootPath, value);
            }
            stat = fs.statSync(value);
        }
        catch (e) {
            return this._error(key, "must be an existing/readable file (" + value + ")");
        }
        if (!stat.isFile()) {
            return this._error(key, "must be a file (" + value + ")");
        }
    };
    /**
     * Check if `value` is a directory.
     *
     * @param {string} key
     * @param {*} value
     * @param {string} [rootPath] Will resolve `value` in `rootPath` instead of current working directory.
     * @returns {*} error, if any
     */
    ValcheckNode.prototype.dir = function (key, value, rootPath) {
        var error;
        if ((error = this.string(key, value, true))) {
            return error;
        }
        var stat;
        try {
            if (rootPath) {
                value = path.resolve(rootPath, value);
            }
            stat = fs.statSync(value);
        }
        catch (e) {
            return this._error(key, "must be an existing/readable directory (" + value + ")");
        }
        if (!stat.isDirectory()) {
            return this._error(key, "must be a directory (" + value + ")");
        }
    };
    return ValcheckNode;
}(Valcheck_1.Valcheck));
exports.ValcheckNode = ValcheckNode;
//# sourceMappingURL=ValcheckNode.js.map
/**
 * Copyright Linkurious SAS 2012 - 2019
 *
 * - Created on 2019-10-30.
 */
import { GenericObject, IDataSourceParams, IGetSubGraphParams } from '../commonTypes';
import { LkEdge, LkNode } from '../graphItemTypes';
import { EntityType } from '../GraphSchema';
export declare enum IndexationStatus {
    ONGOING = "ongoing",
    DONE = "done",
    NEEDED = "needed"
}
export interface GetIndexationStatusResponse {
    indexing: IndexationStatus;
    indexingProgress?: string;
    indexingStatus: string;
    nodeCount?: number;
    edgeCount?: number;
    indexSize?: number;
    indexedSource?: string;
}
export interface ISearchParams extends IDataSourceParams {
    type: EntityType;
    q: string;
    fuzziness?: number;
    size?: number;
    from?: number;
    categoriesOrTypes?: [string];
    filter?: Array<[string, string]>;
}
export interface SearchResponse {
    searchQuery: SearchQuery;
    type: EntityType;
    totalHits?: number;
    moreResults?: boolean;
    results: Array<LkNode | LkEdge>;
}
export interface ISearchFullParams extends IGetSubGraphParams, ISearchParams {
}
export declare enum SearchSyntaxErrorKey {
    /**
     * 1. Detectable errors by checking one statement
     */
    INVALID_FUZZINESS = "invalid-fuzziness",
    SEVERAL_FUZZINESS = "several-fuzziness",
    INVALID_SCOPE = "invalid-scope",
    CONFLICTING_SCOPES = "conflicting-scopes",
    EDGES_NOT_SEARCHABLE = "edges-not-searchable",
    INCOMPATIBLE_TYPE_STATEMENTS = "incompatible-type-statements",
    UNSUPPORTED_OPERATOR = "unsupported-operator",
    /**
     * 2. Detectable errors by checking two statements
     */
    NODE_TYPE_NOT_SEARCHABLE = "node-type-not-searchable",
    EDGE_TYPE_NOT_SEARCHABLE = "edge-type-not-searchable",
    PROPERTIES_NOT_SEARCHABLE = "properties-not-searchable",
    COMPARATOR_TYPE_MISMATCH = "comparator-type-mismatch",
    COMPARATOR_WITH_STRING = "comparator-with-string",
    EMPTY_SEARCH = "empty-search",
    /**
     * 3. Any other error
     */
    SYNTAX_ERROR = "syntax-error"
}
export declare type SearchSyntaxError = {
    offset: [number, number];
} & ({
    errorKey: SearchSyntaxErrorKey.SEVERAL_FUZZINESS | SearchSyntaxErrorKey.CONFLICTING_SCOPES | SearchSyntaxErrorKey.EDGES_NOT_SEARCHABLE | SearchSyntaxErrorKey.INCOMPATIBLE_TYPE_STATEMENTS | SearchSyntaxErrorKey.UNSUPPORTED_OPERATOR | SearchSyntaxErrorKey.EMPTY_SEARCH | SearchSyntaxErrorKey.SYNTAX_ERROR;
} | {
    errorKey: SearchSyntaxErrorKey.COMPARATOR_TYPE_MISMATCH;
    filterType: 'numerical' | 'date';
    propertyKey: string;
    propertyType: string;
    itemType?: string;
} | {
    errorKey: SearchSyntaxErrorKey.COMPARATOR_WITH_STRING;
    filterType: 'numerical' | 'date';
    propertyValue: string;
} | {
    errorKey: SearchSyntaxErrorKey.EDGE_TYPE_NOT_SEARCHABLE | SearchSyntaxErrorKey.NODE_TYPE_NOT_SEARCHABLE;
    itemType: string;
} | {
    errorKey: SearchSyntaxErrorKey.INVALID_FUZZINESS | SearchSyntaxErrorKey.INVALID_SCOPE;
    propertyValue: string;
} | {
    errorKey: SearchSyntaxErrorKey.PROPERTIES_NOT_SEARCHABLE;
    propertyKeys: string[];
    itemType?: string;
});
export declare type FilterStatement = {
    key: string;
    min: string;
    max: string;
} | {
    key: string;
    min: string;
} | {
    key: string;
    max: string;
};
export interface TermStatement {
    key?: string;
    term: string;
    type: 'text' | 'number' | 'date' | 'boolean';
    prefix: boolean;
}
export interface PhraseStatement {
    key?: string;
    phrase: string;
    prefix: boolean;
}
export interface SearchQuery {
    fuzziness: number;
    entityType: EntityType;
    propertiesPerTypes: GenericObject<{
        text: string[];
        number: string[];
        date: string[];
        boolean: string[];
    }>;
    terms: TermStatement[];
    phrases: PhraseStatement[];
    filters: FilterStatement[];
}
